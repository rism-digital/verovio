{"version":3,"file":"build/aruspix.js","sources":["..//src/mus/emscripten_main.cpp","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/iosfwd","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/memory","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/string","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/__functional_base","..//src/mus/mus.h","..//src/mus/mus.cpp","..//src/mus/musaligner.cpp","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/vector","..//src/mus/musaligner.h","..//src/mus/musobject.h","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/algorithm","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/type_traits","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/__split_buffer","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/cstddef","..//src/mus/musapp.cpp","..//src/mus/muslayerelement.h","..//src/mus/musbarline.cpp","..//src/mus/musbarline.h","..//src/mus/musmeasure.cpp","..//src/mus/musstaff.h","..//src/mus/musmeasure.h","..//src/mus/musbboxdc.cpp","..//src/mus/musdc.h","..//src/mus/musbboxdc.h","..//src/mus/musbeam.cpp","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/list","..//src/mus/musbeam.h","..//src/mus/musclef.cpp","..//src/mus/musclef.h","..//src/mus/muscontroller.cpp","./lib/jsonxx/jsonxx.h","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/map","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/__tree","..//src/mus/muscontroller.h","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/ostream","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/iterator","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/ios","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/__locale","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/fstream","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/locale","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/streambuf","..//src/mus/musdc.cpp","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/istream","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/sstream","..//src/mus/musdoc.cpp","..//src/mus/musdoc.h","..//src/mus/musscoredef.h","..//src/mus/musdurationinterface.cpp","..//src/mus/musio.cpp","..//src/mus/musio.h","..//src/tinyxml/tinyxml.h","..//src/mus/muslayer.h","..//src/mus/musmultirest.h","..//src/mus/musiomei.cpp","..//src/mus/muspage.h","..//src/mus/mussystem.h","..//src/mus/mustuplet.h","..//src/tinyxml/tinystr.h","..//src/mus/musiomusxml.cpp","..//src/mus/musiopae.cpp","..//src/mus/musiopae.h","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/utility","..//src/mus/muskeysig.cpp","..//src/mus/muskeysig.h","..//src/mus/muslayer.cpp","/Users/xhero/devel/emsdk_portable/emscripten/1.7.8/system/include/libcxx/typeinfo","..//src/mus/muslayerelement.cpp","..//src/mus/musmensur.h","..//src/mus/musnote.h","..//src/mus/musrest.h","..//src/mus/mussymbol.h","..//src/mus/muspositioninterface.h","..//src/mus/musdurationinterface.h","..//src/mus/muspitchinterface.h","..//src/mus/musleipzigbbox.cpp","..//src/mus/musmensur.cpp","..//src/mus/musmultirest.cpp","..//src/mus/musnote.cpp","..//src/mus/musobject.cpp","..//src/mus/muspage.cpp","..//src/mus/muspitchinterface.cpp","..//src/mus/muspositioninterface.cpp","..//src/mus/musrc.cpp","..//src/mus/musrc.h","..//src/mus/musrc_beam.cpp","..//src/mus/musrc_bezier.cpp","..//src/mus/musrc_element.cpp","..//src/mus/mustie.h","..//src/mus/musapp.h","..//src/mus/musrc_graph.cpp","..//src/mus/musrc_page.cpp","..//src/mus/musrc_tuplet.cpp","..//src/mus/musrest.cpp","..//src/mus/musscoredef.cpp","..//src/mus/musstaff.cpp","..//src/mus/mussvgdc.cpp","..//src/mus/mussymbol.cpp","..//src/mus/mussystem.cpp","..//src/mus/mustie.cpp","..//src/mus/mustuplet.cpp","..//src/tinyxml/tinystr.cpp","..//src/tinyxml/tinyxml.cpp","..//src/tinyxml/tinyxmlparser.cpp","lib/jsonxx/jsonxx.cc"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;ACmzDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AH9yDA;;;;ACkzDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;;;;;;;;;;;AFwnCA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;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A;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AAGA;;AAAA;AAAA;AAEA;;;;AAFA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;AAEA;AAAA;AAAA;;;;;;;;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC8sCA;AAAA;AAAA;AAAA;AAAA;ADlsCA;AAAA;AAAA;;;;ACksCA;AAAA;AAAA;AAAA;AAAA;ADjsCA;AAAA;AAAA;;;;ACisCA;AAAA;AAAA;AAAA;AAAA;ADhsCA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;ACqrCA;AAAA;AAAA;AAAA;AAAA;AD9qCA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;;;;;;;;;;;;;ACsqCA;AAAA;AAAA;AAAA;AAAA;AD9pCA;AAAA;AAAA;AAIA;AAAA;AAEA;;;;;;;;;;;;;ACwpCA;AAAA;AAAA;AAAA;AAAA;ADjpCA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;;;;;;;;;;;;;;;;ACuoCA;AAAA;AAAA;AAAA;AAAA;AD/nCA;AAAA;AAAA;;;;AC+nCA;AAAA;AAAA;AAAA;AAAA;AD9nCA;AAAA;AAAA;AAIA;AAAA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;ACunCA;AAAA;AAAA;AAAA;AAAA;AD/mCA;AAAA;AAAA;;;;AC+mCA;AAAA;AAAA;AAAA;AAAA;AD9m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A;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAPA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArBs8CA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;A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;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AtChBA;;AAAA;AAAA;AAgBA;;;;AAhBA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AsCgjBA;AAAA;AAAA;AAAA;AAAA;AACA;;ADruBA;AAAA;AAAA;ACquBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;ADlFA;AAAA;AAAA;AAAA;AAAA;ACkFA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;AE7eA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AF4eA;;;;;AE5dA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AF6dA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAGA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3NA;;;;;;AElTA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFiTA;;;;;AEjSA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AFiSA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;A5ByzDA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4BjzDA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;ADsCA;AAAA;AAAA;AAAA;AAAA;ACtCA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AtCjUA;AAAA;AAAA;AAAA;;;;;;;;;AsCkUA;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;AtC/UA;AAAA;AAAA;AAAA;;;;;;;;;AsCiVA;;AAOA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AtCxVA;AAAA;AAAA;AAAA;;;;;;;;;AsCyVA;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AtC1VA;AAAA;AAAA;AAAA;;;;;;;;;AsC4VA;AAAA;AAAA;AAAA;;;AAAA;;;ApCvVA;AAAA;AAAA;AAAA;AoCwVA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AtCpWA;AAAA;AAAA;AAAA;;;;;;;;;AsCqWA;;AAKA;AAAA;;;ApCxWA;;;;;;;AoCwWA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AtC1WA;AAAA;AAAA;AAAA;;;;;;;;;AsC2WA;;AAEA;;;ApCzWA;AAAA;AAAA;AAAA;AoCyWA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AEnqBA;AAAA;AFmqBA;;;AEpqBA;AAAA;AFoqBA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AD5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC4CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;AACA;;;AEhsBA;AAAA;AFgsBA;;;AEjsBA;AAAA;AFisBA;AAAA;AAAA;;;;;;;AAAA;;AAGA;AAAA;;;ADjDA;AAAA;AAAA;AAAA;AAAA;ACiDA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;;;AEtsBA;AAAA;AFssBA;;;AEvsBA;AAAA;AFusBA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;;AAAA;;AAGA;;;AE1sBA;AAAA;AF0sBA;;;AEzsBA;AAAA;AFysBA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;AE9sBA;AAAA;AF8sBA;;;AE/sBA;AAAA;AF+sBA;AAAA;AAAA;;;;;;;AD/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC+CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;;;;;AACA;AACA;;;;;;AAOA;AAAA;;;;;;;AAAA;;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AE7dA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AF4dA;AAAA;AACA;;;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3UA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAEA;;;AE3ZA;AAAA;AF2ZA;AAAA;;AACA;AAAA;AAAA;;;;;;AE3JA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFyJA;;AACA;AAAA;AAAA;;AAAA;;AAAA;;;AE5ZA;AAAA;AF4ZA;;;AE9ZA;AAAA;AF8ZA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A5B26DA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA7zDA;AAAA;AAAA;AAAA;AAAA;AA6zDA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4Bn6DA;AAAA;;AAAA;AAAA;AACA;AACA;;;AE/ZA;AAAA;AF+ZA;;;AE9ZA;AAAA;AF8ZA;AAAA;;AAEA;;;AElaA;AAAA;AFkaA;;;AEhaA;AAAA;AFgaA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;;;AEnaA;AAAA;AFmaA;;;AEraA;AAAA;AFqaA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AEtaA;AAAA;AFsaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;AEzaA;AAAA;AF0aA;;;AE1aA;AAAA;AF0aA;AAAA;AACA;;;AE3aA;AAAA;AF2aA;AAAA;AAAA;AAAA;;;;;;AEzKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFwKA;;;AE3aA;AAAA;AF2aA;;ApC+EA;AAAA;AoC/EA;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A5Bq5DA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA7zDA;AAAA;AAAA;AAAA;AAAA;AA6zDA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4B74DA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AElcA;AAAA;AFkcA;AAAA;AACA;;;AEncA;AAAA;AFmcA;AAAA;AAAA;;;;;;;;;;AD2MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC3MA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AEpMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFmMA;;;AEtcA;AAAA;AFscA;;ApCoDA;AAAA;AoCpDA;AACA;;AACA;AAAA;;;AEzcA;AAAA;AFycA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;AE3cA;AAAA;AF2cA;;;AE3cA;AAAA;AF2cA;AAAA;AAAA;;;;;;AEzMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFwMA;;;AE3cA;AAAA;AF2cA;;ApC+CA;AAAA;AoC/CA;AACA;;;;AACA;;;;AAEA;;AAEA;;;AEjdA;AAAA;AFidA;;ApCyCA;AAAA;AoCzCA;;;AACA;;;AEndA;AAAA;AFmdA;AAAA;;AACA;;;;;;AElNA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFgNA;;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;;AAAA;;;AE5dA;AAAA;AF4dA;;;AE3dA;AAAA;AF2dA;AAAA;;AAEA;;;ApCgCA;AAAA;AAAA;AoChCA;;AAEA;;;;AEvOA;AAAA;AAAA;AAAA;AAAA;AFwOA;;ApCoBA;;;AASA;AAAA;AAAA;AATA;;AAAA;;AAAA;AAAA;;AAAA;AoCpBA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;ApCoBA;AAAA;AoCpBA;;;AEneA;AAAA;AFmeA;AAAA;;;ApCXA;AAAA;AAAA;AAAA;AAAA;AoCWA;;AAEA;;;;AE7OA;AAAA;AAAA;AAAA;AAAA;AF8OA;;ApCiBA;AAAA;AoCjBA;;;AEteA;AAAA;AFseA;AACA;AAAA;AAAA;;AAEA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAEA;;;AE/eA;AAAA;AF+eA;AACA;;;AE9eA;AAAA;AF8eA;AACA;;;ApCMA;AAAA;AAAA;AoCNA;;AAEA;;;AElfA;AAAA;AFkfA;AAAA;;AACA;AAAA;;;;;AEvOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AFsOA;;AACA;;ApCJA;AAAA;AoCIA;;;AEpfA;AAAA;AFofA;AACA;;;;AEjPA;AAAA;AAAA;AAAA;AAAA;AFkPA;;AACA;;;AEvfA;AAAA;AFufA;;;AExfA;AAAA;AFwfA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;;;AE3fA;AAAA;AF2fA;;;AE5fA;AAAA;AF4fA;AAAA;AAAA;AAAA;AACA;;;AE7fA;AAAA;AF6fA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAEA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AE3gBA;AAAA;AF2gBA;;;AE1gBA;AAAA;AF0gBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AD6GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC7GA;AAEA;AAAA;;;AE7gBA;AAAA;AF6gBA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AAEA;;;AEhhBA;AAAA;AFghBA;;;AEjhBA;AAAA;AFihBA;AAAA;AAAA;AAAA;AACA;;;AElhBA;AAAA;AFkhBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AE3hBA;AAAA;;;;;AA4QA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AF+QA;AAAA;;;AE3hBA;AAAA;AF2hBA;;;AE7hBA;AAAA;AF6hBA;AAAA;AAAA;;;;AExRA;AAAA;AAAA;AAAA;AAAA;AFyRA;;AACA;;AAEA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;;;AEvRA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AFuRA;;AACA;;ApCxDA;;;AASA;AAAA;AAAA;AATA;;AAAA;;AAAA;AAAA;;AAAA;AoCwDA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AA0PA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;AExiBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFuiBA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AE1hBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AFyhBA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AE7hBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AF6hBA;;AAEA;;;;;AEhiBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AFgiBA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAlCA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;AEngBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AFmgBA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AEvhBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AFqhBA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AE3hBA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AF0hBA;AAAA;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtClsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AavMA;;;;AAAA;AAAA;;;;;;;Ab+LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AsCSA;;;AE5BA;AAAA;;;;AHxEA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;ACoGA;;AAAA;;AAEA;;;AE9BA;AAAA;;;;AHhEA;;;AAAA;;;AC8FA;AAAA;AAAA;;AACA;AAAA;;;ADsjBA;AAAA;AAAA;AAAA;AAAA;ACtjBA;AAAA;AAAA;AACA;;;;AtCbA;;AAAA;AAAA;;;;AsCWA;;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAJA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;AAAA;AACA;AAAA;AAAA;AGmDA;;AACA;;;AHvTA;AAAA;AGuTA;;;AHtTA;AAAA;AGsTA;AAAA;;AACA;;;AHxTA;AAAA;AGwTA;;AzCkMA;AAAA;AyClMA;AAAA;;AACA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;;AH1TA;AAAA;AG0TA;AAAA;;AACA;;;AH3TA;AAAA;AG2TA;AAAA;AAAA;;AACA;;;AHpUA;AAAA;AGoUA;;;AHnUA;AAAA;AGmUA;AAAA;;AAEA;;;AzCwLA;AAAA;AAAA;AyCxLA;;AAEA;AAAA;;;AHxUA;AAAA;AGwUA;;;AHvUA;AAAA;AGuUA;AAAA;AAAA;;;;;;AHtEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AGqEA;;AzC4KA;;;AASA;AAAA;AAAA;AATA;;AAAA;;AAAA;AAAA;;AAAA;AyC5KA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;AzC4KA;AAAA;AyC5KA;;;AH3UA;AAAA;AG2UA;AAAA;;;AzC6IA;AAAA;AAAA;AAAA;AAAA;AyC7IA;;AAEA;AAAA;;;AH9UA;AAAA;AG8UA;;;AH7UA;AAAA;AG6UA;AAAA;AAAA;;;;;;AH5EA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AG2EA;;AzCyKA;AAAA;AyCzKA;;;AH9UA;AAAA;AG8UA;AACA;AAAA;AAAA;;AAEA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;;;AzCoKA;AAAA;AAAA;AyCpKA;;AAEA;;;AH3VA;AAAA;AG2VA;;;AH5VA;AAAA;AG4VA;AAAA;AAAA;AAAA;AACA;;;AHrVA;AAAA;AGqVA;;;AHpVA;AAAA;AGoVA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAKA;;;AH7VA;AAAA;;;AG6VA;;;AH9VA;AAAA;;;AG8VA;AAAA;AAAA;AAAA;AACA;AAAA;AAA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AAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;AACA;;;;AAFA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;;;AACA;;AAAA;AACA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAFA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;;;AArBA;;AAAA;AAAA;AAEA;;;;AAFA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ArCo4CA;AAAA;AAAA;AAAA;AAAA;AqC52CA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;ArCw7CA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AqC97CA;AAAA;AACA;;;;;;;;;AAIA;AACA;;;;;;;ACSA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADLA;AACA;AAAA;;AACA;;;;;ArCuaA;;;AAlDA;;;AAAA;;;;AMxYA;;;;AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;;;A2CvgEA;AAAA;;;;ArCy6CA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;AqC/6CA;AAAA;;;;ArCw6CA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;;;;;AqC96CA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAGA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;ArC00CA;AAAA;AAAA;AAAA;AAAA;;;AqC10CA;AAAA;AAAA;AACA;AAAA;;AAEA;;AALA;AAAA;AAAA;AAAA;;;;AAVA;;AAAA;AAAA;;;;AAGA;;AAAA;AAAA;;;;AAGA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAUA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAVA;AAAA;;;;;;;;;;;AEFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;ArCbA;;;AFqkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AErkBA;;;;;;;AAwXA;AAAA;;;;;;;;;;;;;;;AmC3VA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AtBzDA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AsB8DA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AADA;;AAAA;AAAA;;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AADA;;AAAA;AAA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A;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;A/CLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgD1EA;AAAA;;;;;AhDg9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAnuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A0CCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ANqXA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;ApC2WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AsCCA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;AUj9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AAAA;;;;AAAA;;AAAA;AAGA;AAAA;AAAA;AAHA;;;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AAGA;;AAAA;AAAA;AAIA;;;;AAJA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AAJA;;AAAA;AAAA;AAAA;AA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;;;;AnD83DA;AAAA;AAAA;AAAA;AmD94DA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;AnD5QA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;AoDwvBA;AACA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnDA;AACA;;;AnDy7DA;AAAA;AAAA;AAAA;AmDx7DA;;AAAA;AAAA;;;;AnDw7DA;AAAA;AAAA;AAAA;AmDv7DA;;AAAA;AAAA;;;;AnDu7DA;AAAA;AAAA;AAAA;AmDt7DA;;AAAA;AAAA;;;;AnDs7DA;AAAA;AAAA;AAAA;AmDr7DA;;AAAA;AAAA;;;;AnDq7DA;AAAA;AAAA;AAAA;AmDp7DA;;AAAA;AAAA;;;;AnDo7DA;AAAA;AAAA;AAAA;AmDn7DA;;AAAA;AAAA;;;;AnDm7DA;AAAA;AAAA;AAAA;AmDl7DA;;AAAA;AAAA;;;;AnDk7DA;AAAA;AAAA;AAAA;AmDj7DA;;AAAA;AAAA;;;;AnDi7DA;AAAA;AAAA;AAAA;AmDh7DA;;AAAA;AAAA;;;;AnDg7DA;AAAA;AAAA;AAAA;AmD/6DA;;AAAA;AAAA;;;;;;;;;;AnDzOA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;;;;;;;;;AC0eA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;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;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmD9gFA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;ArDwsBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmD3gFA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;ArDqsBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmDxgFA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;ArDksBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmDrgFA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;ArD+rBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmDlgFA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;ArD4rBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmD//EA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;ArDyrBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmD5/EA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;;;ArDsrBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;;;AAu0DA;AAAA;AAAA;AAAA;AmDz/EA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;;;ArDkrBA;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;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;ADpsDA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlDkmHA;AAAA;AAAA;AAAA;AmD79DA;;AAAA;AAAA;;;;AnD69DA;AAAA;AAAA;AAAA;AmD59DA;;AAAA;AAAA;;;;AnD49DA;AAAA;AAAA;AAAA;AmD39DA;;AAAA;AAAA;;;;AnD29DA;AAAA;AAAA;AAAA;AmD19DA;;AAAA;AAAA;;;;AnD09DA;AAAA;AAAA;AAAA;AmDz9DA;;AAAA;AAAA;;;;AnDy9DA;AAAA;AAAA;AAAA;AmDx9DA;;AAAA;AAAA;;;;AnDw9DA;AAAA;AAAA;AAAA;AmDv9DA;;AAAA;AAAA;;;;;;;;;;AnDjMA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;AoD6qBA;AACA;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AnDtMA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;AoD+pBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AnDm+DA;AAAA;AAAA;AAAA;AmD7/DA;;AAAA;AAAA;;;;AnD6/DA;AAAA;AAAA;AAAA;AmD5/DA;;AAAA;AAAA;;;;AnD4/DA;AAAA;AAAA;AAAA;AmD3/DA;;AAAA;AAAA;;;;AnD2/DA;AAAA;AAAA;AAAA;AmD1/DA;;AAAA;AAAA;;;;AnD0/DA;AAAA;AAAA;AAAA;AmDz/DA;;AAAA;AAAA;;;;AnDy/DA;AAAA;AAAA;AAAA;AmDx/DA;;AAAA;AAAA;;;;AnDw/DA;AAAA;AAAA;AAAA;AmDv/DA;;AAAA;AAAA;;;;AnDu/DA;AAAA;AAAA;AAAA;AmDt/DA;;AAAA;AAAA;;;;AnDs/DA;AAAA;AAAA;AAAA;AmDr/DA;;AAAA;AAAA;;;;AnDq/DA;AAAA;AAAA;AAAA;AmDp/DA;;AAAA;AAAA;;;;AnDo/DA;AAAA;AAAA;AAAA;AmDn/DA;;AAAA;AAAA;;;;AnDm/DA;AAAA;AAAA;AAAA;AmDl/DA;;AAAA;AAAA;;;;AnDk/DA;AAAA;AAAA;AAAA;AmDj/DA;;AAAA;AAAA;;;;AnDi/DA;AAAA;AAAA;AAAA;AmDh/DA;;AAAA;AAAA;;;;AnDg/DA;AAAA;AAAA;AAAA;AmD/+DA;;AAAA;AAAA;;;;AnD++DA;AAAA;AAAA;AAAA;AmD9+DA;;AAAA;AAAA;;;;AnD8+DA;AAAA;AAAA;AAAA;AmD7+DA;;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AnDw+DA;AAAA;AAAA;AAAA;AmD38DA;;AAAA;AAAA;;;;AnD28DA;AAAA;AAAA;AAAA;AmD18DA;;AAAA;AAAA;;;;AnD08DA;AAAA;AAAA;AAAA;AmDz8DA;;AAAA;AAAA;;;;AnDy8DA;AAAA;AAAA;AAAA;AmDx8DA;;AAAA;AAAA;;;;AnDw8DA;AAAA;AAAA;AAAA;AmDv8DA;;AAAA;AAAA;;;;AnDu8DA;AAAA;AAAA;AAAA;AmDt8DA;;AAAA;AAAA;;;;AnDs8DA;AAAA;AAAA;AAAA;AmDr8DA;;AAAA;AAAA;;;;;;;;;;AnDnNA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;AoD+rBA;AACA;;;;;;;;;;;;;;;AAEA;AAAA;;;;;;;;;;;;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SA;AAAA;ApC0SA;AAAA;A2D3hBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;A3DuqDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;AyDjgDA;;;;;ApDgaA;;;AAlDA;;;AAAA;;;;AMxYA;;;;AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;;;A0DjgEA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;AANA;;AAAA;AAAA;;;;AACA;;AAAA;AAKA;;AAAA;;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;ApD+XA;AAAA;;;;;;;;;;;;AoD5XA;;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;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AAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;ApD4aA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoD5aA;;;;ApDssCA;AAAA;AAAA;AAAA;AAAA;;;AoDtsCA;AAAA;AACA;AAAA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ApDyXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoDzXA;AAAA;;;;ApDyXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoDxXA;;;;ApDkpCA;AAAA;AAAA;AAAA;AAAA;;;AoDlpCA;;AACA;AAAA;;;;ApD+/BA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AA55BA;;;AAAA;;;;AA65BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;AoD5/BA;AAAA;;;ApDmXA;;;;;AAxSA;;;ANu+DA;;;AAnLA;AMxyDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoDvFA;;;;ApD0oCA;AAAA;AAAA;AAAA;AAAA;;;AoD1oCA;AAAA;AAAA;AAAA;;AACA;;;;ApDyoCA;AAAA;AAAA;AAAA;AAAA;;;AoDzoCA;AAAA;AAAA;;;;AARA;;AAAA;AASA;;AAAA;;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;;;;ApDytCA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;AoD9tCA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AAHA;;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;;AAGA;;;ApDyUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AoDzUA;AAAA;;;;;ApDyrCA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;AoD7rCA;;;ApDsaA;;;AA5XA;AAAA;;;;AA2EA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA7FA;;;ANk/DA;;;AAnLA;AMjuDA;AAAA;AAAA;AAAA;;AN+kBA;;;AA4bA;AAAA;AAAA;;;AAAA;;;AAsGA;AMjnCA;;;;AoDrHA;;AAGA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;AAAA;AACA;;AAAA;AAAA;;AAAA;AAEA;;;;;;;ApDujCA;AAAA;AAAA;;;;AArBA;;;;A4BhLA;;;;AAAA;AAAA;AAAA;AwB/2BA;AAAA;AAAA;AAAA;;;;ApDokCA;AAAA;AAAA;;;;AArCA;;;;A4BhLA;;;;AAAA;AAAA;AAAA;;;AA+EA;;;AAxFA;AAAA;AAwFA;;;AAxFA;AAAA;AAwFA;AwB97BA;;AAGA;;AAAA;AAAA;;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AxBqyBA;AAAA;AwBnyBA;;AACA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;;;;;AxBozBA;AAAA;AAAA;;;AAJA;AAAA;AAAA;AAAA;AwB9zBA;;;;AANA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AAQA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;;;AAOA;;AAAA;AAEA;;AAAA;;AAGA;;AAAA;AAAA;;AAAA;AACA;;AAAA;AAAA;;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;;AAAA;AAAA;;;;AARA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;AAAA;AAAA;;AAOA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AA5EA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3DuXA;AAAA;AAAA;;;AAlCA;;;AoC1SA;AAAA;ApC0SA;AAAA;AAkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAnXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A0CCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ANqXA;AAAA;AAAA;;;AACA;AAAA;AACA;AAAA;ApCLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AA1ZA;AAAA;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;;;;;AAsgDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AFh2CA;AAAA;AAAA;AAAA;AAAA;A2CCA;AAAA;;;;AAAA;;AAAA;AACA;;AAAA;AAAA;;AAAA;AAAA;;;;;;A3C0ZA;;AAAA;A2CCA;AAAA;;;AA3ZA;AAAA;;;;A3C0ZA;;AAAA;AAAA;;A2CCA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;AgBhiBA;AAAA;;;AAGA;AADA;;;;AAFA;;AAAA;AAGA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;ACkBA;AAAA;;;;;;;AA1FA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AD2qCA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;;AAGA;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;AALA;AAAA;AAAA;AAAA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AzB9UA;AAAA;;;;AA9uBA;AAAA;AAAA;;;AA+uBA;;AAGA;;AhC3UA;;;;;AgC2UA;AACA;;;;AC9FA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACjMA;;;AAvWA;AAAA;AAuWA;ADiMA;AD8FA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AEpiBA;AAAA;;;AFoiBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AExPA;AAAA;;;AlC/DA;AAAA;AAAA;AkC+DA;;;;;AARA;;;;AChjBA;;;AAAA;ADgjBA;;;;ACnKA;AAAA;AAAA;AAAA;AAAA;;;;;ADmKA;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;AASA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AFsPA;;;;ACzFA;AAAA;AAAA;ADyFA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AElZA;AAAA;;;;AAjEA;AAAA;AAAA;AAAA;;;;;AFmdA;;;;AAbA;;AAAA;AAAA;;;;;;;;AACA;;AAAA;AAeA;;AAFA;;AAEA;;AAAA;;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;;AAHA;;AAAA;AACA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAJA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AyBnNA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AAEA;;;;;;;AAKA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4GA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;;;ApDolBA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AoD3lBA;;AACA;AAAA;AAAA;;;;ApDmlBA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AoD1lBA;;AACA;AAAA;AAAA;;;;ApDklBA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AoDzlBA;;AACA;AAAA;AAAA;;;;ApDilBA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AoDxlBA;;AACA;AAAA;AAAA;;;;ApDglBA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AoDvlBA;;AACA;AAAA;AAAA;;;;ApD+kBA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AoDtlBA;;AACA;AAAA;AAAA;;;;ApD8kBA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;AoDrlBA;;AAEA;AAMA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AACA;AAAA;AAAA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AAOA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAEA;;AAEA;;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;AzBnRA;AAAA;AyBoRA;;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;AAWA;AAAA;AAIA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAYA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AACA;;AACA;;AACA;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0UA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;ApDkdA;AAAA;AAAA;AAAA;AAAA;AoDldA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;ApDidA;AAAA;AAAA;AAAA;AAAA;AoDjdA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;;AAKA;;AACA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA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AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AACA;AAAA;;AAEA;;AAEA;AAAA;;;;;;;;;;;;;;A3D/iBA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;A4DpEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;;;;;;;;;AAnBA;AAAA;AAAA;;;;;;;;;;;;;;;ADsjCA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAPA;;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAVA;;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA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;;;;;;;;;AqD9VA;;;;;ArD4XA;;;AAlDA;;;AAAA;;;;AMxYA;;;;AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;A2D99DA;;;;;ArD4XA;;;AAlDA;;;AAAA;;;;AMxYA;;;;AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;;;A2D99DA;;;;;ArD4XA;;;AAlDA;;;AAAA;;;;AMxYA;;;;AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;;;A2D99DA;;;;;ArD4XA;;;AAlDA;;;AAAA;;;;AMxYA;;;;AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;;;A2D99DA;;;;;A5DmoDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;A0D59CA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;ArDqpCA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AA55BA;;;AAAA;;;;AA65BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;AqDvpCA;AAAA;AAAA;;;;ArDmpCA;AAAA;AAAA;;AAEA;AAAA;AA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AAA;AuC70BA;;;;;;;;;;;;;;;;AAiDA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AACA;;;;;;;;;AlBXA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA1KA;AAAA;AAAA;;;;;;;;;;AA2KA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AlBrNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoC8PA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AC9LA;;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AD8LA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AvCslBA;;;AA/VA;;;AxB6yDA;;;AAnLA;AwB3xCA;AuCtlBA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAqBA;AAEA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;AbzTA;AAAA;;;A5CmmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A4CnmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5C63CA;AAAA;AAAA;AAAA;AAAA;AyDtyBA;AAAA;AAAA;;;;AzDsyBA;AAAA;AAAA;AAAA;AAAA;AyDpyBA;AAAA;AAAA;;;;AzDoyBA;AAAA;AAAA;AAAA;AAAA;AyDlyBA;AAAA;AAA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;;;;;AD2NA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AElMA;AAAA;AAAA;;;;;;;;;;AFiNA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AGzOA;AAAA;AAAA;;;;;;;;;;AH2LA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;AIxLA;AAAA;AAAA;;;;;;;AJuGA;;;;;;;;;;;;;;;;AAKA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AACA;;;;;;;;;;;;AAwGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAzGA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;AAoCA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAiBA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;A3D4sCA;AAAA;AAAA;AAAA;AAAA;A2DlqCA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;AAqBA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;A3DinCA;AAAA;AAAA;AAAA;AAAA;A2DzmCA;AAAA;AAAA;;;;A3DymCA;AAAA;AAAA;AAAA;AAAA;A2DxmCA;AAAA;AAAA;AAEA;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;;AACA;AAAA;;AACA;AACA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;AItUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AvDAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AwDLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;A9DuTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;A4DrTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AGKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AJmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AK3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ANEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AvCAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AXAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AKsMA;AAAA;AAAA;AAAA;AAAA;;;;AoD7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;ACnYA;;;;A3EyzDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AyErzDA;;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;AARA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AAYA;;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAIA;AAAA;AACA;AAAA;AACA;;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AA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AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;A6E7iEA;;;;;A9EktDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;A4E5iDA;;;;;A9EktDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;A4E5iDA;;;;;A9EktDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;;;A4E3iDA;;AAAA;;AAAA;;AACA;;;;AADA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AACA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AADA;AAAA;;;;;;;;;;AAMA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AAAA;AAAA;;;;;AvEgcA;;;AAlDA;;;AAAA;;;;AMxYA;;;;AAAA;AAAA;;;ANqYA;AAAA;;;;AMrYA;;;;AAAA;AAAA;;;ANsYA;AAAA;;;;AMtYA;;;;AAAA;AAAA;;;;;;AZutEA;;;;AAAA;;AUrwBA;AVqwBA;;;;AA3LA;;;AAAA;;AU1kBA;AV0kBA;AAAA;A6EliEA;;;;;A9EusDA;AAAA;;;;;ACohBA;;;AA3LA;;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l/FA;AAAA;AAAA;;;AAk/FA;AAAA;AAAA;;;;AAAA;;AAAA;AAKA;AAAA;AAAA;;AAJA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;A4EjgGA;AAAA;;AACA;AAAA;AAEA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvEoyBA;AAAA;AAAA;AAAA;AAAA;AuE7xBA;AAAA;AAAA;;;;AvE6xBA;AAAA;AAAA;AAAA;AAAA;AuE5xBA;AAAA;AAAA;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AvE4uBA;AAAA;AAAA;AAAA;AAAA;AuEruBA;AAAA;AAAA;;;;AvEquBA;AAAA;AAAA;AAAA;AAAA;AuEpuBA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;A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;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AAIA;;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;ACnCA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;AAIA;;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AAAA;AAAA;;;;;AlFuuDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AgFjkDA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA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A;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAXA;AAAA;AAAA;AAAA;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAQA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;;AAAA;;AAGA;;AAhBA;AAAA;AAAA;AAAA;;AAkBA;AAAA;AAAA;;AAAA;;AAMA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AA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A;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;;AAEA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;AACA;;AAlDA;AAAA;AAAA;AAAA;;AAoDA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AACA;;AAtGA;AAAA;AAAA;AAAA;;AAwGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAaA;AAAA;AAAA;AAAA;;AACA;;AAaA;;AACA;;;;;;;;;AC5wBA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAwMA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AC5KA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;AAAA;;;AAMA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+4BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtFq0BA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFj0BA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AALA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAdA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/0BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtF8oDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoF1oDA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;A/E8cA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A+E9cA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;A/EuuCA;AAAA;AAAA;AAAA;AAAA;A+EvuCA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAHA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAGA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;A/EsuCA;AAAA;AAAA;AAAA;AAAA;A+EtuCA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AALA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAbA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA21BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtF6yBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFzyBA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAPA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAaA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AA1DA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmYA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtF8ZA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoF1ZA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAVA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAYA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAbA;AAAA;AAAA;AAAA;;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;;AAnBA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjVA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtFyuBA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFruBA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;;;;;AAVA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAaA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAvFA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhaA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtFooCA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFhoCA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AANA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AtFoJA;AAAA;AAAA;;;AAvQA;;;AoC1SA;AAAA;ApC0SA;AAAA;AAuQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAulBA;AAAA;AAAA;;;;;;AA/qCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A0CCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;ANqXA;AAAA;AAAA;;;AACA;AAAA;AACA;AAAA;ApCuzBA;AAAA;AAAA;AAAA;;;;;AAnwCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmwCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAzoBA;;;;AAFA;AAAA;AAAA;AAAA;AAAA;;;;;AAghDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AF12CA;AAAA;AAAA;AAAA;AAAA;;;;;AAghDA;AAAA;;;;;ACohBA;;;AA3LA;;;AAAA;;;AChgBA;;;ADqvBA;;;AAnLA;AClkBA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AyCz2CA;;AAAA;;;;AAAA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AACA;;AAAA;AAAA;;AAAA;AAAA;;;;;;A3CyoBA;;AAAA;A2CCA;AAAA;;;AA3oBA;AAAA;;;;A3C0oBA;;AAAA;AAAA;;A2CCA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;A2CjJA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;A3C+MA;;;;;A2C/MA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A3C4MA;;;;;A2C5MA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;;;;AAXA;;AAAA;AAAA;;;;AAEA;;AAAA;AAAA;;AAAA;;;;AAGA;;AAAA;AAAA;;AAAA;;AAMA;;AAAA;;AA/CA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAplBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtFwsDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFpsDA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;AATA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtFwrDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFprDA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AANA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAmBA;;AACA;;AAhDA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAurCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAIA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmHA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AACA;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtFsUA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFlUA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AALA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAEA;;AAZA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvzCA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AtFwnDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoFpnDA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;A/EubA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A+EvbA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;A/EgtCA;AAAA;AAAA;AAAA;AAAA;A+EhtCA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAJA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;AAIA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;A/E+sCA;AAAA;AAAA;AAAA;AAAA;A+E/sCA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AALA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAdA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA65CA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;A/EjNA;AAAA;AAAA;AAAA;AAAA;A+EiNA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;A/EpNA;AAAA;AAAA;AAAA;AAAA;A+EoNA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AACA;;AAEA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;;AAjBA;AAAA;AAAA;AAAA;;AA2BA;;AA/BA;AAAA;AAAA;AAAA;;AAgCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA16CA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A5EmsEA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA7zDA;AAAA;AAAA;AAAA;AAAA;AA6zDA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4E3rEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A5EmwEA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4E3vEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A5EurEA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA7zDA;AAAA;AAAA;AAAA;AAAA;AA6zDA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4E/qEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A5EuvEA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4E/uEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAIA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAWA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAEA;;AACA;;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;;AAGA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AADA;;AAAA;AACA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAWA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAqDA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AA1GA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAgHA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAGA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;A5E21DA;AAAA;;;AAAA;;;AAR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AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAIA;AAAA;AACA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAEA;;;;;;;;;;;;;;;;;AA4hBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5sBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A5E+sDA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4EvsDA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;AAAA;AAAA;;AAIA;;;;;;;;;AC7zBA;AAAA;AAAA;;;;;;;AnBwDA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AkBg9CA;AAGA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAj3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;;;;;;;AAwBA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkUA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;;A5E42CA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4Ep2CA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;A5E61CA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A4Er1CA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;;A5Eu0CA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AA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A;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A+EjhFA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;ANsBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AMhBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A/Ek/EA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A+E1+EA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;;A/E26EA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;A+En6EA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAIA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AALA;AAAA;AAAA;AAAA;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+HA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAGA;AACA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;AACA;;AApBA;AAAA;AAAA;AAAA;;AAqBA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AjE2hBA;;;;;AAjWA;;;AxB6yDA;;;AAnLA;AwB1mDA;AAAA;AiE1MA;;AACA;;AAIA;;;AjE+jBA;AAAA;AAAA;AAAA;AAAA;AiE/jBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;;;AjE0kBA;AAAA;AAAA;AAAA;AAAA;AiE1kBA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;AAVA;AAAA;AAAA;AAAA;;AAWA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AAlHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAgLA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAmBA;;;;;;;;;AtExcA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsEwmBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;A1FyrCA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AwFrrCA;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AANA;;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;AnF+vBA;AAAA;AAAA;AAAA;AAAA;AmF/vBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAJA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AA3BA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AArFA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAKA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAGA;AAAA;;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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AAJA;;AAAA;AAIA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA51EA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;;;;;;;;;AC0eA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;A8F73BA;;;;;;;;;A7Fu2CA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;A8F73BA;;;;;;;;;A7Fu2CA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;A8F53BA;;;;;;;;;A7Fs2CA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA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uBA;;;;;A7FguBA;;;;;A6F/tBA;;;;;A7F+tBA;;;;;A6F9tBA;;;;;A7F8tBA;;;;;A6F7tBA;;;;;A7F6tBA;;;;;A6F5tBA;;;;;A7F4tBA;;;;;A6F3tBA;;;;;A7F2tBA;;;;;A6F1tBA;;;;;A7F0tBA;;;;;A6FztBA;;;;;A7FytBA;;;;;A6FxtBA;;;;;A7FwtBA;;;;;A6FvtBA;;;;;A7FutBA;;;;;A6FrtBA;;;;;A7FqtBA;;;;;A6FptBA;;;;;A7FotBA;;;;;A6FltBA;;;;;A7FktBA;;;;;A6FjtBA;;;;;A7FitBA;;;;;A6FhtBA;;;;;A7FgtBA;;;;;A6F/sBA;;;;;A7F+sBA;;;;;A6F9sBA;;;;;A7F8sBA;;;;;A6F7sBA;;;;;A7F6sBA;;;;;A6F5sBA;;;;;A7F4sBA;;;;;A6F3sBA;;;;;A7F2sBA;;;;;A6FzsBA;;;;;A7FysBA;;;;;A6FxsBA;;;;;A7FwsBA;;;;;A6FvsBA;;;;;A7FusBA;;;;;A6FtsBA;;;;;A7FssBA;;;;;A6FpsBA;;;;;A7FosBA;;;;;A6FnsBA;;;;;A7FmsBA;;;;;A6FlsBA;;;;;A7FksBA;;;;;A6FjsBA;;;;;A7FisBA;;;;;A6FhsBA;;;;;A7FgsBA;;;;;A6F/rBA;;;;;A7F+rBA;;;;;A6F9rBA;;;;;A7F8rBA;;;;;A6F7rBA;;;;;A7F6rBA;;;;;A6F3rBA;;;;;A7F2rBA;;;;;A6F1rBA;;;;;A7F0rBA;;;;;A6FzrBA;;;;;A7FyrBA;;;;;A6FxrBA;;;;;A7FwrBA;;;;;A6FvrBA;;;;;A7FurBA;;;;;A6FtrBA;;;;;A7FsrBA;;;;;A6FrrBA;;;;;A7FqrBA;;;;;A6FprBA;;;;;A7ForBA;;;;;A6FnrBA;;;;;A7FmrBA;;;;;A6FlrBA;;;;;A7FkrBA;;;;;A6FjrBA;;;;;A7FirBA;;;;;A6FhrBA;;;;;A7FgrBA;;;;;A6F9qBA;;;;;A7F8qBA;;;;;A6F7qBA;;;;;A7F6qBA;;;;;A6F5qBA;;;;;A7F4qBA;;;;;A6F3qBA;;;;;A7F2qBA;;;;;A6F1qBA;;;;;A7F0qBA;;;;;A6FzqBA;;;;;A7FyqBA;;;;;A6FxqBA;;;;;A7FwqBA;;;;;A6FvqBA;;;;;A7FuqBA;;;;;A6FrqBA;;;;;A7FqqBA;;;;;A6FpqBA;;;;;A7FoqBA;;;;;A6FnqBA;;;;;A7FmqBA;;;;;A6FlqBA;;;;;A7FkqBA;;;;;A6FhqBA;;;;;A7FgqBA;;;;;A6F/pBA;;;;;A7F+pBA;;;;;A6F5pBA;;AAEA;;AACA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;;AAAA;AAAA;;;;;;;A7Fu7BA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzOA;;;;AAuSA;;;AD2xBA;;;AAnLA;ACxmBA;AAAA;AAAA;AAAA;AAvSA;;;;AA6RA;;;ADqyBA;;;AAnLA;AClnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7RA;;AAAA;A6F9sBA;AAAA;;AACA;AAAA;;;;;;;;;;A7Fs7BA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;ACsiEA;AAAA;A6Fl/EA;AAAA;AAEA;AAAA;AAGA;;;AxFi0BA;AAAA;AAAA;;;;AArBA;;;;A4BhLA;;;;AAAA;AAAA;AAAA;A4D5nBA;;;AxFi1BA;AAAA;AAAA;;;;AArCA;;;;A4BhLA;;;;AAAA;AAAA;AAAA;;;A4D5nBA;;;AAAA;;ArFqQA;;;;AyB8eA;AAAA;;;AApDA;;;AA5EA;AAAA;AA4EA;;;AA5EA;AAAA;AA4EA;AAoDA;AzB9eA;;;;AyBsTA;AAAA;AzBrTA;;;ARuyFA;;;;;AA5nEA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzOA;;;;AAuSA;;;AD2xBA;;;AAnLA;ACxmBA;AAAA;AAAA;AAAA;AAvSA;;;;AA6RA;;;ADqyBA;;;AAnLA;AClnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7RA;;AAAA;AAq2EA;AACA;AAAA;;;;;AA7nEA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzOA;;;;AAuSA;;;AD2xBA;;;AAnLA;ACxmBA;AAAA;AAAA;AAAA;AAvSA;;;;AA6RA;;;ADqyBA;;;AAnLA;AClnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7RA;;AAAA;AAs2EA;AAAA;;AACA;AAAA;;AACA;;;;;;;AA/nEA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;ACymFA;AACA;;;;;;;AAhoEA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;AC0mFA;AACA;;;AAjoEA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAioEA;;AACA;AAAA;AAAA;;;;AAl/FA;AAAA;AAAA;;;AAk/FA;AAAA;AAAA;;;;AAAA;;AAAA;AAKA;AAAA;AAAA;;AAJA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;AQlzFA;;AACA;;;;AyBoUA;AAAA;AAAA;AAAA;AzBtUA;;AAGA;AAAA;AAAA;;;;;;;AyBqRA;AAAA;;;;;AAJA;AADA;;;AA2FA;AAAA;AA3FA;A4DvhBA;;;AxFg1BA;AAAA;AAAA;;;;AArCA;;;;A4BhLA;;;;AAAA;AAAA;AAAA;;;AAmEA;;;AA5EA;AAAA;AA4EA;;;AA5EA;AAAA;AA4EA;A4D9rBA;;AAEA;;;;AxFq7BA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;;;;;AwF37BA;;;;AAJA;;AAAA;AAAA;;;;;;;;;;A7Fi7BA;;;ADy1BA;;;AAnLA;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8FA;;;;AAZA;;;ADuwBA;;;AAnLA;ACplBA;AAAA;AAAA;AAAA;AAYA;;;;AANA;;;ADiwBA;;;AAnLA;AC9kBA;AAAA;AAAA;AAAA;;ADhsBA;;AE5zBA;ADkgDA;;AAAA;;ADxkBA;A8F/bA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AArBA;AAAA;AAAA;AAAA;;;;AAeA;;AAAA;AAAA;;AAAA;;AAMA;;AAAA;;AAKA;;AALA;AAAA;;;;;AAAA;;;AANA;AAAA;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;AAKA;;;;;;;;;;;;A3D+UA;;;;;AAjeA;AAAA;AAAA;AACA;;;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA+dA;AAAA;;;;;;;;;;;;;;A2DnTA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;;ApDwTA;AAAA;AoDxTA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AxF42BA;;;AAjpCA;;;ANk/DA;;;AAnLA;AM9qBA;;;AAn2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAo2BA;;;;AA5mBA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAvPA;;;;;AAxSA;;;ANu+DA;;;AAnLA;AMxyDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAohBA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AGoqDA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA73DA;AAAA;AAAA;AAAA;AAAA;AA63DA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AH5pDA;AAAA;AAAA;;AACA;;;AA/PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAo2BA;AAAA;AAEA;AAAA;AAAA;;ANveA;AMueA;;AI8BA;;;;AV9FA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AAAA;;AAAA;;;AMiEA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;;;AAHA;;AAAA;AAGA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;AKjrCA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AL+fA;;;AAreA;;;ANk/DA;;;AAnLA;AM11CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ANkrBA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AA5eA;AA4eA;AAAA;AAAA;;A4D9wCA;;AlDuxCA;;;;AV9EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAsEA;AAAA;AAAA;AAAA;AACA;;AMrrBA;AAAA;AAAA;AAAA;;;AI+xEA;;AAnmDA;AAmmDA;AAAA;AACA;;AApmDA;AAomDA;AAAA;AAAA;;AApmDA;AAqmDA;AAAA;AAAA;AJhyEA;AAAA;AAAA;AAAA;;;AI8xEA;;AAnmDA;AAmmDA;AAAA;AACA;;AApmDA;AAomDA;AAAA;AAAA;;AApmDA;AAqmDA;AAAA;AAAA;AJ/xEA;;;AAleA;;;ANy+DA;;;AAnLA;AMp1CA;;;AKlxBA;;;AXyxEA;;;AAnXA;;;AUyoCA;;AAnmDA;AAmmDA;AAAA;AACA;;AApmDA;AAomDA;AAAA;AAAA;;AApmDA;AAqmDA;AAAA;AAAA;AJ9xEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;;;AK3eA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAnRA;AAAA;;;;AAqDA;;;AAAA;;;;AA6KA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA/PA;;;AX8xEA;;;AAnXA;AAAA;AW3qDA;AAAA;AAAA;AAAA;;AXytBA;;;AA4bA;AAAA;AAAA;;;AAAA;;;AAsGA;;;AW3vCA;;;;AAAA;;AAAA;AACA;AAAA;AAAA;;AA6CA;AAAA;AAAA;AAAA;;;;AA9SA;;;AX8xEA;;;AAnXA;AAAA;AW5nDA;AAAA;;;;;AA5SA;;;AXyxEA;;;AAnXA;AWz4DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AX60CA;AAAA;AAAA;;;;;AA6LA;AAAA;AAAA;AW3vCA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ALyhBA;;;AA1hBA;;;ANg/DA;;;AAnLA;;AAntBA;AAAA;;;AAAA;;AAuGA;;;AMvrBA;AAAA;AAAA;;;AGmnDA;AAAA;;;AAAA;;;AARA;AAAA;;;;;AA7zDA;AAAA;AAAA;AAAA;AAAA;AA6zDA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;AH3mDA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK3jBA;AAAA;;;;AClQA;;;;AAAA;AAAA;;;ADiQA;;;;;AX09DA;AAAA;;;;;AAAA;;AUzwBA;AVywBA;AAAA;;AUzwBA;;;;;AV+YA;;AU/YA;AV+YA;AAAA;AAAA;AAAA;;AU/YA;AV+YA;AW9lDA;AAAA;AAAA;;;;AA/QA;;;AX8xEA;;;AAnXA;AAAA;AW5pDA;;;AXslCA;AAAA;;;;;AAmMA;AAAA;AAAA;AAAA;AWzxCA;;;;;ACnQA;;;;AAAA;AAAA;;;ADmQA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AA/QA;;;AXyxEA;;;AAnXA;AWvpDA;AACA;;;;;;;;;ALyJA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AARA;AAAA;;;;AMvZA;;;;AAAA;AAAA;;;ANuZA;AAAA;;;;AArGA;AAAA;;;;AA2EA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AA7FA;;;ANk/DA;;;AAnLA;AMjuDA;AAAA;AAAA;AAAA;;AN+kBA;;;AA4bA;AAAA;AAAA;;;AAAA;;;AAsGA;;;AMjnCA;;;;AAAA;;AAAA;AACA;AAAA;AAAA;;;;AA/FA;;;ANk/DA;;;AAnLA;AMrsDA;AAAA;;;;;AAjHA;;;ANu+DA;;;AAnLA;AMxyDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AN4iCA;AAAA;AAAA;;;;;AA6LA;AAAA;AAAA;AMnoCA;;AACA;;;;;;;;;;;AyFvaA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AApCA;;;;AhGszDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;A8FlzDA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;;;;AAFA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;;;AACA;;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAFA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AAKA;;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;AAcA;AACA;AAAA;AAAA;AAAA;;AAEA;;;AAEA;AAAA;;AACA;AAAA;;AAEA;;AAEA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;AhGsvDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AoEjyDA;;;;;;;;;;;;;;;;;;;;;;;A2BZA;;;;AjGizDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;A+F7yDA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;;;AAFA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAAA;;;;AACA;;AAAA;AACA;;AAAA;;AAAA;AAAA;;AAAA;;AAFA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;AA8BA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;A1F06CA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;A0Fh7CA;AAAA;AACA;;;;;;;;;;;;;;AAlCA;;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;A1Fm3CA;AAAA;AAAA;AAAA;AAAA;A0F/1CA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;AAiHA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;A1F8tCA;AAAA;AAAA;AAAA;AAAA;A0FttCA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;A1F+sCA;AAAA;AAAA;AAAA;AAAA;A0FrsCA;AAAA;AAAA;;;;A1FqsCA;AAAA;AAAA;AAAA;AAAA;A0FpsCA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAEA;;;;AAFA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;A1FgsCA;AAAA;AAAA;AAAA;AAAA;A0FtrCA;AAAA;AAAA;;;;A1FsrCA;AAAA;AAAA;AAAA;AAAA;A0FrrCA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAEA;;;;AAFA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;A1FirCA;AAAA;AAAA;AAAA;AAAA;A0FzqCA;AAAA;AAAA;AAEA;AAAA;AAEA;;;;;;;;;;;;;A1FqqCA;AAAA;AAAA;AAAA;AAAA;A0F/pCA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;A1F2pCA;AAAA;AAAA;AAAA;AAAA;A0FppCA;AAAA;AAAA;;;;A1FopCA;AAAA;AAAA;AAAA;AAAA;A0FnpCA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;AzFnOA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AD82CA;AAAA;AAAA;AAAA;AAAA;A0FloCA;AAAA;AAAA;;;;A1FkoCA;AAAA;AAAA;AAAA;AAAA;A0FjoCA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAGA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AjG0hDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AqDnyDA;;;;;;;;;;;;;;;;;;;;;;;A2CjBA;;;;AlGwzDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AgGpzDA;;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;AAHA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AAOA;;AAAA;AAAA;AAOA;;;;AAPA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;;;AAFA;;AAAA;AAMA;AAAA;;AAHA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;A9B8DA;AAAA;AAAA;;;;;;;;;;;;A8B1DA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AlG8xDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AqF5yDA;;;;;;;;;;;;;;;;;;;;;;;AYZA;;;;AnG4zDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AiGxzDA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;AAHA;;AAAA;AAAA;;AAAA;;;;AAAA;;AAAA;AAGA;AAAA;;AAAA;;AAHA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;AAOA;;AAAA;AAAA;AACA;;;;AADA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;A5F69CA;AAAA;AAAA;AAAA;;;AAxpCA;;;ANy+DA;;;AAnLA;AM9pBA;AAAA;AAAA;;AAEA;;;AAhqCA;;;ANk/DA;;;AAnLA;AM9pBA;AAAA;AAAA;;ANpfA;AMofA;;;;AN7EA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AM8EA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;;;A4Fn+CA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;;;A1Ei2BA;;;AA/UA;AAAA;AAAA;;;;AA9TA;;;;AAAA;AAAA;AAAA;A0ElNA;;AAAA;AAAA;AAAA;AAAA;;;A1Em2BA;;;AA/TA;;AxBgUA;;AE5zBA;AAAA;AAAA;AsB4fA;;;;AAlVA;;;;AAAA;AAAA;AAAA;;;AA6GA;AAAA;;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;A0E/TA;;;;A1EkRA;AAAA;AAAA;A0EjRA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;A1EmXA;;;;AAJA;AAAA;AAAA;AAAA;AAAA;A0E/WA;AAAA;AAAA;AAAA;AACA;;;;;A1EoSA;AAAA;AAAA;;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;A0E7RA;;AAEA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AnGuxDA;;;;AANA;AAAA;;;;;AC+cA;;;AA3LA;;;AAAA;AClRA;AAAA;;AA/rCA;AAAA;AA+rCA;AsD9yDA;;;;;;;;;;;;;;;;A4CYA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAAA;AAAA;;AACA;;AAAA;;AAAA;;AAAA;AACA;;AACA;AAAA;;;;AAHA;;AAAA;AAGA;;AAAA;;AACA;;AADA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;A3CkGA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA3EA;AAAA;;;;;;;;;;;;;;;;AAuJA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;;;AAEA;;;;;;;;;AAvGA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA0EA;AAAA;AAAA;AAAA;AAAA;;;;;;;AA7EA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAoEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;A2CvJA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;AACA;;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;;;;AAHA;;AAAA;AAGA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;;AANA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;A3CoJA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;A2CzIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;A3CoIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAtFA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAxDA;AAAA;AACA;;;;;;;;A4CpBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AAMA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AACA;;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AAEA;;AACA;;;;;;;;;;;;;;A5CuBA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAxCA;AAAA;;;;;;;;;;;;;;A4CoBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;AAPA;;AAAA;AAOA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;AnDyDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;;;;;;;;;;;;AmDtDA;;AAAA;AAAA;AAUA;;;;AAVA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;;;;AADA;;AAAA;AAEA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAEA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;AnDgeA;AAAA;;;;;;;AAPA;AAAA;AAAA;;;;;;;;;;;;;;AmDhUA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAJA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;AACA;AAAA;;;;;;;;;AnDwJA;AAAA;AAAA;;;;;;;AA6GA;AAAA;AAAA;;;;;;;;;;;;;;AmDvNA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;A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AA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAMA;AAAA;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAMA;AAAA;;;;;;;;;;;;;;;;;;;;;AA8BA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAEA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAGA;AAAA;AAAA;;;AAIA;;AAIA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;;AAIA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AACA;;AAIA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;AAGA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;AAEA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;;AAAA;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;;;;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;;AACA;;AACA;;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;ApDtEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;;;;;;;;;;;;AoDkHA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AASA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAOA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;;;AAFA;;AAAA;AA0EA;;AAtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;AAEA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAEA;;AATA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAIA;AAAA;AAEA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AAGA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;ApD5LA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AoD4LA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AACA;;AAGA;AAGA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AACA;;AAKA;AAAA;AAAA;;AAEA;AAAA;AACA;AACA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;;;AAEA;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ApDnTA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;;AAGA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AoDyVA;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AAAA;AACA;;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AACA;AAAA;;AAGA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAGA;;AAIA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AAEA;;;;;;;AACA;;AAEA;AA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A;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAIA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAMA;AAAA;AACA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;AAEA;AAAA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;;AAAA;AACA;AAAA;;AACA;;;;;AAFA;;AAAA;AAEA;;AAAA;;AAGA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAXA;AAAA;;;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;;AAAA;AAAA;AAAA;;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;AAAA;AAAA;AAAA;AAAA;AAAA;;;ANhuBA;;;AAvWA;AAAA;AAuWA;;;;;AI3YA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AtCqXA;AAAA;AsCrXA;AAAA;;AACA;;;AEymCA;;AACA;;AAEA;;;;AAGA;;AAAA;AACA;;AAAA;;AAAA;AAAA;;;;;AAAA;;;AAnBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A6DltCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AnEoZA;;;AArDA;AAAA;AAAA;AAAA;AmE/VA;;AAEA;AACA;;;;A7D4uBA;AAAA;AACA;AAAA;AAAA;;AACA;;AxC3QA;AAAA;AwC2QA;AAAA;AAAA;;A6D5uBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AnE+YA;;;AArDA;AAAA;AAAA;AAAA;AmE1VA;;AAEA;AACA;;;;A7DuuBA;AAAA;AACA;AAAA;AAAA;;AACA;;AxC3QA;AAAA;AwC2QA;AAAA;AAAA;;A6DvuBA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AnEuYA;;;AArDA;AAAA;AAAA;AAAA;AmElVA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;AACA;;;;A7DiuBA;AAAA;AACA;AAAA;AAAA;;AACA;;AxC3QA;AAAA;AwC2QA;AAAA;AAAA;;A6DnuBA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AnEmYA;;;AArDA;AAAA;AAAA;AAAA;AmE9UA;;AACA;;;;A7D+fA;AAAA;A6D/fA;;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AnE0XA;AAAA;AAAA;AmEzXA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AnEsXA;AAAA;AAAA;AmErXA;;AAEA;AAAA;;A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","sourcesContent":["//\n//  emscripten_main.cpp\n//  aruspix\n//\n//  Created by Rodolfo Zitellini on 05/11/13.\n//  Copyright (c) 2013 com.aruspix.www. All rights reserved.\n//\n\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\n\n#include <sstream>\n#include <string>\n\n#include \"mus.h\"\n#include \"muscontroller.h\"\n\nusing namespace std;\n\nbool initialized = false;\n\nextern \"C\" {\n    const char * convertMusic(const char * c_notation, const char * c_options) {\n        \n        string notation(c_notation);\n        string json_options(c_options);\n        string out_str;\n        MusController controller;\n        \n        if (!initialized) {\n            std::srand(std::time(0));\n            initialized = true;\n        }\n        \n        if (!controller.ParseOptions( json_options )) {\n            Mus::LogError( \"Could not load JSON options.\" );\n            return NULL;\n        }\n        \n        Mus::SetResourcesPath(\"/data\");\n        \n        // default to mei if unset.\n        controller.LoadString( notation );\n\n        // in the future we will be able to render to mei too\n        out_str = controller.RenderToSvg();\n        return out_str.c_str();\n    }\n}","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TYPE_VIS_ONLY char_traits;\ntemplate<class _Tp>     class _LIBCPP_TYPE_VIS_ONLY allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TYPE_VIS_ONLY fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef long long streamoff;        // for char_traits in <string>\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_scalar<_Ptr1>::value &&\n                                         !is_pointer<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, true>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY void reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        explicit shared_ptr(_Yp* __p);\n    template<class _Yp, class _Dp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a);\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp>&& __r);\n#else\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp> __r);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             > shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r)\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r)\n#endif\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n);\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n);\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n);\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2) const;\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s) {return strlen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)memcpy(__s1, __s2, __n);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__a == __str.__alloc() || !__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign recieved nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign recieved nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append recieved nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append recieved nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert recieved nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p + __ip);\n#else\n    return iterator(__p + __ip);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert recieved nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace recieved nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace recieved nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz || __sz - __pos < __n)\n        return npos;\n    if (__n == 0)\n        return __pos;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::search(__p + __pos, __p + __sz, __s, __s + __n,\n                                     __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return find(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): recieved nullptr\");\n    return find(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos >= __sz)\n        return npos;\n    const value_type* __p = data();\n    const value_type* __r = traits_type::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): recieved nullptr\");\n    size_type __sz = size();\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::find_end(__p, __p + __pos, __s, __s + __n,\n                                       __traits_eq<traits_type>());\n    if (__n > 0 && __r == __p + __pos)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return rfind(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): recieved nullptr\");\n    return rfind(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__sz)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const value_type* __p = data();\n        for (const value_type* __ps = __p + __pos; __ps != __p;)\n        {\n            if (traits_type::eq(*--__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos >= __sz || __n == 0)\n        return npos;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::find_first_of(__p + __pos, __p + __sz, __s,\n                                            __s + __n, __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find_first_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): recieved nullptr\");\n    return find_first_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): recieved nullptr\");\n    if (__n != 0)\n    {\n        size_type __sz = size();\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const value_type* __p = data();\n        for (const value_type* __ps = __p + __pos; __ps != __p;)\n        {\n            const value_type* __r = traits_type::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return find_last_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): recieved nullptr\");\n    return find_last_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const value_type* __p = data();\n        const value_type* __pe = __p + __sz;\n        for (const value_type* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (traits_type::find(__s, __n, *__ps) == 0)\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return find_first_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): recieved nullptr\");\n    return find_first_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const value_type* __p = data();\n        const value_type* __pe = __p + __sz;\n        for (const value_type* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!traits_type::eq(*__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    for (const value_type* __ps = __p + __pos; __ps != __p;)\n        if (traits_type::find(__s, __n, *--__ps) == 0)\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return find_last_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): recieved nullptr\");\n    return find_last_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    for (const value_type* __ps = __p + __pos; __ps != __p;)\n        if (!traits_type::eq(*--__ps, __c))\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): recieved nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): recieved nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct ____is_reference_wrapper : public false_type {};\ntemplate <class _Tp> struct ____is_reference_wrapper<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public ____is_reference_wrapper<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n"," /////////////////////////////////////////////////////////////////////////////\n// Name:        mus.h\n// Author:      Laurent Pugin\n// Created:     2013\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_H__\n#define __MUS_H__\n\n#include <string>\n\n//----------------------------------------------------------------------------\n// Mus\n//----------------------------------------------------------------------------\n\n/**\n * This class provides static helpers \n * Most of them differ if they are used in Aruspix or in the command line tool\n */\n\nclass Mus\n{\npublic:\n    // Some statis utiliry functions\n    static std::string GetAxVersion();\n    static std::string GetResourcesPath();\n    static void SetResourcesPath(std::string p) {m_respath = p;}\n    static std::string GetMusicFontDescStr();\n    static std::string GetNeumeFontDescStr();\n    static std::string GetLyricFontDescStr();\n    static int GetFontPosCorrection();\n    static std::string GetFileVersion(int vmaj, int vmin, int vrev);\n    static std::string StringFormat( const char *fmt, ... );\n    static std::string GetFilename( std::string fullpath );\n    \n    static void LogDebug(  const char *fmt, ... );\n    static void LogError(  const char *fmt, ... );\n    static void LogMessage(  const char *fmt, ... );\n    static void LogWarning(  const char *fmt, ... );\n    \n    /**\n     * Utility for comparing doubles\n     */\n    static bool AreEqual(double dFirstVal, double dSecondVal);\n    \n    /**\n     * Utility for converting UTF16 (std::wstring) to UTF-8\n     */\n    static std::string UTF16to8(const wchar_t * in);\n\n    /**\n     * Utility for converting UTF-8 to UTF16 (std::wstring)\n     */\n    static std::wstring UTF8to16(const char * in);\n    \n    \nprivate:\n    static std::string m_respath;\n};\n\n\n//----------------------------------------------------------------------------\n// MusEnv\n//----------------------------------------------------------------------------\n\n/** \n * This class contains the document default environment variables.\n * Some of them are not available as is in MEI - to be solved\n */\nclass MusEnv \n{\npublic:\n    // constructors and destructors\n    MusEnv();\n    virtual ~MusEnv();\n    \n    \npublic:\n    /** The reference interline definition  */\n    int m_interlDefin;\n    /** The landscape paper orientation flag */\n    char m_landscape;\n    /** The staff line width */\n    unsigned char m_staffLineWidth;\n    /** The stem width */\n    unsigned char m_stemWidth;\n    /** The barline width */\n    unsigned char m_barlineWidth;\n    /** The beam width */\n    unsigned char m_beamWidth;\n    /** The beam white width */\n    unsigned char m_beamWhiteWidth;\n    /** The maximum beam slope */\n    unsigned char m_beamMaxSlope;\n    /** The minimum beam slope */\n    unsigned char m_beamMinSlope;     \n    /** The small staff size ratio numerator */\n    unsigned char m_smallStaffNum;\n    /** The small staff size ratio denominator */\n    unsigned char m_smallStaffDen;\n    /** The grace size ratio numerator */\n    unsigned char m_graceNum;\n    /** The grace size ratio denominator */\n    unsigned char m_graceDen;\n    /** The stem position correction */\n    signed char m_stemCorrection;\n    /** The header and footer type */\n    unsigned int m_headerType;\n    /** The notation mode (cmn or mensural) */\n    int m_notationMode;\n    /** The current page height */\n    int m_pageHeight;\n    /** The current page height */\n    int m_pageWidth;\n    /** The current page witdth */\n    int m_pageLeftMar;\n    /** The current page left margin */\n    int m_pageRightMar;\n    /** The current page right margin */\n    int m_pageTopMar;\n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mus.cpp\n// Author:      Laurent Pugin\n// Created:     2013\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"mus.h\"\n\n//----------------------------------------------------------------------------\n\n#include <cmath>\n#include <stdarg.h>\n\n//----------------------------------------------------------------------------\n\n#include \"musdef.h\"\n\n//----------------------------------------------------------------------------\n\n// AX_APP is define is the Aruspix wxWidget application only\n#ifdef AX_APP\n#include \"wx/wxprec.h\"\n#include \"app/axapp.h\"\n#endif\n\n// Initialize static respource path\nstd::string Mus::m_respath = \"/usr/local/share/aruspix\";\n\n//----------------------------------------------------------------------------\n// Mus\n//----------------------------------------------------------------------------\n\n\nbool Mus::AreEqual(double dFirstVal, double dSecondVal)\n{\n    return std::fabs(dFirstVal - dSecondVal) < 1E-3;\n}\n\nstd::string Mus::GetAxVersion() {\n#ifndef AX_APP\n    return std::string(\"command line\"); // we need to add versioning\n#else\n    return AxApp::s_version.mb_str();\n#endif\n}\n\nstd::string Mus::GetResourcesPath() {\n#ifndef AX_APP\n    //hardcode galore\n    return m_respath;\n#else\n    return wxGetApp().m_resourcesPath.mb_str();\n#endif\n}\n\nstd::string Mus::GetMusicFontDescStr() {\n#ifndef AX_APP\n    return std::string(\"0;13;70;90;90;0;Leipzig 4.7;33\");\n#else\n    return wxGetApp().m_musicFontDesc.mb_str();\n#endif\n}\n\nstd::string Mus::GetLyricFontDescStr() {\n#ifndef AX_APP\n    return std::string(\"0;12;70;93;90;0;Garamond;0\");\n#else\n    return wxGetApp().m_lyricFontDesc.mb_str();\n#endif\n}\n\n\nint Mus::GetFontPosCorrection(){\n#ifndef AX_APP\n    return 0;\n#else\n    return wxGetApp().m_fontPosCorrection;\n#endif\n}\n\nstd::string Mus::GetFileVersion(int vmaj, int vmin, int vrev) {\n    return Mus::StringFormat(\"%04d.%04d.%04d\", vmaj, vmin, vrev );\n}\n\nstd::string Mus::StringFormat(const char *fmt, ...)\n{\n    std::string str( 2048, 0 );\n    va_list args;\n    va_start ( args, fmt );\n    vsnprintf ( &str[0], 2048, fmt, args );\n    va_end ( args );\n    str.resize( strlen( str.data() ) );\n    return str;\n}\n\nstd::string Mus::GetFilename( std::string fullpath )\n{\n    // remove extension\n    std::string name = fullpath;\n    size_t lastdot = name.find_last_of(\".\");\n    if (lastdot != std::string::npos) {\n        name = name.substr(0, lastdot);\n    }\n    size_t lastslash = name.find_last_of(\"/\");\n    if (lastslash != std::string::npos) {\n        name = name.substr(lastslash + 1, std::string::npos);\n    }\n    return name;\n}\n\nvoid Mus::LogDebug(const char *fmt, ...)\n{\n#ifdef EMSCRIPTEN\n    return;\n#else\n    va_list args;\n    va_start ( args, fmt );\n#ifndef AX_APP\n    #if defined(DEBUG)\n    printf(\"[Debug] \");\n    vprintf( fmt, args );\n    printf(\"\\n\");\n    #endif\n#else\n    wxVLogDebug( fmt, args );\n#endif\n    va_end ( args );\n#endif\n}\n\nvoid Mus::LogError(const char *fmt, ...)\n{\n#ifdef EMSCRIPTEN\n    return;\n#else\n    va_list args;\n    va_start ( args, fmt );\n#ifndef AX_APP\n    printf(\"[Error] \");\n    vprintf( fmt, args );\n    printf(\"\\n\");\n#else\n    wxVLogError( fmt, args );\n#endif\n    va_end ( args );\n#endif\n}\n\nvoid Mus::LogMessage(const char *fmt, ...)\n{\n#ifdef EMSCRIPTEN\n    return;\n#else\n    va_list args;\n    va_start ( args, fmt );\n#ifndef AX_APP\n    printf(\"[Message] \");\n    vprintf( fmt, args );\n    printf(\"\\n\");\n#else\n    wxVLogMessage( fmt, args );\n#endif\n    va_end ( args );\n#endif\n}\n\nvoid Mus::LogWarning(const char *fmt, ...)\n{\n#ifdef EMSCRIPTEN\n    return;\n#else\n    va_list args;\n    va_start ( args, fmt );\n#ifndef AX_APP\n    printf(\"[Warning] \");\n    vprintf( fmt, args );\n    printf(\"\\n\");\n#else\n    wxVLogWarning( fmt, args );\n#endif\n    va_end ( args );\n#endif\n}\n\nstd::string Mus::UTF16to8(const wchar_t * in)\n{\n    std::string out;\n    unsigned int codepoint = 0;\n    for (;  *in != 0;  ++in)\n    {\n        if (*in >= 0xd800 && *in <= 0xdbff)\n            codepoint = ((*in - 0xd800) << 10) + 0x10000;\n        else\n        {\n            if (*in >= 0xdc00 && *in <= 0xdfff)\n                codepoint |= *in - 0xdc00;\n            else\n                codepoint = *in;\n            \n            if (codepoint <= 0x7f)\n                out.append(1, static_cast<char>(codepoint));\n            else if (codepoint <= 0x7ff)\n            {\n                out.append(1, static_cast<char>(0xc0 | ((codepoint >> 6) & 0x1f)));\n                out.append(1, static_cast<char>(0x80 | (codepoint & 0x3f)));\n            }\n            else if (codepoint <= 0xffff)\n            {\n                out.append(1, static_cast<char>(0xe0 | ((codepoint >> 12) & 0x0f)));\n                out.append(1, static_cast<char>(0x80 | ((codepoint >> 6) & 0x3f)));\n                out.append(1, static_cast<char>(0x80 | (codepoint & 0x3f)));\n            }\n            else\n            {\n                out.append(1, static_cast<char>(0xf0 | ((codepoint >> 18) & 0x07)));\n                out.append(1, static_cast<char>(0x80 | ((codepoint >> 12) & 0x3f)));\n                out.append(1, static_cast<char>(0x80 | ((codepoint >> 6) & 0x3f)));\n                out.append(1, static_cast<char>(0x80 | (codepoint & 0x3f)));\n            }\n            codepoint = 0;\n        }\n    }\n    return out;\n}\n\nstd::wstring Mus::UTF8to16(const char * in)\n{\n    std::wstring out;\n    if (in == NULL)\n        return out;\n    \n    unsigned int codepoint;\n    while (*in != 0)\n    {\n        unsigned char ch = static_cast<unsigned char>(*in);\n        if (ch <= 0x7f)\n            codepoint = ch;\n        else if (ch <= 0xbf)\n            codepoint = (codepoint << 6) | (ch & 0x3f);\n        else if (ch <= 0xdf)\n            codepoint = ch & 0x1f;\n        else if (ch <= 0xef)\n            codepoint = ch & 0x0f;\n        else\n            codepoint = ch & 0x07;\n        ++in;\n        if (((*in & 0xc0) != 0x80) && (codepoint <= 0x10ffff))\n        {\n            if (codepoint > 0xffff)\n            {\n                out.append(1, static_cast<wchar_t>(0xd800 + (codepoint >> 10)));\n                out.append(1, static_cast<wchar_t>(0xdc00 + (codepoint & 0x03ff)));\n            }\n            else if (codepoint < 0xd800 || codepoint >= 0xe000)\n                out.append(1, static_cast<wchar_t>(codepoint));\n        }\n    }\n    return out;\n}\n\n//----------------------------------------------------------------------------\n// MusEnv\n//----------------------------------------------------------------------------\n\nMusEnv::MusEnv()\n{\n    \n    m_interlDefin = 18;\n    m_landscape = false;\n    m_staffLineWidth = 2;\n    m_stemWidth = 2;\n    m_barlineWidth = 2;\n    m_beamWidth = 8;\n    m_beamWhiteWidth = 6;\n    m_beamMaxSlope = 30;\n    m_beamMinSlope = 10;\n    \n    // originally in MusParameters2\n    m_smallStaffNum = 16;\n    m_smallStaffDen = 20;\n    m_graceNum = 3;\n    m_graceDen = 4;\n\tm_stemCorrection = 0;\n    m_headerType = 0;\n    \n    m_pageHeight = 2970;\n    m_pageWidth = 2100;\n    m_pageRightMar = 0;\n    m_pageLeftMar = 0;\n    m_pageTopMar = 0;\n    \n    // additional parameters\n    m_notationMode = MUS_MENSURAL_MODE;\n    //m_notationMode = MUS_CMN_MODE;\n}\n\nMusEnv::~MusEnv()\n{\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musaligner.cpp\n// Author:      Laurent Pugin\n// Created:     2013\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musaligner.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <math.h>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"muslayerelement.h\"\n\n//----------------------------------------------------------------------------\n// MusSystemAligner\n//----------------------------------------------------------------------------\n\nMusSystemAligner::MusSystemAligner():\n    MusObject()\n{\n    m_bottomAlignment = NULL;\n}\n\nMusSystemAligner::~MusSystemAligner()\n{\n    \n}\n\n\nvoid MusSystemAligner::Reset()\n{\n    this->ClearChildren();\n    m_bottomAlignment = NULL;\n    m_bottomAlignment = GetStaffAlignment( 0 );\n}\n\nMusStaffAlignment* MusSystemAligner::GetStaffAlignment( int idx )\n{\n    // The last one is always the bottomAlignment (unless if not created)\n    if ( m_bottomAlignment ) {\n        // remove it temporarily\n        this->m_children.pop_back();\n    }\n    \n    if (idx < GetStaffAlignmentCount()) {\n        this->m_children.push_back( m_bottomAlignment );\n        return (MusStaffAlignment*)m_children[idx];\n    }\n    // check that we are searching for the next one (not gap)\n    assert( idx == GetStaffAlignmentCount() );\n    //Mus::LogDebug(\"Creating staff alignment\");\n    \n    // This is the first time we are looking for it (e.g., first staff)\n    // We create the MusStaffAlignment\n    MusStaffAlignment *alignment = new MusStaffAlignment();\n    alignment->SetParent( this );\n    m_children.push_back( alignment );\n    \n    if ( m_bottomAlignment ) {\n        this->m_children.push_back( m_bottomAlignment );\n    }\n    \n    return alignment;\n}\n\n\n//----------------------------------------------------------------------------\n// MusStaffAlignment\n//----------------------------------------------------------------------------\n\nMusStaffAlignment::MusStaffAlignment():\n    MusObject()\n{\n    m_yRel = 0;\n    m_yShift = 0;\n}\n\nMusStaffAlignment::~MusStaffAlignment()\n{\n    \n}\n\nvoid MusStaffAlignment::SetYShift( int yShift )\n{\n    if ( yShift < m_yShift )\n    {\n        m_yShift = yShift;\n    }\n}\n\n//----------------------------------------------------------------------------\n// MusMeasureAligner\n//----------------------------------------------------------------------------\n\nMusMeasureAligner::MusMeasureAligner():\n    MusObject()\n{\n    m_leftAlignment = NULL;\n    m_rightAlignment = NULL;\n    //m_totalWidth = 0;\n}\n\nMusMeasureAligner::~MusMeasureAligner()\n{\n}\n\nvoid MusMeasureAligner::Reset()\n{\n    this->ClearChildren();\n    m_leftAlignment = new MusAlignment( 0.0, ALIGNMENT_MEASURE_START );\n    AddAlignment( m_leftAlignment );\n    m_rightAlignment = new MusAlignment( 0.0, ALIGNMENT_MEASURE_END );\n    AddAlignment( m_rightAlignment );\n}\n\nvoid MusMeasureAligner::AddAlignment( MusAlignment *alignment, int idx )\n{\n\talignment->SetParent( this );\n    if ( idx == -1 ) {\n        m_children.push_back( alignment );\n    }\n    else {\n        InsertChild( alignment, idx );\n    }\n}\n\nMusAlignment* MusMeasureAligner::GetAlignmentAtTime( double time, MusAlignmentType type )\n{\n    int i;\n    int idx = -1; // the index if we reach the end.\n    MusAlignment *alignment = NULL;\n    // First try to see if we already have something at the time position\n    for (i = 0; i < GetAlignmentCount(); i++)\n    {\n        alignment = (MusAlignment*)m_children[i];\n        double alignment_time = alignment->GetTime();\n        if ( Mus::AreEqual( alignment_time, time ) && (alignment->GetType() == type) ) {\n            return alignment;\n        }\n        // nothing found, do not go any further but keep the index\n        if (alignment->GetTime() > time) {\n            idx = i;\n            break;\n        }\n    }\n    // nothing found\n    if ( idx == -1 ) {\n        // this is tricky! Because we want m_rightAlignment to always stay at the end,\n        // we always to insert _before_ the last one - m_rightAlignment is added in Reset()\n        idx = GetAlignmentCount() - 1;\n    }\n    MusAlignment *newAlignement = new MusAlignment( time, type );\n    AddAlignment( newAlignement, idx );\n    return newAlignement;\n}\n\nvoid MusMeasureAligner::SetMaxTime( double time )\n{\n    if ( m_rightAlignment->GetTime() < time ) {\n        m_rightAlignment->SetTime( time );\n    }\n}\n\n//----------------------------------------------------------------------------\n// MusAlignement\n//----------------------------------------------------------------------------\n\nMusAlignment::MusAlignment( ):\n    MusObject()\n{\n    m_xRel = 0;\n    m_xShift = 0;\n    m_maxWidth = 0;\n    m_time = 0.0;\n    m_type = ALIGNMENT_DEFAULT;\n}\n\nMusAlignment::MusAlignment( double time, MusAlignmentType type ):\n    MusObject()\n{\n    m_xRel = 0;\n    m_xShift = 0;\n    m_maxWidth = 0;\n    m_time = time;\n    m_type = type;\n}\n\nMusAlignment::~MusAlignment()\n{\n    \n}\n\nvoid MusAlignment::SetXRel( int x_rel )\n{\n    m_xRel = x_rel;\n}\n\nvoid MusAlignment::SetXShift( int xShift )\n{\n    if ( xShift > m_xShift )\n    {\n        m_xShift = xShift;\n    }\n}\n\nvoid MusAlignment::SetMaxWidth( int max_width )\n{\n    if ( max_width > m_maxWidth )\n    {\n        m_maxWidth = max_width;\n    }\n}\n\n//----------------------------------------------------------------------------\n// Functors\n//----------------------------------------------------------------------------\n\nint MusStaffAlignment::SetAligmentYPos( ArrayPtrVoid params )\n{\n    // param 0: the previous staff height\n    // param 1: the staff margin\n    // param 2: the staff interline sizes (int[2])\n    // param 2: the functor to be redirected to MusSystemAligner (unused)\n    int *previousStaffHeight = (int*)params[0];\n    int *staffMargin = (int*)params[1];\n    int **interlineSizes = (int**)params[2];\n\n    int min_shift = (*staffMargin) + (*previousStaffHeight);\n    \n    if ( m_yShift > -min_shift) {\n        m_yShift = -min_shift;\n    }\n    \n    // for now always for interlines, eventually should be taken from the staffDef, so should the staff size\n    (*previousStaffHeight) = 4 * (*interlineSizes)[0];\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusStaffAlignment::IntegrateBoundingBoxYShift( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    // param 1: the functor to be redirected to the MusSystemAligner (unused)\n    int *shift = (int*)params[0];\n    \n    // integrates the m_xShift into the m_xRel\n    m_yRel += m_yShift + (*shift);\n    // cumulate the shift value\n    (*shift) += m_yShift;\n    m_yShift = 0;\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusMeasureAligner::IntegrateBoundingBoxXShift( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    // param 1: the cumulated width\n    // param 2: the functor to be redirected to the MusMeasureAligner (unused)\n    int *shift = (int*)params[0];\n    \n    // We start a new MusMeasureAligner\n    // Reset the cumulated shift to 0;\n    (*shift) = 0;\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusAlignment::IntegrateBoundingBoxXShift( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    // param 1: the functor to be redirected to the MusMeasureAligner (unused)\n    int *shift = (int*)params[0];\n    \n    // integrates the m_xShift into the m_xRel\n    m_xRel += m_xShift + (*shift);\n    // cumulate the shift value and the width\n    (*shift) += m_xShift;\n\n    // reset member to 0\n    m_xShift = 0;\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusMeasureAligner::SetAligmentXPos( ArrayPtrVoid params )\n{\n    // param 0: the previous time position\n    // param 1: the previous x rel position\n    // param 2: the functor to be redirected to the MusMeasureAligner (unused)\n    double *previousTime = (double*)params[0];\n    int *previousXRel = (int*)params[1];\n    \n    // We start a new MusMeasureAligner\n    // Reset the previous time position and x_rel to 0;\n    (*previousTime) = 0.0;\n    (*previousXRel) = 0;\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusAlignment::SetAligmentXPos( ArrayPtrVoid params )\n{\n    // param 0: the previous time position\n    // param 1: the previous x rel position\n    // param 2: the functor to be redirected to the MusMeasureAligner (unused)\n    double *previousTime = (double*)params[0];\n    int *previousXRel = (int*)params[1];\n    \n    int intervalXRel = 0;\n    double intervalTime = (m_time - (*previousTime));\n    if ( intervalTime > 0.0 ) {\n        intervalXRel = pow( intervalTime, 0.60 ) * 2.5; // 2.5 is an abritrary value\n    }\n    \n    m_xRel = (*previousXRel) + (intervalXRel);\n    (*previousTime) = m_time;\n    (*previousXRel) = m_xRel;\n    \n    return FUNCTOR_CONTINUE;\n}\n\n\nint MusAlignment::JustifyX( ArrayPtrVoid params )\n{\n    // param 0: the justification ratio\n    // param 1: the system full width (without system margins) (unused)\n    // param 2: the functor to be redirected to the MusMeasureAligner (unused)\n    double *ratio = (double*)params[0];\n    \n    this->m_xRel = ceil((*ratio) * (double)this->m_xRel);\n\n    return FUNCTOR_CONTINUE;\n}\n\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#ifdef _LIBCPP_DEBUG\n#   include <__debug>\n#else\n#   define _LIBCPP_ASSERT(x, m) ((void)0)\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        __base::clear();\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __move_construct_at_end(pointer __first, pointer __last);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        __base::__destruct_at_end(__new_last);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_construct_at_end(pointer __first, pointer __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__first));\n        ++this->__end_;\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __base::__move_assign_alloc(__c);\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typename iterator_traits<_ForwardIterator>::difference_type __new_size = _VSTD::distance(__first, __last);\n    if (static_cast<size_type>(__new_size) <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (static_cast<size_type>(__new_size) > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last);\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__new_size)));\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __move_range(__p, __old_last, __p + __old_n);\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                _VSTD::advance(__m, this->__end_ - __p);\n                __construct_at_end(__m, __last);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __move_range(__p, __old_last, __p + __old_n);\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __base::__swap_alloc(this->__alloc(), __x.__alloc());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__storage_type>\n#else\n                rebind_alloc<__storage_type>::other\n#endif\n                                                     __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a);\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~(__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __storage_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator&, __storage_allocator&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __move_assign_alloc(__c);\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_alloc(this->__alloc(), __x.__alloc());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musaligner.h\n// Author:      Laurent Pugin\n// Created:     2013\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_ALIGNER_H__\n#define __MUS_ALIGNER_H__\n\n#include \"musobject.h\"\n\nclass MusSystemAligner;\nclass MusStaffAlignment;\nclass MusMeasureAligner;\n\n/**\n * Alignment types for aligning types together.\n * For example, we align notes and rests (default) together, clef separately, etc.\n */\nenum MusAlignmentType {\n    ALIGNMENT_DEFAULT = 0,\n    ALIGNMENT_CLEF,\n    ALIGNMENT_MENSUR,\n    ALIGNMENT_KEYSIG,\n    ALIGNMENT_BARLINE,\n    ALIGNMENT_MULTIREST,\n    ALIGNMENT_MEASURE_START,\n    ALIGNMENT_MEASURE_END\n};\n\n//----------------------------------------------------------------------------\n// MusSystemAligner\n//----------------------------------------------------------------------------\n\n/**\n * This class aligns the content of a system\n * It contains a vector of MusStaffAlignment\n */\nclass MusSystemAligner: public MusObject\n{\npublic:\n    // constructors and destructors\n    MusSystemAligner();\n    virtual ~MusSystemAligner();\n    \n    int GetStaffAlignmentCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Reset the aligner (clear the content) and creates the end (bottom) alignement\n     */\n    void Reset();\n    \n    /**\n     * Get bottom MusStaffAlignment for the system.\n     * For each MusSystemAligner, we keep and MusStaffAlignment for the bottom position.\n     */\n    MusStaffAlignment *GetBottomAlignment( ) { return m_bottomAlignment; };\n    \n    /**\n     * Get the MusStaffAlignment at index idx.\n     * Creates the MusStaffAlignment if not there yet.\n     * Checks the they are created incrementally (without gap).\n     */\n    MusStaffAlignment* GetStaffAlignment( int idx );\n    \nprivate:\n    \npublic:\n    \nprivate:\n    /**\n     * A pointer to the left MusStaffAlignment object kept for the system bottom position\n     */\n    MusStaffAlignment *m_bottomAlignment;\n    \n};\n\n//----------------------------------------------------------------------------\n// MusStaffAlignment\n//----------------------------------------------------------------------------\n\n/**\n * This class stores an alignement position staves will point to\n */\nclass MusStaffAlignment: public MusObject\n{\npublic:\n    // constructors and destructors\n    MusStaffAlignment();\n    virtual ~MusStaffAlignment();\n    \n    void SetYRel( int yRel ) { m_yRel = yRel; };\n    int GetYRel() { return m_yRel; };\n    \n    void SetYShift( int yShift );\n    int GetYShift() { return m_yShift; };\n    \n    /**\n     * Set the position of the StaffAlignment.\n     * Functor redirected from MusSystem.\n     */\n    virtual int SetAligmentYPos( ArrayPtrVoid params );\n    \n    /**\n     * Correct the Y alignment once the the content of a system has been aligned and laid out.\n     * Special case of functor redirected from MusSystem.\n     */\n    virtual int IntegrateBoundingBoxYShift( ArrayPtrVoid params );\n    \nprivate:\n    \npublic:\n    \nprivate:\n    /**\n     * Stores the position relative to the system.\n     */\n    int m_yRel;\n    int m_yShift;\n};\n\n\n//----------------------------------------------------------------------------\n// MusAlignment\n//----------------------------------------------------------------------------\n\n/** \n * This class stores an alignement position elements will point to\n */\nclass MusAlignment: public MusObject\n{\npublic:\n    // constructors and destructors\n    MusAlignment( );\n    MusAlignment( double time, MusAlignmentType type = ALIGNMENT_DEFAULT );\n    virtual ~MusAlignment();\n    \n    void SetXRel( int x_rel );\n    int GetXRel() { return m_xRel; };\n    \n    void SetXShift( int xShift );\n    int GetXShift() { return m_xShift; };\n    \n    void SetMaxWidth( int max_width );\n    int GetMaxWidth() { return m_maxWidth; };\n\n    /**\n     * @name Set and get the time value of the alignment\n     */\n    ///@{\n    void SetTime( double time ) { m_time = time; };\n    double GetTime() { return m_time; };\n    ///@}\n    \n    /**\n     * @name Set and get the type of the alignment\n     */\n    ///@{\n    void SetType( MusAlignmentType type ) { m_type = type; };\n    MusAlignmentType GetType() { return m_type; };\n    ///@}\n    \n    /**\n     * Correct the X alignment once the the content of a system has been aligned and laid out.\n     * Special case of functor redirected from MusMeasure.\n     */\n    virtual int IntegrateBoundingBoxXShift( ArrayPtrVoid params );\n    \n    /**\n     * Set the position of the MusAlignment.\n     * Looks at the time different with the previous MusAlignment.\n     */\n    virtual int SetAligmentXPos( ArrayPtrVoid params );\n    \n    /**\n     * Justify the X positions\n     * Special case of functor redirected from MusMeasure.\n     */\n    virtual int JustifyX( ArrayPtrVoid params );\n    \nprivate:\n    \npublic:\n    \nprivate:\n    /**\n     * Stores the position relative to the measure.\n     * This is instanciated the MusObject::SetAligmentXPos functor.\n     * It takes into account a non-linear according to the time interval with\n     * the previous MusAlignement\n     */\n    int m_xRel;\n    /**\n     * Stores temporally the maximum amount we need to shift the element pointing to it for \n     * avoiding collisions. This is set in MusObject::SetBoundingBoxXShift and then\n     * integrated for all aligment in MusAligment::IntegrateBoundingBoxXShift.\n     */\n    int m_xShift;\n    /**\n     * Stores temporally the maximum width of the of the element pointing to it.\n     * It is set and integrated as m_xShift and it is used only for shifting the\n     * alignment of the end of the measure (ALIGNMENT_MEASURE_END).\n     */\n    int m_maxWidth;\n    /**\n     * Stores the time at which the alignment occur.\n     * It is set by  MusObject::Align.\n     */\n    double m_time;\n    /**\n     * Defines the type of alignment (see the MusAlignmentType enum).\n     * We have different types because we want events occuring at the same\n     * time to be alignnemt separately. Example: the clef needs to be aligned\n     * togeter, but key signature together and then the notes, even if all\n     * of them occur at time 0.\n     */\n    MusAlignmentType m_type;\n};\n\n//----------------------------------------------------------------------------\n// MusMeasureAligner\n//----------------------------------------------------------------------------\n\n/**\n * This class aligns the content of a measure\n * It contains a vector of MusAlignment\n */\nclass MusMeasureAligner: public MusObject\n{\npublic:\n    // constructors and destructors\n    MusMeasureAligner();\n    virtual ~MusMeasureAligner();\n    \n    int GetAlignmentCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Reset the aligner (clear the content) and creates the start (left) and end (right) alignement\n     */\n    void Reset();\n    \n    MusAlignment* GetAlignmentAtTime( double time, MusAlignmentType type );\n    \n    /**\n     * Keep the maximum time of the measure.\n     * This correspond to the whole duration of the measure and \n     * should be the same for all staves/layers.\n     */\n    void SetMaxTime( double time );\n    \n    /**\n     * @name Set and get the total width\n     */\n    ///@{\n    //void SetTotalWidh( int width ) { m_totalWidth = width; };\n    //int GetTotalWidth() { return m_totalWidth; };\n    ///@}\n    \n    /**\n     * Get left MusAlignment for the measure.\n     * For each MusMeasureAligner, we keep and MusAlignment for the left position.\n     * The MusAlignment time will be always stay 0.0 and be the first in the list.\n     */\n    MusAlignment *GetLeftAlignment( ) { return m_leftAlignment; };\n    \n    /**\n     * Get right MusAlignment for the measure.\n     * For each MusMeasureAligner, we keep and MusAlignment for the right position.\n     * The MusAlignment time will be increased whenever necessary when values are added.\n     */\n    MusAlignment *GetRightAlignment( ) { return m_rightAlignment; };\n    \n    /**\n     * Correct the X alignment once the the content of a system has been aligned and laid out.\n     * Special case of functor redirected from MusMeasure.\n     */\n    virtual int IntegrateBoundingBoxXShift( ArrayPtrVoid params );\n    \n    /**\n     * Set the position of the MusAlignment.\n     * Looks at the time different with the previous MusAlignment.\n     * For each MusMeasureAlignment, we need to reset the previous time position.\n     */\n    virtual int SetAligmentXPos( ArrayPtrVoid params );\n    \n    /**\n     * Justify the X positions\n     * Special case of functor redirected from MusMeasure.\n     */\n    //virtual int JustifyX( ArrayPtrVoid params );\n\n    \nprivate:\n    void AddAlignment( MusAlignment *alignment, int idx = -1 );\n    \npublic:\n    \nprivate:\n    /**\n     * A pointer to the left MusAlignment object kept for the measure start position\n     */\n    MusAlignment *m_leftAlignment;\n    \n    /**\n     * A pointer to the left MusAlignment object kept for the measure end position\n     */\n    MusAlignment *m_rightAlignment;\n    \n    /**\n     * Store the system width in order to calculate the justification ratio\n     */\n    //int m_totalWidth;\n};\n\n\n#endif\n"," /////////////////////////////////////////////////////////////////////////////\n// Name:        musobject.h\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_OBJECT_H__\n#define __MUS_OBJECT_H__\n\n#include <list>\n#include <string>\n#include <typeinfo>\n#include <vector>\n\n#include \"musdef.h\"\n \nclass MusDoc;\nclass MusFunctor;\nclass MusObject;\n\ntypedef std::vector<MusObject*> ArrayOfMusObjects;\n\ntypedef std::list<MusObject*> ListOfMusObjects;\n\ntypedef std::vector<void*> ArrayPtrVoid;\n\n//----------------------------------------------------------------------------\n// MusObject\n//----------------------------------------------------------------------------\n\n/** \n * This class represents a basic object\n */\nclass MusObject\n{\npublic:\n    // constructors and destructors\n    MusObject();\n    MusObject(std::string classid);\n    virtual ~MusObject();\n    \n    /**\n     * Copy constructor that also copy the children.\n     * The children are copied using the MusObject::Clone virtual method that\n     * Needs to be overwritten in the child class - we make it crash otherwise,\n     * Because this will create problem if we don't check this (the parents will \n     * one the same child...)\n     * UUID: the uuid is copied, is needs to be reset later if this is not wished\n     */\n    MusObject( const MusObject& object );\n    \n    /**\n     * See copy constructor.\n     */\n    MusObject& operator=( const MusObject& object ); // copy assignement;\n    \n    /**\n     * Method call for copying child classes\n     */\n    virtual MusObject* Clone();\n    \n    virtual bool operator==( MusObject& other );\n    \n    std::string GetUuid() { return m_uuid; };\n    void SetUuid( std::string uuid );\n    void ResetUuid( );\n    \n    /**\n     * Children count\n     * Used for classes with several types of children\n     */\n    int GetChildCount() { return (int)m_children.size(); };\n    \n    /**\n     * Child access (generic)\n     */\n    MusObject *GetChild( int idx );\n    \n    /**\n     * Clear the children vector and delete all the objects.\n     */\n    void ClearChildren();\n    \n    /**\n     * Set the parent of the MusObject.\n     * The current parent is expected to be NULL.\n     */\n    void SetParent( MusObject *parent );\n    \n    virtual std::string MusClassName( ) { return \"[MISSING]\"; };\n\n    /**\n     * Return the index position of the object in its parent (-1 if not found)\n     */\n    int GetIdx() const;\n\n    /**\n     * Look for the MusObject in the children and return its position (-1 if not found)\n     */\n    int GetChildIndex( const MusObject *child );\n    \n    /**\n     * Insert a element at the idx position.\n     */\n    void InsertChild( MusObject *element, int idx );\n    \n    /**\n     * Detach the child at the idx position (NULL if not found)\n     * The parent pointer is set to NULL.\n     */\n    MusObject *DetachChild( int idx );\n    \n    /**\n     * Remove and delete the child at the idx position.\n     */\n    void RemoveChildAt( int idx );\n    \n    /**\n     * Return the first parent of the specified type.\n     * The maxSteps parameter limit the search to a certain number of level if not -1.\n     */\n    MusObject *GetFirstParent( const std::type_info *elementType, int maxSteps = -1 );\n    \n    /**\n     * Return the first of the specified type.\n     */\n    MusObject *GetFirstChild( const std::type_info *elementType );\n    \n    /**\n     * Return the previous sibling object of the specified type.\n     * If no type is specified, returns the previous object.\n     * Returns NULL if not found in both cases.\n     */\n    MusObject *GetPreviousSibling( const std::type_info *elementType = NULL );\n    \n    /**\n     * Return the next sibling object of the specified type.\n     * If no type is specified, returns the next object.\n     * Returns NULL if not found in both cases.\n     */\n    MusObject *GetNextSibling( const std::type_info *elementType = NULL );\n    \n    /**\n     * Fill the list of all the children MusLayerElement.\n     * This is used for navigating in a MusLayer (See MusLayer::GetPrevious and MusLayer::GetNext).\n     */  \n    void FillList( ListOfMusObjects *list );\n    \n    /**\n     * Add a sameAs attribute to the object.\n     * If a filename is given, the attribute will be filename#id.\n     * If several value are added, they will be separated by a whitespace.\n     */\n    void AddSameAs( std::string id, std::string filename = \"\" );\n    \n    /**\n     * Parse the sameAs attribute and return the one at the #idx position (if any).\n     */\n    bool GetSameAs( std::string *id, std::string *filename, int idx = 0 );\n    \n    /**\n     * Check if the content was modified or not\n     */\n    bool IsModified( ) { return m_isModified; };\n    \n    /**\n     * Mark the object and its parent (if any) as modified\n     */\n    void Modify( bool modified = true );\n    \n    /**\n     * Main method that processes functors.\n     * For each object, it will call the functor.\n     * Depending on the code returned by the functor, it will also process it for all children.\n     */\n    virtual void Process( MusFunctor *functor, ArrayPtrVoid params, MusFunctor *endFunctor = NULL );\n    \n    // functor methods\n    /**\n     * Add each MusLayerElements and its children to a list\n     */\n    virtual int AddMusLayerElementToList( ArrayPtrVoid params );\n    \n    /**\n     * See MusLayer::CopyToLayer\n     */ \n    virtual int CopyToLayer( ArrayPtrVoid params ) { return false; };\n    \n    /**\n     * Find a MusObject with a specified uuid.\n     * param 0: the uuid we are looking for.\n     * param 1: the pointer to pointer to the MusObject retrieved (if found).\n     */\n    virtual int FindByUuid( ArrayPtrVoid params );\n    \n    /**\n     * Save the content of and object by calling the appropriate MusFileOutputStream method\n     * param 0: a pointer to the MusFileOutputStream.\n     */\n    virtual int Save( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Adjust the size of a system according to its content\n     * See MusSystem::TrimSystem for actual implementation.\n     */\n    virtual int TrimSystem( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n\n    /**\n     * Lay out the X positions of the staff content looking that the bounding boxes.\n     * The m_xShift is updated appropriately\n     */\n    virtual int SetBoundingBoxXShift( ArrayPtrVoid params );\n    \n    /**\n     * Lay out the X positions of the staff content looking that the bounding boxes.\n     * This is the MusFunctor called at the end of the measure or a layer.\n     */\n    virtual int SetBoundingBoxXShiftEnd( ArrayPtrVoid params );\n    \n    /**\n     * Lay out the Y positions of the staff looking that the bounding box of each staff.\n     * The m_yShift is updated appropriately\n     */\n    virtual int SetBoundingBoxYShift( ArrayPtrVoid params );\n    \n    /**\n     * Align the content of a system.\n     * For each MusLayerElement, instanciate its MusAlignment.\n     * It creates it if no other note or event occurs at its position.\n     */\n    virtual int Align( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Set the position of the MusAlignment.\n     * Looks at the time different with the previous MusAlignment.\n     */\n    virtual int SetAligmentXPos( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n\n    /**\n     * Set the position of the StaffAlignment.\n     */\n    virtual int SetAligmentYPos( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Set the initial scoreDef of each page.\n     * This is necessary for integrating changes that occur within a page.\n     */\n    virtual int SetPageScoreDef( ArrayPtrVoid params );\n\n    /**\n     * Set the initial scoreDef of each page.\n     * This is necessary for integrating changes that occur within a page.\n     * param 0: bool clef flag.\n     * param 1: bool keysig flag.\n     * param 2: bool the mensur flag.\n     */\n    virtual int SetStaffDefDraw( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Replace all the staffDefs in a scoreDef.\n     * param 0: a pointer to the scoreDef we are going to replace the staffDefs\n     */\n    virtual int ReplaceStaffDefsInScoreDef( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Correct the X alignment once the the content of a system has been aligned and laid out\n     * See MusMeasure::IntegrateBoundingBoxXShift for actual implementation\n     */\n    virtual int IntegrateBoundingBoxXShift( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Correct the Y alignment once the the content of a system has been aligned and laid out\n     * See MusSystem::IntegrateBoundingBoxYShift for actual implementation\n     */\n    virtual int IntegrateBoundingBoxYShift( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Align the measures by adjusting the m_xRel position looking at the MusMeasureAligner.\n     */\n    virtual int AlignMeasures( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Store the width of the system in the MusMeasureAligner for justification\n     * This method is called at the end of a system\n     */\n    virtual int AlignMeasuresEnd( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Justify the X positions\n     */\n    virtual int JustifyX( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n    \n    /**\n     * Align the system by adjusting the m_yRel position looking at the MusSystemAligner.\n     */\n    virtual int AlignSystems( ArrayPtrVoid params ) { return FUNCTOR_CONTINUE; };\n\npublic:\n    ArrayOfMusObjects m_children;\n    MusObject *m_parent;\n    std::string m_sameAs;\n    \nprotected:\n    std::string m_uuid;\n    std::string m_classid;\n\nprivate:\n    \n    void GenerateUuid();\n    void Init(std::string);\n    \n    /**\n     * Indicated whether the object content is up-to-date or not.\n     * This is usefull for object using sub-lists of objects when drawing.\n     * For example, MusBeam has a list of children notes and this value indicates if the\n     * list needs to be updated or not. Is is moslty and optimization feature.\n     */\n    bool m_isModified;\n    \n};\n\n\n//----------------------------------------------------------------------------\n// MusDocObject\n//----------------------------------------------------------------------------\n\n/** \n * This class represents a basic object in the layout domain\n */\nclass MusDocObject: public MusObject\n{\npublic:\n    // constructors and destructors\n    MusDocObject();\n    MusDocObject(std::string classid);\n    virtual ~MusDocObject();\n    \n    /**\n     * Refreshes the views from MusDoc.\n     * From other MusDocObject, simply pass it to its parent until MusDoc is reached.\n     */\n    virtual void Refresh();\n    \n    void UpdateContentBB( int x1, int y1, int x2, int y2);\n    void UpdateSelfBB( int x1, int y1, int x2, int y2 );\n    bool HasContentBB();\n    bool HasSelfBB();\n    void ResetBB();\n\n    int m_contentBB_x1, m_contentBB_y1, m_contentBB_x2, m_contentBB_y2;\n    int m_selfBB_x1, m_selfBB_y1, m_selfBB_x2, m_selfBB_y2; \n    \n    /**\n     * Is true if the bounding box (self or content) has been updated at least once.\n     * We need this to avoid not updating bounding boxes to screw up the layout with their intial values.\n     */\n    bool HasUpdatedBB( ) { return m_updatedBB; };\n    \nprivate:\n    bool m_updatedBB;\n    \nprotected:\n    \npublic:\n    \n};\n\n\n//----------------------------------------------------------------------------\n// MusObjectListInterface\n//----------------------------------------------------------------------------\n\n/** \n * This class is an interface for elements maintaining a list of children\n * MusLayerElement for processing.\n * The list is a flatten list of pointers to children elements.\n * It is not an abstract class but should not be instanciate directly.\n */\nclass MusObjectListInterface\n{\npublic:\n    // constructors and destructors\n    MusObjectListInterface() {};\n    virtual ~MusObjectListInterface() {};\n    MusObjectListInterface( const MusObjectListInterface& interface ); // copy constructor;\n    MusObjectListInterface& operator=( const MusObjectListInterface& interface ); // copy assignement;\n\n    /**\n     * Look for the MusObject in the list and return its position (-1 if not found)\n     */\n    int GetListIndex( const MusObject *listElement );\n    \n    /**\n     * Returns the previous object in the list (NULL if not found)\n     */\n    MusObject *GetListPrevious( const MusObject *listElement );\n\n    /**\n     * Returns the next object in the list (NULL if not found)\n     */\n    MusObject *GetListNext( const MusObject *listElement );\n    \n    /**\n     * Return the list.\n     * Before returning the list, it checks that the list is up-to-date with MusObject::IsModified\n     * If not, it updates the list and also calls FilterList.\n     * Because this is an interface, we need to pass the object - not the best design.\n     */\n    ListOfMusObjects *GetList( MusObject *node );\n    \nprotected:\n    /**\n     * Filter the list for a specific class.\n     * For example, keep only notes in MusBeam\n     */\n    virtual void FilterList() {};\n\npublic:    \n    /**\n     * Reset the list of children and call FilterList().\n     * As for GetList, we need to pass the object.\n     */\n    void ResetList( MusObject *node );\n        \n    ListOfMusObjects m_list;\n    \n};\n\n//----------------------------------------------------------------------------\n// abstract base class MusFunctor\n//----------------------------------------------------------------------------\n\n/** \n * This class is an abstact Functor for the object hierarchy.\n * Needs testing.\n */\nclass MusFunctor\n{\nprivate:\n    int (MusObject::*obj_fpt)( ArrayPtrVoid params );   // pointer to member function\n    \npublic:\n    \n    // constructor - takes pointer to an object and pointer to a member and stores\n    // them in two private variables\n    MusFunctor( );\n    MusFunctor( int(MusObject::*_obj_fpt)( ArrayPtrVoid ));\n\tvirtual ~MusFunctor() {};\n    \n    // override function \"Call\"\n    virtual void Call( MusObject *ptr, ArrayPtrVoid params );\n    \n    int m_returnCode;\n    bool m_reverse;\n    \nprivate:\n    \n};\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator& rand);\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b);\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility>\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _VSTD::move(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_first_of(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return __first1;  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return __first1;\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_RandomAccessIterator1\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __first1;\n    _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return __last1;\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return __first1;\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return __first1;\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __n, __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            swap(*__first, *__last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    pair<const _Tp*, const _Tp*> __p =\n                                   _VSTD::minmax_element(__t.begin(), __t.end());\n    return pair<_Tp, _Tp>(*__p.first, *__p.second);\n}\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    pair<const _Tp*, const _Tp*> __p =\n                           _VSTD::minmax_element(__t.begin(), __t.end(), __comp);\n    return pair<_Tp, _Tp>(*__p.first, *__p.second);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __merge<_Compare>(move_iterator<value_type*>(__buff),\n                          move_iterator<value_type*>(__p),\n                          move_iterator<_BidirectionalIterator>(__middle),\n                          move_iterator<_BidirectionalIterator>(__last),\n                          __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),\n                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),\n                _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n        {\n            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);\n            return;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _Tp>\nstruct __inplace_merge_switch\n{\n    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__push_heap_front(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,\n                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        difference_type __p = 0;\n        _RandomAccessIterator __pp = __first;\n        difference_type __c = 2;\n        _RandomAccessIterator __cp = __first + __c;\n        if (__c == __len || __comp(*__cp, *(__cp - 1)))\n        {\n            --__c;\n            --__cp;\n        }\n        if (__comp(*__pp, *__cp))\n        {\n            value_type __t(_VSTD::move(*__pp));\n            do\n            {\n                *__pp = _VSTD::move(*__cp);\n                __pp = __cp;\n                __p = __c;\n                __c = (__p + 1) * 2;\n                if (__c > __len)\n                    break;\n                __cp = __first + __c;\n                if (__c == __len || __comp(*__cp, *(__cp - 1)))\n                {\n                    --__c;\n                    --__cp;\n                }\n            } while (__comp(__t, *__cp));\n            *__pp = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__push_heap_back(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n                 typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __push_heap_back<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __push_heap_back<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __push_heap_front<_Compare>(__first, __last, __comp, __len-1);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        __last = __first;\n        ++__last;\n        for (difference_type __i = 1; __i < __n;)\n            __push_heap_back<_Compare>(__first, ++__last, __comp, ++__i);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __push_heap_front<_Compare>(__first, __middle, __comp, __len);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = 0;\n        for (; __first != __last && __r != __result_last; ++__first, ++__r, ++__len)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __push_heap_front<_Compare>(__result_first, __r, __comp, __len);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_left(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_right(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;\n    typedef integral_constant<bool, false> false_type;\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n}  // std\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\ntypedef integral_constant<bool, true>  true_type;\ntypedef integral_constant<bool, false> false_type;\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __is_void       : public false_type {};\ntemplate <>          struct __is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __is_void<typename remove_cv<_Tp>::type> {};\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct ____is_nullptr_t       : public false_type {};\ntemplate <>          struct ____is_nullptr_t<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public ____is_nullptr_t<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public ____is_nullptr_t<typename remove_cv<_Tp>::type> {};\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __is_integral                     : public false_type {};\ntemplate <>          struct __is_integral<bool>               : public true_type {};\ntemplate <>          struct __is_integral<char>               : public true_type {};\ntemplate <>          struct __is_integral<signed char>        : public true_type {};\ntemplate <>          struct __is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __is_integral<short>              : public true_type {};\ntemplate <>          struct __is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __is_integral<int>                : public true_type {};\ntemplate <>          struct __is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __is_integral<long>               : public true_type {};\ntemplate <>          struct __is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __is_integral<long long>          : public true_type {};\ntemplate <>          struct __is_integral<unsigned long long> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __is_integral<typename remove_cv<_Tp>::type> {};\n\n// is_floating_point\n\ntemplate <class _Tp> struct __is_floating_point              : public false_type {};\ntemplate <>          struct __is_floating_point<float>       : public true_type {};\ntemplate <>          struct __is_floating_point<double>      : public true_type {};\ntemplate <>          struct __is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __is_floating_point<typename remove_cv<_Tp>::type> {};\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n// is_pointer\n\ntemplate <class _Tp> struct __is_pointer       : public false_type {};\ntemplate <class _Tp> struct __is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __is_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if defined(__clang__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n#define _LIBCPP_HAS_TYPE_TRAITS\n#endif\n\n// is_union\n\n#if __has_feature(is_union) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n// is_function\n\nnamespace __is_function_imp\n{\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source();\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __is_function\n    : public integral_constant<bool, sizeof(__is_function_imp::__test<_Tp>(__is_function_imp::__source<_Tp>())) == 1>\n    {};\ntemplate <class _Tp> struct __is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __is_function<_Tp> {};\n\n// is_member_function_pointer\n\ntemplate <class _Tp> struct            __is_member_function_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __is_member_function_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n// is_enum\n\n#if __has_feature(is_enum) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename remove_reference<_Tp>::type* type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct ___is_signed : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};\n\ntemplate <class _Tp>\nstruct ___is_signed<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __is_signed : public ___is_signed<_Tp> {};\n\ntemplate <class _Tp> struct __is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __is_signed<_Tp> {};\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct ___is_unsigned : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};\n\ntemplate <class _Tp>\nstruct ___is_unsigned<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __is_unsigned : public ___is_unsigned<_Tp> {};\n\ntemplate <class _Tp> struct __is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __is_unsigned<_Tp> {};\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // __has_feature(is_base_of)\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // __has_feature(is_base_of)\n\n// is_convertible\n\n#if __has_feature(is_convertible_to)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> char  __test(_Tp);\ntemplate <class _Tp> __two __test(...);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> _Tp&& __source();\n#else\ntemplate <class _Tp> typename remove_reference<_Tp>::type& __source();\n#endif\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n#else\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n// is_empty\n\n#if __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else  // _LIBCPP_HAS_TYPE_TRAITS\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif  // _LIBCPP_HAS_TYPE_TRAITS\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[_Len];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[_Len];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = (is_arithmetic<_A1>::value || is_void<_A1>::value) &&\n                 (is_arithmetic<_A2>::value || is_void<_A2>::value) &&\n                 (is_arithmetic<_A3>::value || is_void<_A3>::value)>\nclass __promote {};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\n    typedef typename __promote<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n};\n\ntemplate <class _A1>\nclass __promote<_A1, void, void, true>\n{\npublic:\n    typedef typename conditional<is_arithmetic<_A1>::value,\n                     typename conditional<is_integral<_A1>::value, double, _A1>::type,\n                     void\n            >::type type;\n};\n\n#ifdef _LIBCPP_STORE_AS_OPTIMIZATION\n\n// __transform\n\ntemplate <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};\ntemplate <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};\ntemplate <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};\ntemplate <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};\ntemplate <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};\n\n#endif  // _LIBCPP_STORE_AS_OPTIMIZATION\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n    __nat\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n    __nat\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class V = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef _Tp type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp&& __t();\n    static _Up&& __u();\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp __t();\n    static _Up __u();\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\npublic:\n    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class ..._Tp> struct common_type;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n{\nprivate:\n    static _Tp&& __t();\n    static _Up&& __u();\n    static bool __f();\npublic:\n    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n{\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename T> struct __select_2nd { typedef T type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_lvalue_reference<_Tp>::type> {};\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n// is_destructible\n\ntemplate <class _Tp>\nstruct __destructible_test\n{\n    _Tp __t;\n};\n\ntemplate <class _Tp>\ndecltype((_VSTD::declval<__destructible_test<_Tp> >().~__destructible_test<_Tp>(), true_type()))\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_destructible_test(_Tp&&);\n#else\n__is_destructible_test(_Tp&);\n#endif\n\nfalse_type\n__is_destructible_test(__any);\n\ntemplate <class _Tp, bool = is_void<_Tp>::value || is_abstract<_Tp>::value\n                                                || is_function<_Tp>::value>\nstruct __destructible_imp\n    : public common_type\n        <\n            decltype(__is_destructible_test(declval<_Tp>()))\n        >::type {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_imp<_Tp> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public false_type {};\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\ntemplate <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\nnamespace __is_construct\n{\n\nstruct __nat {};\n\n}\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                               const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};\n\n#else  // _LIBCPP_HAS_TYPE_TRAITS\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif  // _LIBCPP_HAS_TYPE_TRAITS\n\n// is_nothrow_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp, class... _Args> struct __is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __is_nothrow_constructible<true, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct __is_nothrow_constructible<false, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp, class _Arg> struct __is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                               const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp> struct __is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else  // _LIBCPP_HAS_TYPE_TRAITS\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_TYPE_TRAITS\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#if __has_feature(is_literal)\n    : public integral_constant<bool, __is_literal(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial)\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\n#endif\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\ntemplate <class ..._Args>\nauto\n__invoke(__any, _Args&& ...__args)\n    -> __nat;\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f);\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));\n\n// __invokable\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable_imp\n    : private __check_complete<_Fp>\n{\n    typedef decltype(\n            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)\n                    ) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable\n    : public integral_constant<bool,\n          __invokable_imp<_Fp, _Args...>::value>\n{\n};\n\n// __invoke_of\n\ntemplate <bool _Invokable, class _Fp, class ..._Args>\nstruct __invoke_of_imp  // false\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of_imp<true, _Fp, _Args...>\n{\n    typedef typename __invokable_imp<_Fp, _Args...>::type type;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp>\nstruct __swappable\n{\n    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable<_Tp>::value>\n{\n};\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp>\nstruct __is_nothrow_swappable_imp\n    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),\n                                                   _VSTD::declval<_Tp&>()))>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable_imp<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public false_type\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#ifdef _LIBCXX_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCXX_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCXX_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCXX_UNDERLYING_TYPE\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_imp\n{\n    template <class>\n        static auto __test(__any) -> false_type;\n    template <class _Up>\n        static auto __test(_Up* __u)\n            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;\n\n    static const bool value = decltype(__test<_Tp>(nullptr))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    explicit __split_buffer(__alloc_rr& __a);\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__alloc_rr>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr&, __alloc_rr&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_alloc(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===--------------------------- cstddef ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CSTDDEF\n#define _LIBCPP_CSTDDEF\n\n/*\n    cstddef synopsis\n\nMacros:\n\n    offsetof(type,member-designator)\n    NULL\n\nnamespace std\n{\n\nTypes:\n\n    ptrdiff_t\n    size_t\n    max_align_t\n    nullptr_t\n\n}  // std\n\n*/\n\n#include <__config>\n\n#ifdef __GLIBC__\n#define __need_NULL\n#define __need_ptrdiff_t\n#define __need_size_t\n#endif  // __GLIBC__\n\n#include <stddef.h>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nusing ::ptrdiff_t;\nusing ::size_t;\n\ntypedef long double max_align_t;\n\n#ifdef _LIBCPP_HAS_NO_NULLPTR\n\nstruct _LIBCPP_TYPE_VIS_ONLY nullptr_t\n{\n    void* __lx;\n\n    struct __nat {int __for_bool_;};\n\n    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t() : __lx(0) {}\n    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t(int __nat::*) : __lx(0) {}\n\n    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR operator int __nat::*() const {return 0;}\n\n    template <class _Tp>\n        _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR\n        operator _Tp* () const {return 0;}\n\n    template <class _Tp, class _Up>\n        _LIBCPP_ALWAYS_INLINE\n        operator _Tp _Up::* () const {return 0;}\n\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator==(nullptr_t, nullptr_t) {return true;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator!=(nullptr_t, nullptr_t) {return false;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator<(nullptr_t, nullptr_t) {return false;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator<=(nullptr_t, nullptr_t) {return true;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator>(nullptr_t, nullptr_t) {return false;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator>=(nullptr_t, nullptr_t) {return true;}\n};\n\ninline _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t __get_nullptr_t() {return nullptr_t(0);}\n\n#define nullptr _VSTD::__get_nullptr_t()\n\n#endif  // _LIBCPP_HAS_NO_NULLPTR\n\n_LIBCPP_END_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_NULLPTR\n\nnamespace std\n{\n    typedef decltype(nullptr) nullptr_t;\n}\n\n#endif  // _LIBCPP_HAS_NO_NULLPTR\n\n#endif  // _LIBCPP_CSTDDEF\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musapp.cpp\n// Author:      Laurent Pugin\n// Created:     2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musapp.h\"\n\n//----------------------------------------------------------------------------\n\n#include \"musio.h\"\n\n//----------------------------------------------------------------------------\n// MusLayerApp\n//----------------------------------------------------------------------------\n\nMusLayerApp::MusLayerApp():\n    MusLayerElement()\n{\n}\n\nMusLayerApp::~MusLayerApp()\n{\n    \n}\n\nvoid MusLayerApp::AddLayerRdg( MusLayerRdg *layerRdg )\n{\n    //assert(this->m_layer->m_staff); // Layer staff cannot be NULL when adding and <rdg>\" \n    // The the to the parent staff will be NULL!\n    //layerRdg->SetStaff( this->m_layer->m_staff );\n    \n\tlayerRdg->SetParent( this );\n    m_children.push_back( layerRdg );\n    Modify();\n}\n\nint MusLayerApp::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];         \n    if (!output->WriteLayerApp( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n}\n\n//----------------------------------------------------------------------------\n// MusLayerRdg\n//----------------------------------------------------------------------------\n\nMusLayerRdg::MusLayerRdg( ):\n    MusObject()\n{\n\n}\n\n\nMusLayerRdg::~MusLayerRdg()\n{\n    \n}\n\n\nvoid MusLayerRdg::AddElement( MusLayerElement *element, int idx )\n{\n\telement->SetParent( this );\n    if ( idx == -1 ) {\n        m_children.push_back( element );\n    }\n    else {\n        InsertChild( element, idx );\n    }\n}\n\n\nint MusLayerRdg::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];       \n    if (!output->WriteLayerRdg( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muslayerelement.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_LAYER_ELEMENT_H__\n#define __MUS_LAYER_ELEMENT_H__\n\n#include \"musdc.h\" // for MusPoint\n#include \"musdef.h\"\n#include \"musobject.h\"\n\nclass MusAlignment;\n\n//----------------------------------------------------------------------------\n// MusLayerElement\n//----------------------------------------------------------------------------\n\n/** \n * This class is a base class for the MusLayer (<layer>) content.\n * It is not an abstract class but should not be instanciate directly.\n */\nclass MusLayerElement: public MusDocObject\n{\npublic:\n    // constructors and destructors\n    MusLayerElement();\n    MusLayerElement(std::string classid);\n    virtual ~MusLayerElement();\n    \n    MusLayerElement& operator=( const MusLayerElement& element ); // copy assignement - this need to be changed to the MusObject::Clone way;\n    \n    /**\n     * Return a copy of the MusLayerElement (child class).\n     * By default, a new uuid is generated\n     */\n    MusLayerElement *GetChildCopy( bool newUuid = true );\n    \n    /**\n     * Return the default horizontal spacing of elements.\n     * This method should be redefined whenever necessary in the child classes.\n     */\n    virtual int GetHorizontalSpacing( );\n    \n    /** Adjust the pname and the octave for values outside the range */\n    static void AdjustPname( int *pname, int *oct );\n    \n    /** \n     * Set the pitch or position for MusPitchInterface or MusPositionInterface elements.\n     * Because MusPitchInterface and PositionInterface are not child classes of MusLayerElement,\n     * the call had to be done explicitly from this method. The method can still be overriden.\n     */\n    virtual void SetPitchOrPosition( int pname, int oct );\n    \n    /**\n     * Get the pitch or position for MusPitchInterface or MusPositionInterface elements.\n     * See MusLayerElement::SetPitchOrPosition for more comments.\n     */\n    virtual bool GetPitchOrPosition( int *pname, int *oct );\n    \n    /**\n     * Set the value for child element of MusLayerElement.\n     * For example, set the duration for MusDurationInterface elements (call explicitly) \n     */\n\tvirtual void SetValue( int value, int flag = 0 );\n    \n    /**\n     * Change the coloration for MusNote elements.\n     */ \n\tvirtual void ChangeColoration( ) {};\n    \n    /**\n     * Change the stem direction for MusNote elements.\n     */\n\tvirtual void ChangeStem( ) {};\n    \n    /**\n     * Set the ligature flag for MusNote elements.\n     */\n\tvirtual void SetLigature( ) {};\n    \n    \n    int GetElementNo() const;\n\n    \n    bool IsBarline();\n    bool IsBeam();\n    bool IsClef();\n    bool HasDurationInterface();\n    bool IsKeySig();\n    bool IsMensur();\n    bool IsMultiRest();\n    bool IsNeume();\n    bool IsNeumeSymbol();\n    bool IsNote();\n    bool HasPitchInterface();\n    bool HasPositionInterface();\n    bool IsRest();\n    bool IsSymbol( SymbolType type );\n    bool IsSymbol( );\n    \n    virtual double GetAlignementDuration();\n    \n    MusAlignment *GetAlignment() { return m_alignment; };\n    \n    int GetXRel();\n    \n    // functors\n    /**\n     * Save the object (virtual).\n     * Most of the child classes do not override it. In these cases, the actual \n     * saving occurs in the MusFileOutputStream::WriteLayerElement method\n     * A few classes, such as MusLayerApp, have an overriden version.\n     */\n    virtual int Save( ArrayPtrVoid params );\n    \n    /**\n     * Align the content of a system.\n     */\n    virtual int Align( ArrayPtrVoid params );\n    \nprivate:\n    void Init();\n    \npublic:\n\t/** Absolute position X. This is used for facsimile (transcription) encoding */\n    int m_xAbs;\n\t/** Relative position X. This is used internally when calculating the layout */\n    //int m_xRel;\n\t/** Drawing position X. This is used internally when drawing */\n    int m_xDrawing;\n\t/** Drawing position Y. This is used internally when drawing */\n\tint m_yDrawing; \n    /** for elements in MusLayerApp. They will be drawn from the MusLayerElement of the app (and not from the layer) */\n    bool m_in_layer_app;\n    /** Indicates if cue size */\n    bool m_cueSize;\n    /** Indicates an horizontal offset */\n    int m_hOffset;\n    /** Indicates if occurs on staff above (-1) or below (1) */\n    char m_staffShift;\n    /** Indicates if visible (default) or not */\n    bool m_visible;\n\n    /** If this is a note, store here the stem coordinates (useful for ex. tuplets) */\n    MusPoint m_stem_start; // beginning point, the one near the note\n    MusPoint m_stem_end; // end point (!), near beam or stem\n    /** stem direction as drawn, true = up, false = down */\n    bool m_drawn_stem_dir;\n    \nprotected:\n    MusAlignment *m_alignment;\n    \n};\n\n\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musbarline.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musbarline.h\"\n\n//----------------------------------------------------------------------------\n// MusBarline\n//----------------------------------------------------------------------------\n\nMusBarline::MusBarline():\n\tMusLayerElement(\"bline-\")\n{\n    m_barlineType = BARLINE_SINGLE;\n    m_partialBarline = false; // this was used unitialized\n    m_onStaffOnly = false; // is this good?\n}\n\nMusBarline::~MusBarline()\n{\n}\n\nbool MusBarline::operator==( MusObject& other )\n{\n    MusBarline *otherBarline = dynamic_cast<MusBarline*>( &other );\n    if ( !otherBarline ) {\n        return false;\n    }\n    return true;\n}\n\nbool MusBarline::HasRepetitionDots()\n{\n    if (m_barlineType == BARLINE_RPTSTART || m_barlineType == BARLINE_RPTEND || m_barlineType == BARLINE_RPTBOTH) {\n        return true;\n    }\n    return false;\n}","/////////////////////////////////////////////////////////////////////////////\n// Name:        musbarline.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_BARLINE_H__\n#define __MUS_BARLINE_H__\n\n#include \"musdef.h\"\n#include \"muslayerelement.h\"\n\n//----------------------------------------------------------------------------\n// MusBarline\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <barline> element. \n */\nclass MusBarline: public MusLayerElement\n{\npublic:\n    // constructors and destructors\n    MusBarline();\n    virtual ~MusBarline();\n    \n    /**\n     * Comparison operator. \n     * Check if the MusLayerElement if a MusBarline and compare attributes\n     */\n    virtual bool operator==(MusObject& other);\n    \n    virtual std::string MusClassName( ) { return \"MusBarline\"; };\n    \n    /**\n     * Use to set the alignment for the MusMeasure MusBarline members.\n     * This is as special case where we need to add to the measure aligner.\n     */\n    void SetAlignment( MusAlignment *alignment ) { m_alignment = alignment; };\n    \n    /*\n     * Return true if the barline type requires repetition dots to be drawn.\n     */\n    bool HasRepetitionDots( );\n    \n    /**\n     * Return the default horizontal spacing of notes.\n     */\n    virtual int GetHorizontalSpacing( ) { return 0; }\n    \nprivate:\n    \npublic:\n    /** Indicates the barline type (@rend) */\n    BarlineType m_barlineType;\n    /** Indicates a partial barline (inbetween the staves) - no MEI equivalent */\n    bool m_partialBarline;\n    /** Indicates a barline displayed only on the staff - no MEI equivalent */\n    bool m_onStaffOnly;\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musmeasure.h\n// Author:      Laurent Pugin\n// Created:     2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musmeasure.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musdef.h\"\n#include \"musio.h\"\n#include \"musstaff.h\"\n\n//----------------------------------------------------------------------------\n// MusMeasure\n//----------------------------------------------------------------------------\n\nMusMeasure::MusMeasure( bool measureMusic, int logMeasureNb ):\n    MusDocObject(\"measure-\")\n{\n\tClear( );\n    m_measuredMusic = measureMusic;\n    m_logMeasureNb = logMeasureNb;\n    if ( !m_measuredMusic ) {\n        m_xAbs = 0;\n    }\n}\n\nMusMeasure::~MusMeasure()\n{\n    \n}\n\nvoid MusMeasure::Clear()\n{\n\tClearChildren();\n    m_parent = NULL;\n    m_logMeasureNb = -1;\n    m_measuredMusic = true;\n    m_xAbs = AX_UNSET;\n    m_xRel = 0;\n    m_xDrawing = 0;\n    // by default, we have a single barline on the right (none on the left)\n    m_rightBarline.m_barlineType = BARLINE_SINGLE;\n    m_leftBarline.m_barlineType = BARLINE_NONE;\n}\n\nint MusMeasure::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];\n    if (!output->WriteMeasure( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n\n}\n\nvoid MusMeasure::AddStaff( MusStaff *staff )\n{    \n\tstaff->SetParent( this );\n\tm_children.push_back( staff );\n    \n    if ( staff->GetStaffNo() == -1 ) {\n        staff->SetStaffNo( this->GetStaffCount() );\n    }\n}\n\nMusStaff *MusMeasure::GetFirst( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\treturn (MusStaff*)m_children[0];\n}\n\nMusStaff *MusMeasure::GetLast( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\tint i = GetStaffCount() - 1;\n\treturn (MusStaff*)m_children[i];\n}\n\nMusStaff *MusMeasure::GetNext( MusStaff *staff )\n{\n    if ( !staff || m_children.empty())\n        return NULL;\n    \n\tint i = 0; GetChildIndex( staff );\n    \n\tif ((i == -1 ) || ( i >= GetStaffCount() - 1 ))\n\t\treturn NULL;\n    \n\treturn (MusStaff*)m_children[i + 1];\n}\n\nMusStaff *MusMeasure::GetPrevious( MusStaff *staff )\n{\n    if ( !staff || m_children.empty())\n        return NULL;\n    \n\tint i = GetChildIndex( staff );\n    \n\tif ((i == -1 ) || ( i <= 0 ))\n        return NULL;\n\t\n    return (MusStaff*)m_children[i - 1];\n}\n\n\nMusStaff *MusMeasure::GetStaffWithIdx( int staffIdx )\n{\n    if ( staffIdx > (int)m_children.size() - 1 )\n        return NULL;\n\t\n\treturn (MusStaff*)m_children[staffIdx];\n}\n\n\nMusStaff *MusMeasure::GetStaffWithNo( int staffNo )\n{\n    int i;\n    MusStaff *staff = NULL;\n    for (i = 0; i < this->GetStaffCount(); i++ ) {\n        staff = dynamic_cast<MusStaff*>(m_children[i]);\n        if ( staff && (staff->GetStaffNo() == staffNo ) ) {\n            return staff;\n        }\n    }\n\treturn NULL;\n}\n\nint MusMeasure::GetXRel()\n{\n    if ( m_measureAligner.GetLeftAlignment() ) {\n        return m_measureAligner.GetLeftAlignment()->GetXRel();\n    }\n    return 0;\n}\n\nint MusMeasure::GetXRelRight()\n{\n    if ( m_measureAligner.GetRightAlignment() ) {\n        return m_measureAligner.GetRightAlignment()->GetXRel();\n    }\n    return 0;\n}\n\n//----------------------------------------------------------------------------\n// MusMeasure functor methods\n//----------------------------------------------------------------------------\n\nint MusMeasure::Align( ArrayPtrVoid params )\n{\n    // param 0: the measureAligner\n    // param 1: the time (unused)\n    // param 2: the systemAligner (unused)\n    // param 3: the staffNb\n    MusMeasureAligner **measureAligner = (MusMeasureAligner**)params[0];\n    int *staffNb = (int*)params[3];\n    \n    // clear the content of the measureAligner\n    m_measureAligner.Reset();\n    \n    // point to it\n    (*measureAligner) = &m_measureAligner;\n    \n    if ( m_rightBarline.m_barlineType != BARLINE_NONE ) {\n        m_rightBarline.SetAlignment( m_measureAligner.GetRightAlignment() );\n    }\n    \n    // we also need to reset the staffNb\n    (*staffNb) = 0;\n    \n    assert( *measureAligner );\n        \n    return FUNCTOR_CONTINUE;\n}\n\nint MusMeasure::IntegrateBoundingBoxXShift( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift (unused)\n    // param 1: the functor to be redirected to MusAligner\n    MusFunctor *integrateBoundingBoxShift = (MusFunctor*)params[1];\n    \n    m_measureAligner.Process( integrateBoundingBoxShift, params);\n    \n    return FUNCTOR_SIBLINGS;\n}\n\nint MusMeasure::SetAligmentXPos( ArrayPtrVoid params )\n{\n    // param 0: the previous time position (unused)\n    // param 1: the previous x rel position (unused)\n    // param 2: the functor to be redirected to MusAligner\n    MusFunctor *setAligmnentPosX = (MusFunctor*)params[2];\n    \n    m_measureAligner.Process( setAligmnentPosX, params);\n    \n    return FUNCTOR_SIBLINGS;\n}\n\n#include <math.h>\n\nint MusMeasure::JustifyX( ArrayPtrVoid params )\n{\n    // param 0: the justification ratio\n    // param 1: the system full width (without system margins) (unused)\n    // param 2: the functor to be redirected to the MusMeasureAligner\n    double *ratio = (double*)params[0];\n    MusFunctor *justifyX = (MusFunctor*)params[2];\n    \n    this->m_xRel = ceil((*ratio) * (double)this->m_xRel);\n    \n    m_measureAligner.Process( justifyX, params );\n    \n    return FUNCTOR_SIBLINGS;\n}\n\n\nint MusMeasure::AlignMeasures( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    int *shift = (int*)params[0];\n    \n    this->m_xRel = (*shift);\n    \n    assert( m_measureAligner.GetRightAlignment() );\n    \n    (*shift) += m_measureAligner.GetRightAlignment()->GetXRel();\n    \n    // We also need to take into account the measure end (right) barline with here\n    if (GetRightBarlineType() != BARLINE_NONE) {\n        // shift the next measure of the total with\n        (*shift) += GetRightBarline()->GetAlignment()->GetMaxWidth();\n    }\n    \n    return FUNCTOR_SIBLINGS;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musstaff.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_STAFF_H__\n#define __MUS_STAFF_H__\n\n#include \"musobject.h\"\n\n#define STAFF_OFFSET 190\n#define MAXCLE 100\t// maximum number of clef on one staff\n\nclass MusClef;\nclass MusDC;\nclass MusLayer;\nclass MusStaffAlignment;\n\n//----------------------------------------------------------------------------\n// MusStaff\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a staff in a laid-out score (MusDoc).\n * A MusStaff is contained in a MusSystem.\n * It contains MusMeasure objects.\n * For unmeasured music, on single MusMeasure is added for simplifying internal processing\n*/\nclass MusStaff: public MusDocObject\n{\n    \npublic:\n    // constructors and destructors\n    MusStaff( int n = -1 );\n\tMusStaff( const MusStaff& staff ); // copy contructor\n    virtual ~MusStaff();\n\n    virtual std::string MusClassName( ) { return \"MusStaff\"; };\t\n    \n    void Clear();\n    \n    void AddLayer( MusLayer *layer );\n\t\n\tint GetLayerCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Return the index position of the staff in its measure parent\n     */\n    int GetStaffIdx() const { return MusObject::GetIdx(); };\n    \n    /**\n     * @name Set and get  the staff number which is 1-based.\n     * This can be different from the index position in the parent measure.\n     */\n    ///@{\n    int GetStaffNo() const { return m_n; };\n    void SetStaffNo( int n ) { m_n = n; };\n    ///@}\n    \n    /**\n     * Return the default horizontal spacing of staves.\n     */\n    int GetVerticalSpacing();\n    \n    MusStaffAlignment *GetAlignment() { return m_staffAlignment; };\n    \n    int GetYRel();\n\n    // functors\n    virtual int Save( ArrayPtrVoid params );\n    virtual bool GetPosOnPage( ArrayPtrVoid params );\n    \n\tvoid CopyAttributes( MusStaff *staff ); // copy all attributes but none of the elements\n\t//void ClearElements( MusDC *dc , MusElement *start = NULL );\n\n\tMusLayer *GetFirst( );\n\tMusLayer *GetLast( );\n\tMusLayer *GetNext( MusLayer *layer );\n\tMusLayer *GetPrevious( MusLayer *layer );\n    MusLayer *GetLayerWithIdx( int LayerIdx );\n    \n    /**\n     * Align the content of a system.\n     */\n    virtual int Align( ArrayPtrVoid params );\n    \npublic:\n\t/** numero dans le groupe auquel appartient la portee */\n\tunsigned short noGrp;\n\t/** nombre total de portee dans le groupe */\n\tunsigned short totGrp;\n\t/** numero de systeme */\n\t//unsigned short noLigne; // ax2\n\t/** type d'armure. 0 = aucune1 = dieses2 = bemols */\n\tunsigned char armTyp;\n\t/** nombre d'alterations a l'armures */\n\tunsigned char armNbr;\n\t/** portee en notation ancienne */\n\tchar notAnc;\n\t/** portee grise */\n\tchar grise;\n\t/** portee invisible */\n\tchar invisible;\n\t/** barre verticale. 0 = aucun1 = debut2 = fin */\n\tunsigned char vertBarre;\n\t/** accolade ou bloc. 0 = aucun1 = debut2 = fin */\n\tunsigned char brace;\n\t/** taille. 0 = normale1 = petite  */\n\tunsigned char staffSize;\n\t\n    /** portee indentee\n\t\tchar dans Wolfgang - ici indentation par portee\n\t*/\n\t//int indent; // ax2 \n\t/** portee indentee a droite */\n\t//char indentDroite; // ax2\n\t/** type de portee (nombre de lignes) */\n\tunsigned char portNbLine;\n\t/** type d'accolade. 0 = bloc1 = accolade ronde */\n\tunsigned char accol;\n\t/** ???? */\n\tunsigned char accessoire;\n\t/** \n     * The Y absolute position of the staff for facsimile (transcription) encodings.\n     * This is the top left corner of the staff (the X position is the position of the system).\n     */\n    int m_yAbs;\n    /**\n     * The Y relative position of the staff.\n     * It is used internally when calculating the layout andd it is not stored in the file.\n     */\n    //int m_yRel;\n\t/** \n     * The Y drawing position of the staff.\n     * It is re-computed everytime the staff is drawn and it is not stored in the file.\n     */\n    int m_yDrawing;\n    \n    /** indicates this staff is in anchent notation\n     it has to be carried on to the LayedOutStaf */\n    bool m_mensuralNotation;\n\nprivate:\n    /** The staff number */\n    int m_n;\n    \n    /**\n     * A pointer to a MusStaffAlignment for aligning the staves\n     */\n    MusStaffAlignment *m_staffAlignment;\n\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musmeasure.h\n// Author:      Laurent Pugin\n// Created:     2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_MEASURE_H__\n#define __MUS_MEASURE_H__\n\n#include \"musobject.h\"\n\n#include \"musaligner.h\"\n#include \"musbarline.h\"\n\nclass MusStaff;\n\n//----------------------------------------------------------------------------\n// MusMeasure\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a measure in a page-based score (MusDoc).\n * A MusMeasure is contained in a MusStaff.\n * It contains MusLayer objects.\n * For internally simplication of processing, unmeasure music is contained in one single measure object\n */\nclass MusMeasure: public MusDocObject\n{\n    \npublic:\n    // constructors and destructors\n    MusMeasure( bool measuredMusic = true, int logMeasureNb = -1 );\n    virtual ~MusMeasure();\n    \n    virtual std::string MusClassName( ) { return \"MusMeasure\"; };\n    \n    /**\n     * Return true if measured music (otherwise we have fakes measures)\n     */\n    bool IsMeasuredMusic() { return m_measuredMusic; };\n    \n    void Clear();\n    \n\tvoid AddStaff( MusStaff *staff );\n\t\n\tint GetStaffCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Return the index position of the measure in its system parent\n     */\n    int GetMeasureNo() const { return MusObject::GetIdx(); };\n    \n    /**\n     * @name Set and get the left and right barline types\n     */\n    ///@{\n    BarlineType GetLeftBarlineType() const { return m_leftBarline.m_barlineType; };\n    void SetLeftBarlineType( BarlineType type ) { m_leftBarline.m_barlineType = type; };\n    BarlineType GetRightBarlineType() const { return m_rightBarline.m_barlineType; };\n    void SetRightBarlineType( BarlineType type ) { m_rightBarline.m_barlineType = type; };\n    ///@}\n    \n    /**\n     * @name Set and get the barlines. \n     * Careful - the barlines are owned by the measure and will be destroy by it.\n     * This method should be used only for acessing them (e.g., when drawing) and \n     * not for creating other measure objects.\n     */\n    ///@{\n    MusBarline *GetLeftBarline() { return &m_leftBarline; };\n    MusBarline *GetRightBarline() { return &m_rightBarline; };\n    ///@}\n       \n    // functors\n    virtual int Save( ArrayPtrVoid params );\n    \n\tvoid CopyAttributes( MusMeasure *measure ); // copy all attributes but none of the elements\n\t//void ClearElements( MusDC *dc , MusElement *start = NULL );\n    \n\tMusStaff *GetFirst( );\n\tMusStaff *GetLast( );\n\tMusStaff *GetNext( MusStaff *layer );\n\tMusStaff *GetPrevious( MusStaff *layer );\n    MusStaff *GetStaffWithIdx( int staffIdx );\n    \n    MusStaff *GetStaffWithNo( int staffNo );\n    \n    int GetXRel( );\n    \n    int GetXRelRight( );\n    \n    /**\n     * Align the content of a system.\n     */\n    virtual int Align( ArrayPtrVoid params );\n    \n    /**\n     * Correct the X alignment once the the content of a system has been aligned and laid out.\n     * Special case that redirects the functor to the MusMeasureAligner.\n     */\n    virtual int IntegrateBoundingBoxXShift( ArrayPtrVoid params );\n    \n    /**\n     * Set the position of the MusAlignment.\n     * Special case that redirects the functor to the MusMeasureAligner.\n     */\n    virtual int SetAligmentXPos( ArrayPtrVoid params );\n    \n    /**\n     * Align the measures by adjusting the m_xRel position looking at the MusMeasureAligner.\n     * This method also moves the end position of the measure according to the barline width.\n     */\n    virtual int AlignMeasures( ArrayPtrVoid params );\n    \n    /**\n     * Justify the X positions\n     * Special case that redirects the functor to the MusMeasureAligner.\n     */\n    virtual int JustifyX( ArrayPtrVoid params );\n        \npublic:\n    /** The logical staff */\n    int m_logMeasureNb;\n\t/**\n     * The X absolute position of the measure for facsimile (transcription) encodings.\n     * This is the top left position of the measure.\n     */\n    int m_xAbs;\n    /**\n     * The X relative position of the measure.\n     * It is used internally when calculating the layout and it is not stored in the file.\n     */\n    int m_xRel;\n\t/**\n     * The X drawing position of the measure.\n     * It is re-computed everytime the measure is drawn and it is not stored in the file.\n     */\n    int m_xDrawing;\n    \nprivate:\n    bool m_measuredMusic;\n    \n    MusMeasureAligner m_measureAligner;\n    \n    /**\n     * @name The measure barlines (left and right) used when drawing\n     */\n    ///@{\n    MusBarline m_leftBarline;\n    MusBarline m_rightBarline;\n    ///@}\n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musbboxdc.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musbboxdc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <math.h>\n\n//----------------------------------------------------------------------------\n\n#include \"musdef.h\"\n#include \"musleipzigbbox.h\"\n#include \"musrc.h\"\n\nextern \"C\" {\nstatic inline double DegToRad(double deg) { return (deg * M_PI) / 180.0; }\nstatic inline double RadToDeg(double deg) { return (deg * 180.0) / M_PI; }\n}\n\n//----------------------------------------------------------------------------\n// MusBBoxDC\n//----------------------------------------------------------------------------\n\n\nMusBBoxDC::MusBBoxDC ( MusRC *rc, int width, int height):\n    MusDC()\n{\t\n    m_correctMusicAscent = false; // do not correct the ascent in the Leipzig font    \n    \n    m_rc = rc;\n    m_width = width;\n    m_height = height;\n    \n    m_userScaleX = 1.0;\n    m_userScaleY = 1.0;\n    m_originX = 0;\n    m_originY = 0;\n    \n    SetBrush( AxBLACK, AxSOLID );\n    SetPen( AxBLACK, 1, AxSOLID );\n}\n\n\nMusBBoxDC::~MusBBoxDC ( )\n{\n}\n\nvoid MusBBoxDC::StartGraphic( MusDocObject *object, std::string gClass, std::string gId )\n{\n    // add object\n    object->ResetBB();\n    m_objects.push_back( object );\n}\n      \nvoid MusBBoxDC::EndGraphic(MusDocObject *object, MusRC *rc ) \n{\n    // detach the object\n    assert( m_objects.back() == object );\n    m_objects.pop_back();\n}\n\nvoid MusBBoxDC::StartPage( )\n{\n}\n \nvoid MusBBoxDC::EndPage() \n{\n}\n\nvoid MusBBoxDC::SetBrush( int colour, int style )\n{\n}\n        \nvoid MusBBoxDC::SetBackground( int colour, int style )\n{\n    // nothing to do, we do not handle Background\n}\n        \nvoid MusBBoxDC::SetBackgroundMode( int mode )\n{\n    // nothing to do, we do not handle Background Mode\n}\n        \nvoid MusBBoxDC::SetPen( int colour, int width, int style )\n{\n    m_penWidth = width;\n}\n        \nvoid MusBBoxDC::SetFont( MusFontInfo *font_info )\n{\n    m_font = *font_info;\n}\n            \n\nvoid MusBBoxDC::SetTextForeground( int colour )\n{\n}\n        \nvoid MusBBoxDC::SetTextBackground( int colour )\n{\n    // nothing to do, we do not handle Text Background Mode\n}\n       \nvoid MusBBoxDC::ResetBrush( )\n{\n}\n        \nvoid MusBBoxDC::ResetPen( )\n{\n    SetPen( AxBLACK, 1, AxSOLID );\n} \n\nvoid MusBBoxDC::SetLogicalOrigin( int x, int y ) \n{\n    //// no idea how to handle this with the BB\n    m_originX = -x;\n    m_originY = -y;\n} \n\nvoid MusBBoxDC::SetUserScale( double xScale, double yScale ) \n{\n    //// no idea how to handle this with the BB\n    m_userScaleX = xScale;\n    m_userScaleY = yScale;\n}       \n\nvoid MusBBoxDC::GetTextExtent( const std::string& string, int *w, int *h )\n{\n    int x, y, partial_w, partial_h;\n    \n    *w = 0;\n    *h = 0;\n    \n    for (unsigned int i = 0; i < string.length(); i++) {\n        \n        MusLeipzigBBox::GetCharBounds(string.c_str()[i], &x, &y, &partial_w, &partial_h);\n        \n        partial_w *= ((m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM));\n        partial_h *= ((m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM));\n        \n        *w += partial_w;\n        *h += partial_h;\n    }\n    \n}\n       \n\nMusPoint MusBBoxDC::GetLogicalOrigin( ) \n{\n    return MusPoint( m_originX, m_originY );\n}\n\n// claculated better\nvoid MusBBoxDC::DrawComplexBezierPath(int x, int y, int bezier1_coord[6], int bezier2_coord[6])\n{\n    int vals[4];\n    FindPointsForBounds( MusPoint(x, y), \n                        MusPoint(bezier1_coord[0], bezier1_coord[1]), \n                        MusPoint(bezier1_coord[2], bezier1_coord[3]),\n                        MusPoint(bezier1_coord[4], bezier1_coord[5]),\n                        vals);\n    \n    UpdateBB(vals[0], vals[1], vals[2], vals[3]);\n}\n\nvoid MusBBoxDC::DrawCircle(int x, int y, int radius)\n{\n    DrawEllipse(x - radius, y - radius, 2*radius, 2*radius);\n}\n\n\nvoid MusBBoxDC::DrawEllipse(int x, int y, int width, int height)\n{\n    UpdateBB(x, y, x + width, y + height);\n}\n\n        \nvoid MusBBoxDC::DrawEllipticArc(int x, int y, int width, int height, double start, double end)\n{\n    /*\n    Draws an arc of an ellipse. The current pen is used for drawing the arc\n    and the current brush is used for drawing the pie. This function is\n    currently only available for X window and PostScript device contexts.\n\n    x and y specify the x and y coordinates of the upper-left corner of the\n    rectangle that contains the ellipse.\n\n    width and height specify the width and height of the rectangle that\n    contains the ellipse.\n\n    start and end specify the start and end of the arc relative to the\n    three-o'clock position from the center of the rectangle. Angles are\n    specified in degrees (360 is a complete circle). Positive values mean\n    counter-clockwise motion. If start is equal to end, a complete ellipse\n    will be drawn. */\n\n    //known bug: SVG draws with the current pen along the radii, but this does not happen in wxMSW\n\n    std::string s ;\n    //radius\n    double rx = width / 2 ;\n    double ry = height / 2 ;\n    // center\n    double xc = x + rx ;\n    double yc = y + ry ;\n\n    double xs, ys, xe, ye ;\n    xs = xc + rx * cos (DegToRad(start)) ;\n    xe = xc + rx * cos (DegToRad(end)) ;\n    ys = yc - ry * sin (DegToRad(start)) ;\n    ye = yc - ry * sin (DegToRad(end)) ;\n\n    ///now same as circle arc...\n\n    double theta1 = atan2(ys-yc, xs-xc);\n    double theta2 = atan2(ye-yc, xe-xc);\n\n    int fArc  ;                  // flag for large or small arc 0 means less than 180 degrees\n    if ( (theta2 - theta1) > 0 ) fArc = 1; else fArc = 0 ;\n\n    int fSweep ;\n    if ( fabs(theta2 - theta1) > M_PI) fSweep = 1; else fSweep = 0 ;\n\n    //WriteLine( Mus::StringFormat(\"<path d=\\\"M%d %d A%d %d 0.0 %d %d  %d %d \\\" />\",\n    //    int(xs), int(ys), int(rx), int(ry),\n    //    fArc, fSweep, int(xe), int(ye) ) );\n    \n    int penWidth = m_penWidth;\n    if ( penWidth % 2 ) {\n        penWidth += 1;\n    }\n    // needs to be fixed - for now uses the entire rectangle\n    UpdateBB( x - penWidth / 2, y - penWidth / 2, x + width + penWidth / 2, y + height + penWidth / 2);\n}\n  \n              \nvoid MusBBoxDC::DrawLine(int x1, int y1, int x2, int y2)\n{\n    if ( x1 > x2 ) {\n        int tmp = x1;\n        x1 = x2;\n        x2 = tmp;\n    }\n    if ( y1 > y2 ) {\n        int tmp = y1;\n        y1 = y2;\n        y2 = tmp;\n    }\n    int penWidth = m_penWidth;\n    if ( penWidth % 2 ) {\n        penWidth += 1;\n    }\n    \n    UpdateBB( x1 - penWidth / 2, y1 - penWidth / 2, x2 + penWidth / 2, y2 + penWidth / 2);\n}\n \n               \nvoid MusBBoxDC::DrawPolygon(int n, MusPoint points[], int xoffset, int yoffset, int fill_style)\n{\n    if ( n == 0 ) {\n        return;\n    }\n    int x1 = points[0].x + xoffset;\n    int x2 = x1;\n    int y1 = points[0].y + yoffset;\n    int y2 = y1;\n    \n    for (int i = 0; i < n;  i++)\n    {\n        if ( points[i].x + xoffset < x1 ) x1 = points[i].x + xoffset;\n        if ( points[i].x + xoffset > x2 ) x2 = points[i].x + xoffset;\n        if ( points[i].y + yoffset < y1 ) y1 = points[i].y + yoffset;\n        if ( points[i].y + yoffset > y2 ) y2 = points[i].y + yoffset;\n\n    }\n    UpdateBB(x1, y1, x2, y2);\n}\n    \n            \nvoid MusBBoxDC::DrawRectangle(int x, int y, int width, int height)\n{\n    DrawRoundedRectangle( x, y, width, height, 0 );\n}\n\n\nvoid MusBBoxDC::DrawRoundedRectangle(int x, int y, int width, int height, double radius)\n{\n    // avoid negative heights or widths\n    if ( height < 0 ) {\n        height = -height;\n        y -= height;\n    }\n    if ( width < 0 ) {\n        width = -width;\n        x -= width;\n    }\n    int penWidth = m_penWidth;\n    if ( penWidth % 2 ) {\n        penWidth += 1;\n    }\n    \n    UpdateBB( x - penWidth / 2, y - m_penWidth / 2, x + width + m_penWidth / 2, y + height + m_penWidth / 2);\n}\n\n        \nvoid MusBBoxDC::DrawText(const std::string& text, int x, int y)\n{\n    DrawMusicText( text, x, y);\n}\n\n\n\nvoid MusBBoxDC::DrawRotatedText(const std::string& text, int x, int y, double angle)\n{\n    //known bug; if the font is drawn in a scaled DC, it will not behave exactly as wxMSW\n\n    std::string s;\n\n    // calculate bounding box\n    int w, h, desc;\n    //DoGetTextExtent(sText, &w, &h, &desc);\n    w = h = desc = 0;\n\n    //double rad = DegToRad(angle);\n\n    \n    //if (m_backgroundMode == AxSOLID)\n    {\n        //WriteLine(\"/*- MusSVGFileDC::DrawRotatedText - Backgound not implemented */\") ;\n    }\n}\n\n\nvoid MusBBoxDC::DrawMusicText(const std::string& text, int x, int y)\n{  \n    \n    int g_x, g_y, g_w, g_h;\n    int lastCharWidth = 0;\n    \n    for (unsigned int i = 0; i < text.length(); i++) {\n        unsigned char c = (unsigned char)text[i];\n        \n        MusLeipzigBBox::GetCharBounds(c, &g_x, &g_y, &g_w, &g_h);\n    \n        int x_off = x + (g_x * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) ) - 2;\n        // because we are in the rendering context, y position are already flipped\n        int y_off = y - (g_y * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) ) + 2;\n        // the +/- 2 is to compesate a couple pixels down the figure (rounding error?)\n         \n        UpdateBB(x_off, y_off, \n                  x_off + (g_w * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) ),\n        // idem, y position are flipped\n                  y_off - (g_h * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) ));\n        \n        lastCharWidth = (g_w * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)));\n        x += lastCharWidth; // move x to next char\n     \n    }\n    \n    /*\n    int x_off = x + (bbox->m_bBox[glyph].m_x * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) );\n    // because we are in the rendering context, y position are already flipped\n    int y_off = y - (bbox->m_bBox[glyph].m_y * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) );\n    \n    UpdateBB(x_off, y_off, \n        x_off + (bbox->m_bBox[glyph].m_width * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) ),\n        // idem, y position are flipped\n        y_off - (bbox->m_bBox[glyph].m_height * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) ));\n    */\n}\n\n\nvoid MusBBoxDC::DrawSpline(int n, MusPoint points[])\n{\n    //m_dc->DrawSpline( n, (wxPoint*)points );\n}\n\nvoid MusBBoxDC::UpdateBB(int x1, int y1, int x2, int y2) \n{\n    /*\n    MusDocObject *first = &m_objects[m_objects.Count() - 1];\n    \n    first->UpdateOwnBB(x1, y1, x2, y2);\n    \n    // Stretch the content BB of the other objects\n    // Check that we are not the only elem in the list\n    if (m_objects.Count() > 1) {\n        \n        // The second element in the list stretches in base of the new BBox of the first\n        m_objects[m_objects.Count() - 2].UpdateContentBB(first->m_selfBB_x1, first->m_selfBB_y1, first->m_selfBB_x2, first->m_selfBB_y2);\n        \n        // All the next ones, stretch using contentBB\n        for (int i = m_objects.Count() - 3; i >= 0; i--) {\n            MusDocObject *precedent = &m_objects[i + 1];\n            m_objects[i].UpdateContentBB(precedent->m_contentBB_x1, precedent->m_contentBB_y1, precedent->m_contentBB_x2, precedent->m_contentBB_y2);\n        }\n    }\n    */\n    \n    // simpler version \n    \n    // the array should not be empty\n    assert( !m_objects.empty() ); // Array cannot be empty\n    \n    \n    // we need to store logical coordinates in the objects, we need to convert them back (this is why we need a MusRC object)\n    ((MusDocObject*)m_objects.back())->UpdateSelfBB( m_rc->ToLogicalX(x1), m_rc->ToLogicalY(y1), m_rc->ToLogicalX(x2), m_rc->ToLogicalY(y2) );\n    \n    int i;\n    for (i = 0; i < (int)m_objects.size(); i++) {\n        ((MusDocObject*)m_objects[i])->UpdateContentBB( m_rc->ToLogicalX(x1), m_rc->ToLogicalY(y1), m_rc->ToLogicalX(x2), m_rc->ToLogicalY(y2) );\n    }\n}\n\n// Ok, shame on me, found off the internet and modified, but for now it works\nvoid MusBBoxDC::FindPointsForBounds(MusPoint P0, MusPoint P1, MusPoint P2, MusPoint P3, int *ret)\n{\n    \n    int A = P3.x - 3 * P2.x + 3 * P1.x - P0.x;\n    int B = 3 * P2.x - 6 * P1.x + 3 * P0.x;\n    int C = 3 * P1.x - 3 * P0.x;\n    int D = P0.x;\n    \n    int E = P3.y - 3 * P2.y + 3 * P1.y - P0.y;\n    int F = 3 * P2.y - 6 * P1.y + 3 * P0.y;\n    int G = 3 * P1.y - 3 * P0.y;\n    int H = P0.y;\n    \n    float x, y;\n    float xMin = 0xFFFF;\n    float yMin = 0xFFFF;\n    float xMax = 0;\n    float yMax = 0;\n    \n    for (float t = 0.0f; t <= 1.0f; t += 0.01f)\n    {\n        x = A * t * t * t + B * t * t + C * t + D;\n        if (x < xMin)\n            xMin = x;\n        if (x > xMax)\n            xMax = x;\n        y = E * t * t * t + F * t * t + G * t + H;\n        if (y < yMin)\n            yMin = y;\n        if (y > yMax)\n            yMax = y; \n    }\n    \n    ret[0] = (int)xMin;\n    ret[1] = (int)yMin;\n    \n    ret[2] = (int)xMax;\n    ret[3] = (int)yMax;\n}","/////////////////////////////////////////////////////////////////////////////\n// Name:        musdc.h \n// Author:      Laurent Pugin\n// Created:     2010\n// Copyright (c) Authors and others. All rights reserved.   \n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_DC_H__\n#define __MUS_DC_H__\n\n#include <string>\n\n#define AxWHITE  255 << 16 | 255 << 8 | 255\n#define AxBLACK 0\n#define AxRED  255 << 16\n#define AxBLUE 255\n#define AxGREEN  255 << 8\n#define AxCYAN 255 << 8 | 255\n#define AxLIGHT_GREY 127 << 16 | 127 << 8 | 127\n\n/*  Polygon filling mode */\nenum\n{\n    AxODDEVEN_RULE = 1,\n    AxWINDING_RULE\n};\n\nenum\n{\n    /*  Pen styles */\n    AxSOLID      =   100,\n    AxDOT,\n    AxLONG_DASH,\n    AxSHORT_DASH,\n    AxDOT_DASH,\n    AxUSER_DASH,\n    AxTRANSPARENT\n};\n\nclass MusPoint;\nclass MusRect;\nclass MusFontInfo;\nclass MusDocObject;\nclass MusRC;\n\n// ---------------------------------------------------------------------------\n// MusDC\n// ---------------------------------------------------------------------------\n\n/**\n * This class is an abstract device context.\n * It enables different types of concrete classes to be implemented.\n * For example:\n *  MusWxDC - a wrapper to wxDCs;\n *  MusSvgDC - a non-gui file DC;\n *  MusCairoDC - a wrapper to a Cairo surface;\n * The class uses int-based colour encoding (instead of wxColour in wxDC).\n * It uses MusFontInfo (instead of wxFont in wxDC).\n*/\n\nclass MusDC\n{\npublic:\n\n    MusDC () { m_correctMusicAscent = true; };\n    virtual ~MusDC() {};\n    \n    // Setters\n    \n    virtual void SetBrush( int colour, int style = AxSOLID ) = 0;\n    \n    virtual void SetBackground( int colour, int style = AxSOLID ) = 0;\n    \n    virtual void SetBackgroundImage( void *image, double opacity = 1.0 ) = 0;\n    \n    virtual void SetBackgroundMode( int mode ) = 0;\n    \n    virtual void SetPen( int colour, int width = 1, int style = AxSOLID ) = 0;\n    \n    virtual void SetFont( MusFontInfo *font_info ) = 0;\n\n    virtual void SetTextForeground( int colour ) = 0;\n    \n    virtual void SetTextBackground( int colour ) = 0;\n    \n    virtual void ResetBrush( ) = 0;\n    \n    virtual void ResetPen( ) = 0;\n    \n    virtual void SetLogicalOrigin( int x, int y ) = 0;\n    \n    // Getters \n    \n    virtual void GetTextExtent( const std::string& string, int *w, int *h ) = 0;\n    \n    virtual MusPoint GetLogicalOrigin( ) = 0;\n    \n    virtual bool CorrectMusicAscent( ) { return m_correctMusicAscent; };\n\n    // Drawing methods\n    \n    virtual void DrawComplexBezierPath(int x, int y, int bezier1_coord[6], int bezier2_coord[6]) = 0;\n    \n    virtual void DrawCircle(int x, int y, int radius) = 0;\n    \n    virtual void DrawEllipse(int x, int y, int width, int height) = 0;\n    \n    virtual void DrawEllipticArc(int x, int y, int width, int height, double start, double end) = 0;\n    \n    virtual void DrawLine(int x1, int y1, int x2, int y2) = 0;\n    \n    virtual void DrawPolygon(int n, MusPoint points[], int xoffset = 0, int yoffset = 0, int fill_style = AxODDEVEN_RULE) = 0;\n    \n    virtual void DrawRectangle(int x, int y, int width, int height) = 0;\n    \n    virtual void DrawRotatedText(const std::string& text, int x, int y, double angle) = 0;\n    \n    virtual void DrawRoundedRectangle(int x, int y, int width, int height, double radius) = 0;\n    \n    virtual void DrawText(const std::string& text, int x, int y) = 0;\n    \n    virtual void DrawMusicText(const std::string& text, int x, int y) = 0;\n    \n    virtual void DrawSpline(int n, MusPoint points[]) = 0;\n    \n    virtual void DrawBackgroundImage( int x = 0, int y = 0 ) = 0;\n    \n    // Method for starting and ending a graphic - for example for grouping shapes in <g></g> in SVG\n    \n    virtual void StartGraphic( MusDocObject *object, std::string gClass, std::string gId ) = 0;\n    \n    virtual void EndGraphic( MusDocObject *object, MusRC *rc  ) = 0;\n    \n    virtual void StartPage( ) = 0;\n    \n    virtual void EndPage( ) = 0;\n    \n    // Colour conversion method\n    \n    static int RGB2Int( char red, char green, char blue ) { return (red << 16 | green << 8 | blue); };\n\n    \nprotected:\n    \n    bool m_correctMusicAscent; // specify if the ascent has to be correct when rendering the Leipzig font (true wxDC, false SVG)\n};\n\n// ---------------------------------------------------------------------------\n// MusFontInfo\n// ---------------------------------------------------------------------------\n\n/**\n * This class is store font properties.\n * It is very similar to wxNativeFontInfo, but we need it for non-gui AxDCs \n*/\n\nclass MusFontInfo\n{\npublic:\n    MusFontInfo () \n    {\n        pointSize = 0;\n        family = 0; //was wxFONTFAMILY_DEFAULT;\n        style = 0; //was wxFONTSTYLE_NORMAL;\n        weight = 0; //was wxFONTWEIGHT_NORMAL;\n        underlined = false;\n        faceName.clear();\n        encoding = 0; //was wxFONTENCODING_DEFAULT;\n    }\n    virtual ~MusFontInfo() {};\n    \n        // accessors and modifiers for the font elements\n    int GetPointSize() { return pointSize; }\n    int GetStyle() { return style; };\n    int GetWeight() { return weight; }\n    bool GetUnderlined() { return underlined; }\n    std::string GetFaceName() { return faceName; }\n    int GetFamily() { return family; }\n    int GetEncoding() { return encoding; }\n\n    void SetPointSize(int pointSize_) { pointSize = pointSize_; }\n    void SetStyle(int style_) { style = style_; }\n    void SetWeight(int weight_) { weight = weight_; }\n    void SetUnderlined(bool underlined_) { underlined = underlined_; }\n    void SetFaceName(std::string& faceName_) { faceName = faceName_; }\n    void SetFamily(int family_) { family = family_; }\n    void SetEncoding(int encoding_) { encoding = encoding_; }\n    \n    // in axdc.cpp\n    bool FromString(const std::string& s);\n    std::string ToString() const;\n    \n    int           pointSize;\n    int           family;\n    int           style;\n    int           weight;\n    bool          underlined;\n    std::string   faceName;\n    int           encoding;\n};\n\n\n\n// ---------------------------------------------------------------------------\n// MusPoint\n// ---------------------------------------------------------------------------\n\n/**\n * This class is similar to wxPoint.\n * It is required for non-gui application because wxPoint in not available in\n * wxBase. All operations that use wxSize do not exist.\n*/\n\nclass MusPoint\n{\npublic:\n    int x, y;\n\n    MusPoint() : x(0), y(0) { }\n    MusPoint(int xx, int yy) : x(xx), y(yy) { }\n\n    // no copy ctor or assignment operator - the defaults are ok\n\n    // comparison\n    bool operator==(const MusPoint& p) const { return x == p.x && y == p.y; }\n    bool operator!=(const MusPoint& p) const { return !(*this == p); }\n\n    // arithmetic operations (component wise)\n    MusPoint operator+(const MusPoint& p) const { return MusPoint(x + p.x, y + p.y); }\n    MusPoint operator-(const MusPoint& p) const { return MusPoint(x - p.x, y - p.y); }\n\n    MusPoint& operator+=(const MusPoint& p) { x += p.x; y += p.y; return *this; }\n    MusPoint& operator-=(const MusPoint& p) { x -= p.x; y -= p.y; return *this; }\n\n    //MusPoint& operator+=(const wxSize& s) { x += s.GetWidth(); y += s.GetHeight(); return *this; }\n    //MusPoint& operator-=(const wxSize& s) { x -= s.GetWidth(); y -= s.GetHeight(); return *this; }\n\n    //MusPoint operator+(const wxSize& s) const { return MusPoint(x + s.GetWidth(), y + s.GetHeight()); }\n    //MusPoint operator-(const wxSize& s) const { return MusPoint(x - s.GetWidth(), y - s.GetHeight()); }\n\n    MusPoint operator-() const { return MusPoint(-x, -y); }\n};\n\n\n\n// ---------------------------------------------------------------------------\n// MusRect\n// ---------------------------------------------------------------------------\n\n/**\n * This class is similar to wxRect.\n * It is required for non-gui application because wxPoint in not available in\n * wxBase.\n * All operations that use wxSize do not exists.\n * All operations on rectangles (inflate, etc.) do not exists.\n*/\n\nclass MusRect\n{\npublic:\n    MusRect()\n        : x(0), y(0), width(0), height(0)\n        { }\n    MusRect(int xx, int yy, int ww, int hh)\n        : x(xx), y(yy), width(ww), height(hh)\n        { }\n    MusRect(const MusPoint& topLeft, const MusPoint& bottomRight);\n    //MusRect(const MusPoint& pt, const wxSize& size)\n    //    : x(pt.x), y(pt.y), width(size.x), height(size.y)\n    //    { }\n    //MusRect(const wxSize& size)\n    //    : x(0), y(0), width(size.x), height(size.y)\n    //    { }\n\n    // default copy ctor and assignment operators ok\n\n    int GetX() const { return x; }\n    void SetX(int xx) { x = xx; }\n\n    int GetY() const { return y; }\n    void SetY(int yy) { y = yy; }\n\n    int GetWidth() const { return width; }\n    void SetWidth(int w) { width = w; }\n\n    int GetHeight() const { return height; }\n    void SetHeight(int h) { height = h; }\n\n    MusPoint GetPosition() const { return MusPoint(x, y); }\n    void SetPosition( const MusPoint &p ) { x = p.x; y = p.y; }\n\n    //wxSize GetSize() const { return wxSize(width, height); }\n    //void SetSize( const wxSize &s ) { width = s.GetWidth(); height = s.GetHeight(); }\n\n    bool IsEmpty() const { return (width <= 0) || (height <= 0); }\n\n    int GetLeft()   const { return x; }\n    int GetTop()    const { return y; }\n    int GetBottom() const { return y + height - 1; }\n    int GetRight()  const { return x + width - 1; }\n\n    void SetLeft(int left) { x = left; }\n    void SetRight(int right) { width = right - x + 1; }\n    void SetTop(int top) { y = top; }\n    void SetBottom(int bottom) { height = bottom - y + 1; }\n\n    MusPoint GetTopLeft() const { return GetPosition(); }\n    MusPoint GetLeftTop() const { return GetTopLeft(); }\n    void SetTopLeft(const MusPoint &p) { SetPosition(p); }\n    void SetLeftTop(const MusPoint &p) { SetTopLeft(p); }\n\n    MusPoint GetBottomRight() const { return MusPoint(GetRight(), GetBottom()); }\n    MusPoint GetRightBottom() const { return GetBottomRight(); }\n    void SetBottomRight(const MusPoint &p) { SetRight(p.x); SetBottom(p.y); }\n    void SetRightBottom(const MusPoint &p) { SetBottomRight(p); }\n\n    MusPoint GetTopRight() const { return MusPoint(GetRight(), GetTop()); }\n    MusPoint GetRightTop() const { return GetTopRight(); }\n    void SetTopRight(const MusPoint &p) { SetRight(p.x); SetTop(p.y); }\n    void SetRightTop(const MusPoint &p) { SetTopLeft(p); }\n\n    MusPoint GetBottomLeft() const { return MusPoint(GetLeft(), GetBottom()); }\n    MusPoint GetLeftBottom() const { return GetBottomLeft(); }\n    void SetBottomLeft(const MusPoint &p) { SetLeft(p.x); SetBottom(p.y); }\n    void SetLeftBottom(const MusPoint &p) { SetBottomLeft(p); }\n\npublic:\n    int x, y, width, height;\n};\n\n#endif // __AX_DC_H__\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musbboxdc.h \n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.   \n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_BBOX_DC_H__\n#define __MUS_BBOX_DC_H__\n\n#include \"musdc.h\"\n#include \"musobject.h\"\n\n//----------------------------------------------------------------------------\n// MusBBoxDC\n//----------------------------------------------------------------------------\n\n/** \n * This class calculates the bouding box of the object that are drawn.\n * It can be used when doing the layout of the object in order to manage object spacing.\n * The drawing primitives do not draw anything but update the bounding box values of the \n * layout objects currently drawn. The layout objects store their own bounding box and a\n * bounding box of their content. The own bouding box is updated only for the object being\n * drawn (the top one on the stack). The content bounding box is updated for all objects\n * the stack\n */\nclass MusBBoxDC: public MusDC\n{\npublic:\n\n    MusBBoxDC ( MusRC *rc, int width, int height );\n    virtual ~MusBBoxDC();\n    \n    // Setters\n    \n    virtual void SetBrush( int colour, int style = AxSOLID );\n    \n    virtual void SetBackground( int colour, int style = AxSOLID );\n    \n    virtual void SetBackgroundImage( void *image, double opacity = 1.0 ) {};\n    \n    virtual void SetBackgroundMode( int mode );\n    \n    virtual void SetPen( int colour, int width = 1, int style = AxSOLID );\n    \n    virtual void SetFont( MusFontInfo *font_info );\n        \n    virtual void SetTextForeground( int colour );\n    \n    virtual void SetTextBackground( int colour );\n    \n    virtual void ResetBrush( );\n    \n    virtual void ResetPen( );\n    \n    virtual void SetLogicalOrigin( int x, int y );\n    \n    virtual void SetUserScale( double xScale, double yScale );\n    \n    // Getters\n    \n    virtual void GetTextExtent( const std::string& string, int *w, int *h );\n    \n    virtual MusPoint GetLogicalOrigin( );\n\n    // Drawing methods\n        \n    virtual void DrawComplexBezierPath(int x, int y, int bezier1_coord[6], int bezier2_coord[6]);\n    \n    virtual void DrawCircle(int x, int y, int radius);\n    \n    virtual void DrawEllipse(int x, int y, int width, int height);\n    \n    virtual void DrawEllipticArc(int x, int y, int width, int height, double start, double end);\n    \n    virtual void DrawLine(int x1, int y1, int x2, int y2);\n    \n    virtual void DrawPolygon(int n, MusPoint points[], int xoffset, int yoffset, int fill_style = AxODDEVEN_RULE);\n    \n    virtual void DrawRectangle(int x, int y, int width, int height);\n    \n    virtual void DrawRotatedText(const std::string& text, int x, int y, double angle);\n    \n    virtual void DrawRoundedRectangle(int x, int y, int width, int height, double radius);\n    \n    virtual void DrawText(const std::string& text, int x, int y);\n    \n    virtual void DrawMusicText(const std::string& text, int x, int y);\n    \n    virtual void DrawSpline(int n, MusPoint points[]);\n    \n    virtual void DrawBackgroundImage( int x = 0, int y = 0 ) {};\n    \n    // \n    virtual void StartGraphic( MusDocObject *object, std::string gClass, std::string gId );\n    \n    virtual void EndGraphic(MusDocObject *object, MusRC *rc );\n    \n    virtual void StartPage();\n    \n    virtual void EndPage();\n    \n    \nprivate:\n    int m_width, m_height;\n    int m_originX, m_originY;\n    double m_userScaleX, m_userScaleY;\n    \n    /**\n     * The array containing the object for which the bounding box needs to be updated\n     */ \n    ArrayOfMusObjects m_objects;\n    \n    MusFontInfo m_font;\n    \n    /**\n     * The rendering context we are calling from - used to flip back the Y coordinates\n     */\n    MusRC *m_rc;\n   \n    //\n    int m_penWidth;\n    \n    void UpdateBB(int x1, int y1, int x2, int y2);\n    \n    void FindPointsForBounds(MusPoint P0, MusPoint P1, MusPoint P2, MusPoint P3, int *ret);\n};\n\n#endif // __MUS_BBOX_DC_H__\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musbeam.cpp\n// Author:      Rodolfo Zitellini\n// Created:     26/06/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"mus.h\"\n#include \"musbeam.h\"\n\n//----------------------------------------------------------------------------\n// MusBeam\n//----------------------------------------------------------------------------\n\nMusBeam::MusBeam():\n    MusLayerElement(\"beam-\"), MusObjectListInterface()\n{\n}\n\n\nMusBeam::~MusBeam()\n{\n}\n\nvoid MusBeam::AddElement(MusLayerElement *element) {\n   \n    element->SetParent( this );\n    m_children.push_back(element);\n    Modify();\n}\n\nvoid MusBeam::FilterList()\n{\n    // We want to keep only notes and rest\n    // Eventually, we also need to filter out grace notes properly (e.g., with sub-beams)\n    ListOfMusObjects::iterator iter = m_list.begin();\n    \n    while ( iter != m_list.end()) {\n        MusLayerElement *currentElement = dynamic_cast<MusLayerElement*>(*iter);\n        if ( currentElement && !currentElement->HasDurationInterface() )\n        {\n            //Mus::LogDebug(\"KILLED!!! %s\", currentElement->MusClassName().c_str() );\n            iter = m_list.erase( iter );\n        } else {\n            iter++;\n        }\n    }\n    \n}\n\n\n","// -*- C++ -*-\n//===---------------------------- list ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LIST\n#define _LIBCPP_LIST\n\n/*\n    list synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Alloc = allocator<T> >\nclass list\n{\npublic:\n\n    // types:\n    typedef T value_type;\n    typedef Alloc allocator_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef implementation-defined size_type;\n    typedef implementation-defined difference_type;\n    typedef reverse_iterator<iterator> reverse_iterator;\n    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n\n    list()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit list(const allocator_type& a);\n    explicit list(size_type n);\n    explicit list(size_type n, const allocator_type& a); // C++14\n    list(size_type n, const value_type& value);\n    list(size_type n, const value_type& value, const allocator_type& a);\n    template <class Iter>\n        list(Iter first, Iter last);\n    template <class Iter>\n        list(Iter first, Iter last, const allocator_type& a);\n    list(const list& x);\n    list(const list&, const allocator_type& a);\n    list(list&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    list(list&&, const allocator_type& a);\n    list(initializer_list<value_type>);\n    list(initializer_list<value_type>, const allocator_type& a);\n\n    ~list();\n\n    list& operator=(const list& x);\n    list& operator=(list&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    list& operator=(initializer_list<value_type>);\n    template <class Iter>\n        void assign(Iter first, Iter last);\n    void assign(size_type n, const value_type& t);\n    void assign(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator end() noexcept;\n    const_iterator end() const noexcept;\n    reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    bool empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    template <class... Args>\n        void emplace_front(Args&&... args);\n    void pop_front();\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n    void push_front(const value_type& x);\n    void push_front(value_type&& x);\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class Iter>\n        iterator insert(const_iterator position, Iter first, Iter last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator position, const_iterator last);\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(list&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void clear() noexcept;\n\n    void splice(const_iterator position, list& x);\n    void splice(const_iterator position, list&& x);\n    void splice(const_iterator position, list& x, const_iterator i);\n    void splice(const_iterator position, list&& x, const_iterator i);\n    void splice(const_iterator position, list& x, const_iterator first,\n                                                  const_iterator last);\n    void splice(const_iterator position, list&& x, const_iterator first,\n                                                  const_iterator last);\n\n    void remove(const value_type& value);\n    template <class Pred> void remove_if(Pred pred);\n    void unique();\n    template <class BinaryPredicate>\n        void unique(BinaryPredicate binary_pred);\n    void merge(list& x);\n    void merge(list&& x);\n    template <class Compare>\n        void merge(list& x, Compare comp);\n    template <class Compare>\n        void merge(list&& x, Compare comp);\n    void sort();\n    template <class Compare>\n        void sort(Compare comp);\n    void reverse() noexcept;\n};\n\ntemplate <class T, class Alloc>\n    bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator< (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator!=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator> (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator>=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator<=(const list<T,Alloc>& x, const list<T,Alloc>& y);\n\ntemplate <class T, class Alloc>\n    void swap(list<T,Alloc>& x, list<T,Alloc>& y)\n         noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n\n#include <memory>\n#include <limits>\n#include <initializer_list>\n#include <iterator>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#ifdef _LIBCPP_DEBUG\n#   include <__debug>\n#else\n#   define _LIBCPP_ASSERT(x, m) ((void)0)\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _VoidPtr> struct __list_node;\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node_base\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other pointer;\n#endif\n\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node_base> __base_pointer;\n#else\n        rebind<__list_node_base>::other __base_pointer;\n#endif\n\n    pointer __prev_;\n    pointer __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_node_base()\n        : __prev_(static_cast<pointer>(pointer_traits<__base_pointer>::pointer_to(*this))),\n          __next_(static_cast<pointer>(pointer_traits<__base_pointer>::pointer_to(*this)))\n          {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node\n    : public __list_node_base<_Tp, _VoidPtr>\n{\n    _Tp __value_;\n};\n\ntemplate <class _Tp, class _Alloc> class _LIBCPP_TYPE_VIS_ONLY list;\ntemplate <class _Tp, class _Alloc> class __list_imp;\ntemplate <class _Tp, class _VoidPtr> class _LIBCPP_TYPE_VIS_ONLY __list_const_iterator;\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\n    template<class, class> friend class __list_const_iterator;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef value_type&                      reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator(const __list_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator=(const __list_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_iterator& __x, const __list_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_const_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__p);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_const_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator=(const __list_const_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::const_iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _Alloc>\nclass __list_imp\n{\n    __list_imp(const __list_imp&);\n    __list_imp& operator=(const __list_imp&);\nprotected:\n    typedef _Tp                                                     value_type;\n    typedef _Alloc                                                  allocator_type;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n    typedef typename __alloc_traits::size_type                      size_type;\n    typedef typename __alloc_traits::void_pointer                   __void_pointer;\n    typedef __list_iterator<value_type, __void_pointer>             iterator;\n    typedef __list_const_iterator<value_type, __void_pointer>       const_iterator;\n    typedef __list_node_base<value_type, __void_pointer>            __node_base;\n    typedef __list_node<value_type, __void_pointer>                 __node;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node>\n#else\n                rebind_alloc<__node>::other\n#endif\n                                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>                       __node_alloc_traits;\n    typedef typename __node_alloc_traits::pointer                    __node_pointer;\n    typedef typename __node_alloc_traits::pointer                    __node_const_pointer;\n    typedef typename __alloc_traits::pointer                         pointer;\n    typedef typename __alloc_traits::const_pointer                   const_pointer;\n    typedef typename __alloc_traits::difference_type                 difference_type;\n\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node_base>\n#else\n                rebind_alloc<__node_base>::other\n#endif\n                                                                     __node_base_allocator;\n    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;\n\n    __node_base __end_;\n    __compressed_pair<size_type, __node_allocator> __size_alloc_;\n\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& __sz() _NOEXCEPT {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __sz() const _NOEXCEPT\n        {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT\n          {return __size_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __size_alloc_.second();}\n\n    static void __unlink_nodes(__node_pointer __f, __node_pointer __l) _NOEXCEPT;\n\n    __list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value);\n    __list_imp(const allocator_type& __a);\n    ~__list_imp();\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __sz() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__end_.__next_, this);\n#else\n        return iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const  _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(__end_.__next_, this);\n#else\n        return const_iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__node_pointer>(\n                pointer_traits<__node_base_pointer>::pointer_to(__end_)), this);\n#else\n        return iterator(static_cast<__node_pointer>(\n                      pointer_traits<__node_base_pointer>::pointer_to(__end_)));\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))), this);\n#else\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))));\n#endif\n    }\n\n    void swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c)\n        _NOEXCEPT_(\n            !__node_alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, true_type)\n        {\n            if (__node_alloc() != __c.__node_alloc())\n                clear();\n            __node_alloc() = __c.__node_alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {\n            __node_alloc() = _VSTD::move(__c.__node_alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, false_type)\n        _NOEXCEPT\n        {}\n};\n\n// Unlink nodes [__f, __l]\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__list_imp<_Tp, _Alloc>::__unlink_nodes(__node_pointer __f, __node_pointer __l)\n    _NOEXCEPT\n{\n    __f->__prev_->__next_ = __l->__next_;\n    __l->__next_->__prev_ = __f->__prev_;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    : __size_alloc_(0)\n{\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)\n    : __size_alloc_(0, __node_allocator(__a))\n{\n}\n\ntemplate <class _Tp, class _Alloc>\n__list_imp<_Tp, _Alloc>::~__list_imp()\n{\n    clear();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::clear() _NOEXCEPT\n{\n    if (!empty())\n    {\n        __node_allocator& __na = __node_alloc();\n        __node_pointer __f = __end_.__next_;\n        __node_pointer __l = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n        __unlink_nodes(__f, __l->__prev_);\n        __sz() = 0;\n        while (__f != __l)\n        {\n            __node_pointer __n = __f;\n            __f = __f->__next_;\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != __l)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __c.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    using _VSTD::swap;\n    __swap_alloc(__node_alloc(), __c.__node_alloc());\n    swap(__sz(), __c.__sz());\n    swap(__end_, __c.__end_);\n    if (__sz() == 0)\n        __end_.__next_ = __end_.__prev_ = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n    else\n        __end_.__prev_->__next_ = __end_.__next_->__prev_\n                                = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n    if (__c.__sz() == 0)\n        __c.__end_.__next_ = __c.__end_.__prev_\n                           = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_));\n    else\n        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_\n                                    = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __libcpp_db* __db = __get_db();\n    __c_node* __cn1 = __db->__find_c_and_lock(this);\n    __c_node* __cn2 = __db->__find_c(&__c);\n    std::swap(__cn1->beg_, __cn2->beg_);\n    std::swap(__cn1->end_, __cn2->end_);\n    std::swap(__cn1->cap_, __cn2->cap_);\n    for (__i_node** __p = __cn1->end_; __p != __cn1->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n        {\n            __cn2->__add(*__p);\n            if (--__cn1->end_ != __p)\n                memmove(__p, __p+1, (__cn1->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn1;\n    }\n    for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_)))\n        {\n            __cn1->__add(*__p);\n            if (--__cn2->end_ != __p)\n                memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn2;\n    }\n    __db->unlock();\n#endif\n}\n\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY list\n    : private __list_imp<_Tp, _Alloc>\n{\n    typedef __list_imp<_Tp, _Alloc> base;\n    typedef typename base::__node              __node;\n    typedef typename base::__node_allocator    __node_allocator;\n    typedef typename base::__node_pointer      __node_pointer;\n    typedef typename base::__node_alloc_traits __node_alloc_traits;\n    typedef typename base::__node_base         __node_base;\n    typedef typename base::__node_base_pointer __node_base_pointer;\n\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Alloc                                   allocator_type;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename base::pointer                   pointer;\n    typedef typename base::const_pointer             const_pointer;\n    typedef typename base::size_type                 size_type;\n    typedef typename base::difference_type           difference_type;\n    typedef typename base::iterator                  iterator;\n    typedef typename base::const_iterator            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    list()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    explicit list(const allocator_type& __a) : base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit list(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit list(size_type __n, const allocator_type& __a);\n#endif\n    list(size_type __n, const value_type& __x);\n    list(size_type __n, const value_type& __x, const allocator_type& __a);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n\n    list(const list& __c);\n    list(const list& __c, const allocator_type& __a);\n    list& operator=(const list& __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    list(initializer_list<value_type> __il);\n    list(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    list(list&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value);\n    list(list&& __c, const allocator_type& __a);\n    list& operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    list& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InpIter>\n        void assign(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    allocator_type get_allocator() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT     {return base::__sz();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT         {return base::empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return numeric_limits<difference_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT        {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT          {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return base::end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    reference back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n       void emplace_front(_Args&&... __args);\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n    template <class... _Args>\n        iterator emplace(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    iterator insert(const_iterator __p, value_type&& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void push_front(const value_type& __x);\n    void push_back(const value_type& __x);\n\n    iterator insert(const_iterator __p, const value_type& __x);\n    iterator insert(const_iterator __p, size_type __n, const value_type& __x);\n    template <class _InpIter>\n        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, initializer_list<value_type> __il)\n        {return insert(__p, __il.begin(), __il.end());}\n#endif   // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(list& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {base::swap(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {base::clear();}\n\n    void pop_front();\n    void pop_back();\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n\n    void resize(size_type __n);\n    void resize(size_type __n, const value_type& __x);\n\n    void splice(const_iterator __p, list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}\n#endif\n    void splice(const_iterator __p, list& __c, const_iterator __i);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __i)\n        {splice(__p, __c, __i);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)\n        {splice(__p, __c, __f, __l);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void remove(const value_type& __x);\n    template <class _Pred> void remove_if(_Pred __pred);\n    void unique();\n    template <class _BinaryPred>\n        void unique(_BinaryPred __binary_pred);\n    void merge(list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(list&& __c) {merge(__c);}\n#endif\n    template <class _Comp>\n        void merge(list& __c, _Comp __comp);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Comp>\n    _LIBCPP_INLINE_VISIBILITY\n        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void sort();\n    template <class _Comp>\n        void sort(_Comp __comp);\n\n    void reverse() _NOEXCEPT;\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    static void __link_nodes(__node_pointer __p, __node_pointer __f, __node_pointer __l);\n    iterator __iterator(size_type __n);\n    template <class _Comp>\n        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);\n\n    void __move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value);\n    void __move_assign(list& __c, false_type);\n};\n\n// Link in nodes [__f, __l] just prior to __p\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes(__node_pointer __p, __node_pointer __f, __node_pointer __l)\n{\n    __p->__prev_->__next_ = __f;\n    __f->__prev_ = __p->__prev_;\n    __p->__prev_ = __l;\n    __l->__next_ = __p;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__iterator(size_type __n)\n{\n    return __n <= base::__sz() / 2 ? _VSTD::next(begin(), __n)\n                                   : _VSTD::prev(end(), base::__sz() - __n);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n#endif\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c)\n    : base(allocator_type(\n           __node_alloc_traits::select_on_container_copy_construction(\n                __c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(const list& __c)\n{\n    if (this != &__c)\n    {\n        base::__copy_assign_alloc(__c);\n        assign(__c.begin(), __c.end());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value)\n    : base(allocator_type(_VSTD::move(__c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    splice(end(), __c);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __c.get_allocator())\n        splice(end(), __c);\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n{\n    __move_assign(__c, integral_constant<bool,\n          __node_alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, false_type)\n{\n    if (base::__node_alloc() != __c.__node_alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n{\n    clear();\n    base::__move_assign_alloc(__c);\n    splice(end(), __c);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nvoid\nlist<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,\n                          typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __f != __l && __i != __e; ++__f, ++__i)\n        *__i = *__f;\n    if (__i == __e)\n        insert(__e, __f, __l);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __n > 0 && __i != __e; --__n, ++__i)\n        *__i = __x;\n    if (__i == __e)\n        insert(__e, __n, __x);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n_Alloc\nlist<_Tp, _Alloc>::get_allocator() const _NOEXCEPT\n{\n    return allocator_type(base::__node_alloc());\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__n > 0)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, range) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__f != __l)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (++__f; __f != __l; ++__f, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(base::__end_.__next_, __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(base::__end_.__next_, __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_front(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(base::__end_.__next_, __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_back(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::emplace(iterator, args...) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_front()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_front() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_back() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__prev_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __p)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::erase(iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    _LIBCPP_ASSERT(__p != end(),\n        \"list::erase(iterator) called with a non-dereferenceable iterator\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = __p.__ptr_;\n    __node_pointer __r = __n->__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__r, this);\n#else\n    return iterator(__r);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == this,\n        \"list::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (__f != __l)\n    {\n        __node_allocator& __na = base::__node_alloc();\n        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);\n        while (__f != __l)\n        {\n            __node_pointer __n = __f.__ptr_;\n            ++__f;\n            --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __c_node* __c = __get_db()->__find_c_and_lock(this);\n            for (__i_node** __p = __c->end_; __p != __c->beg_; )\n            {\n                --__p;\n                iterator* __i = static_cast<iterator*>((*__p)->__i_);\n                if (__i->__ptr_ == __n)\n                {\n                    (*__p)->__c_ = nullptr;\n                    if (--__c->end_ != __p)\n                        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n            __get_db()->unlock();\n#endif\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__l.__ptr_, this);\n#else\n    return iterator(__l.__ptr_);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c)\n{\n    _LIBCPP_ASSERT(this != &__c,\n                   \"list::splice(iterator, list) called with this == &list\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (!__c.empty())\n    {\n        __node_pointer __f = __c.__end_.__next_;\n        __node_pointer __l = __c.__end_.__prev_;\n        base::__unlink_nodes(__f, __l);\n        __link_nodes(__p.__ptr_, __f, __l);\n        base::__sz() += __c.__sz();\n        __c.__sz() = 0;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__i) == &__c,\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(&__i),\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" derefereceable\");\n#endif\n    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)\n    {\n        __node_pointer __f = __i.__ptr_;\n        base::__unlink_nodes(__f, __f);\n        __link_nodes(__p.__ptr_, __f, __f);\n        --__c.__sz();\n        ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            if (__j->__ptr_ == __f)\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == &__c,\n        \"list::splice(iterator, list, iterator, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    if (this == &__c)\n    {\n        for (const_iterator __i = __f; __i != __l; ++__i)\n            _LIBCPP_ASSERT(__i != __p,\n                           \"list::splice(iterator, list, iterator, iterator)\"\n                           \" called with the first iterator within the range\"\n                           \" of the second and third iterators\");\n    }\n#endif\n    if (__f != __l)\n    {\n        if (this != &__c)\n        {\n            size_type __s = _VSTD::distance(__f, __l);\n            __c.__sz() -= __s;\n            base::__sz() += __s;\n        }\n        __node_pointer __first = __f.__ptr_;\n        --__l;\n        __node_pointer __last = __l.__ptr_;\n        base::__unlink_nodes(__first, __last);\n        __link_nodes(__p.__ptr_, __first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            for (__node_pointer __k = __f.__ptr_;\n                                          __k != __l.__ptr_; __k = __k->__next_)\n            {\n                if (__j->__ptr_ == __k)\n                {\n                    __cn1->__add(*__p);\n                    (*__p)->__c_ = __cn1;\n                    if (--__cn2->end_ != __p)\n                        memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::remove(const value_type& __x)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (*__i == __x)\n        {\n            iterator __j = _VSTD::next(__i);\n            for (; __j != __e && *__j == __x; ++__j)\n                ;\n            __i = erase(__i, __j);\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Pred>\nvoid\nlist<_Tp, _Alloc>::remove_if(_Pred __pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (__pred(*__i))\n        {\n            iterator __j = _VSTD::next(__i);\n            for (; __j != __e && __pred(*__j); ++__j)\n                ;\n            __i = erase(__i, __j);\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::unique()\n{\n    unique(__equal_to<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _BinaryPred>\nvoid\nlist<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        iterator __j = _VSTD::next(__i);\n        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)\n            ;\n        if (++__i != __j)\n            __i = erase(__i, __j);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::merge(list& __c)\n{\n    merge(__c, __less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\nvoid\nlist<_Tp, _Alloc>::merge(list& __c, _Comp __comp)\n{\n    if (this != &__c)\n    {\n        iterator __f1 = begin();\n        iterator __e1 = end();\n        iterator __f2 = __c.begin();\n        iterator __e2 = __c.end();\n        while (__f1 != __e1 && __f2 != __e2)\n        {\n            if (__comp(*__f2, *__f1))\n            {\n                size_type __ds = 1;\n                iterator __m2 = _VSTD::next(__f2);\n                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)\n                    ;\n                base::__sz() += __ds;\n                __c.__sz() -= __ds;\n                __node_pointer __f = __f2.__ptr_;\n                __node_pointer __l = __m2.__ptr_->__prev_;\n                __f2 = __m2;\n                base::__unlink_nodes(__f, __l);\n                __m2 = _VSTD::next(__f1);\n                __link_nodes(__f1.__ptr_, __f, __l);\n                __f1 = __m2;\n            }\n            else\n                ++__f1;\n        }\n        splice(__e1, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort()\n{\n    sort(__less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort(_Comp __comp)\n{\n    __sort(begin(), end(), base::__sz(), __comp);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)\n{\n    switch (__n)\n    {\n    case 0:\n    case 1:\n        return __f1;\n    case 2:\n        if (__comp(*--__e2, *__f1))\n        {\n            __node_pointer __f = __e2.__ptr_;\n            base::__unlink_nodes(__f, __f);\n            __link_nodes(__f1.__ptr_, __f, __f);\n            return __e2;\n        }\n        return __f1;\n    }\n    size_type __n2 = __n / 2;\n    iterator __e1 = _VSTD::next(__f1, __n2);\n    iterator  __r = __f1 = __sort(__f1, __e1, __n2, __comp);\n    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);\n    if (__comp(*__f2, *__f1))\n    {\n        iterator __m2 = _VSTD::next(__f2);\n        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n            ;\n        __node_pointer __f = __f2.__ptr_;\n        __node_pointer __l = __m2.__ptr_->__prev_;\n        __r = __f2;\n        __e1 = __f2 = __m2;\n        base::__unlink_nodes(__f, __l);\n        __m2 = _VSTD::next(__f1);\n        __link_nodes(__f1.__ptr_, __f, __l);\n        __f1 = __m2;\n    }\n    else\n        ++__f1;\n    while (__f1 != __e1 && __f2 != __e2)\n    {\n        if (__comp(*__f2, *__f1))\n        {\n            iterator __m2 = _VSTD::next(__f2);\n            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n                ;\n            __node_pointer __f = __f2.__ptr_;\n            __node_pointer __l = __m2.__ptr_->__prev_;\n            if (__e1 == __f2)\n                __e1 = __m2;\n            __f2 = __m2;\n            base::__unlink_nodes(__f, __l);\n            __m2 = _VSTD::next(__f1);\n            __link_nodes(__f1.__ptr_, __f, __l);\n            __f1 = __m2;\n        }\n        else\n            ++__f1;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::reverse() _NOEXCEPT\n{\n    if (base::__sz() > 1)\n    {\n        iterator __e = end();\n        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)\n        {\n            _VSTD::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);\n            __i.__ptr_ = __i.__ptr_->__prev_;\n        }\n        _VSTD::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__invariants() const\n{\n    return size() == _VSTD::distance(begin(), end());\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(this->__end_)));\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__decrementable(const const_iterator* __i) const\n{\n    return !empty() &&  __i->__ptr_ != base::__end_.__next_;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LIST\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musbeam.h\n// Author:      Rodolfo Zitellini\n// Created:     26/06/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n//\n\n#ifndef __MUS_BEAM_H__\n#define __MUS_BEAM_H__\n\n#include \"muslayerelement.h\"\n#include \"musnote.h\"\n\n//----------------------------------------------------------------------------\n// MusBeam\n//----------------------------------------------------------------------------\n\nclass MusBeam: public MusLayerElement, public MusObjectListInterface\n{\npublic:\n    // constructors and destructors\n    MusBeam();\n    virtual ~MusBeam();\n    \n    virtual std::string MusClassName( ) { return \"MusBeam\"; };\n    \n    int GetNoteCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Add an element (a note or a rest) to a beam.\n     * Only MusNote or MusRest elements will be actually added to the beam.\n     */\n    void AddElement(MusLayerElement *element);\n    \n    // functor\n    //virtual int Save( ArrayPtrVoid params );\n    \nprotected:\n    /**\n     * Filter the list for a specific class.\n     * For example, keep only notes in MusBeam\n     */\n    virtual void FilterList();\n    \nprivate:\n\npublic:\n    \nprivate:\n    \n};\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musclef.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musclef.h\"\n\n//----------------------------------------------------------------------------\n// MusClef\n//----------------------------------------------------------------------------\n\nMusClef::MusClef():\n\tMusLayerElement(\"clef-\")\n{\n    m_clefId = UT1;\n}\n\n\nMusClef::~MusClef()\n{\n}\n\nint MusClef::GetClefOffset ()\n{\t\n\tint offset = 0;\t\t// case 5: UT 1e ligne par default, valable pour PERC\n\tswitch(m_clefId)\n\t{\tcase SOL2 : offset = -2; break;\n\t\tcase SOL1 : offset = -4; break;\n\t\tcase SOLva : offset = 5; break;\n\t\tcase FA5 : offset = 12; break;\n\t\tcase FA4 : offset = 10; break;\n\t\tcase FA3 : offset = 8; break;\n\t\tcase UT2 : offset = 2; break;\n\t\tcase UT3 : offset = 4; break;\n\t\tcase UT5 : offset = 8; break;\n\t\tcase UT4 : offset =  6;\t\t\n\t\tdefault: break;\n\t}\n\treturn offset;\n}\n\nbool MusClef::operator==( MusObject& other )\n{\n    MusClef *otherClef = dynamic_cast<MusClef*>( &other );\n    if ( !otherClef ) {\n        return false;\n    }\n    if ( this->m_clefId != otherClef->m_clefId ) {\n        return false;\n    }\n    return true;\n}\n\nvoid MusClef::SetValue( int value, int flag ) \n{\n   switch ( value )\n   {\n       case ('1'): this->m_clefId = SOL1; break;\n       case ('2'): this->m_clefId = SOL2; break;\n       case ('3'): this->m_clefId = UT1; break;\n       case ('4'): this->m_clefId = UT2; break;\n       case ('5'): this->m_clefId = UT3; break;\n       case ('6'): this->m_clefId = UT4; break;\n       case ('7'): this->m_clefId = UT5; break;\n       case ('8'): this->m_clefId = FA3; break;\n       case ('9'): this->m_clefId = FA4; break;\n       case ('0'): this->m_clefId = FA5; break;\n   }\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musclef.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_CLEF_H__\n#define __MUS_CLEF_H__\n\n#include \"musdef.h\"\n#include \"muslayerelement.h\"\n\n//----------------------------------------------------------------------------\n// MusClef\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <clef> element. \n */\nclass MusClef: public MusLayerElement\n{\npublic:\n    // constructors and destructors\n    MusClef();\n    virtual ~MusClef();\n    \n    /**\n     * Comparison operator. \n     * Check if the MusLayerElement if a MusClef and compare attributes\n     */\n    virtual bool operator==(MusObject& other);\n    \n    virtual std::string MusClassName( ) { return \"MusClef\"; };\n    \n    /**\n     * Return the offset of the clef\n     */\n    int GetClefOffset();\n    \n    /**\n     * Set the value for the clef.\n     */\n\tvirtual void SetValue( int value, int flag = 0 );\n    \nprivate:\n    \npublic:\n    /** Indicates the shape and the line of the clef using clef ids  */\n    ClefId m_clefId;\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muscontroller.cpp\n// Author:      Laurent Pugin\n// Created:     17/10/2013\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"muscontroller.h\"\n\n//----------------------------------------------------------------------------\n\n#include <iostream>\n\n//----------------------------------------------------------------------------\n\n#include \"musbboxdc.h\"\n#include \"musdoc.h\"\n#include \"musiodarms.h\"\n#include \"musiomei.h\"\n#include \"musiomusxml.h\"\n#include \"musiopae.h\"\n#include \"muspage.h\"\n#include \"musrc.h\"\n#include \"mussvgdc.h\"\n#include \"mussystem.h\"\n\n#ifdef USE_EMSCRIPTEN\n#include \"jsonxx.h\"\nusing namespace jsonxx;\n#endif\n\n//----------------------------------------------------------------------------\n// MusController\n//----------------------------------------------------------------------------\n\nMusController::MusController()\n{\n    m_border = 10;\n    m_scale = 100;\n    m_format = pae_file;\n}\n\n\nMusController::~MusController()\n{\n}\n\nbool MusController::LoadFile( std::string filename )\n{\n    MusFileInputStream *input = NULL;\n    if (m_format == pae_file) {\n        input = new MusPaeInput( &m_doc, filename.c_str() );\n    } else if (m_format == darms_file) {\n        input = new MusDarmsInput( &m_doc, filename.c_str() );\n    } else if (m_format == mei_file) {\n        input = new MusMeiInput( &m_doc, filename.c_str() );\n    }\n    else {\n        Mus::LogError( \"Unknown format\" );\n        return false;\n    }\n    \n    // something went wrong\n    if ( !input ) {\n        Mus::LogError( \"Unknown error\" );\n        return false;\n    }\n\n    // load the file\n    if ( !input->ImportFile()) {\n        Mus::LogError( \"Error importing file '%s'\", filename.c_str() );\n        delete input;\n        return false;\n    }\n    \n    m_rc.SetDoc( &m_doc );\n    delete input;\n    return true;\n}\n\nbool MusController::LoadString( std::string data )\n{\n    MusFileInputStream *input = NULL;\n    if (m_format == pae_file) {\n        input = new MusPaeInput( &m_doc, \"\" );\n    } else if (m_format == mei_file) {\n        input = new MusMeiInput( &m_doc, \"\" );\n    }\n    else {\n        Mus::LogError( \"Unknown format\" );\n        return false;\n    }\n    \n    // something went wrong\n    if ( !input ) {\n        Mus::LogError( \"Unknown error\" );\n        return false;\n    }\n    \n    // load the file\n    if ( !input->ImportString( data )) {\n        Mus::LogError( \"Error importing data\" );\n        delete input;\n        return false;\n    }\n    \n    m_rc.SetDoc( &m_doc );\n    delete input;\n    return true;\n}\n\nbool MusController::ParseOptions( std::string json_options ) {\n#ifdef USE_EMSCRIPTEN\n    std::string in_format = \"pae\";\n    \n    int scale = m_scale;\n    int border = m_border;\n    \n    Object json;\n        \n    // Read JSON options\n    if (!json.parse(json_options)) {\n        Mus::LogError( \"Can not parse JSON string.\" );\n        return false;\n    }\n    \n    if (json.has<String>(\"InputFormat\"))\n        in_format = json.get<String>(\"InputFormat\");\n    \n    if (json.has<Number>(\"Scale\"))\n        scale = json.get<Number>(\"Scale\");\n    \n    if (json.has<Number>(\"Border\"))\n        border = json.get<Number>(\"Border\");\n    \n    if (in_format == \"pae\") \n        SetFormat(pae_file);\n    else if (in_format == \"mei\")\n        SetFormat(mei_file);\n    else if (in_format == \"darms\")\n        SetFormat(darms_file);\n    else { // fail if format in invalid\n        Mus::LogError( \"InputFormat is invalid: %s\\n\", in_format.c_str() );\n        return false;\n    }\n    \n    // Check boundaries for scale and border\n    \n    if (border < 0 || border > 1000) {\n        Mus::LogError( \"Border out of bounds, use 10 (default).\" );\n        border = 10;\n    }\n        \n    if (scale < 0 || scale > 1000) {\n        Mus::LogError( \"Scale out of bounds, use 10 (default).\" );\n        scale = 100;\n    }\n    \n    SetScale(scale);\n    SetBorder(border);\n    \n    return true;\n    \n#else\n    // The non js version of the app should not use this function.\n    return false;\n#endif\n    \n}\n\nstd::string MusController::RenderToSvg( int pageNo, bool xml_tag )\n{\n    m_doc.Layout();\n    \n    // Get the current system for the SVG clipping size\n    MusPage *page = dynamic_cast<MusPage*>(m_doc.m_children[0]);\n    //MusSystem *system = dynamic_cast<MusSystem*>(page->m_children[0]);\n    \n    // Create the SVG object, h & w come from the system\n    // we add border*2 so it is centered into the image\n    //MusSvgDC svg(system->m_contentBB_x2 - system->m_contentBB_x1 + m_border * 2, (system->m_contentBB_y2 - system->m_contentBB_y1) + m_border * 2);\n    MusSvgDC svg( m_doc.m_rendPageWidth, m_doc.m_rendPageHeight );\n    \n    // set scale and border from user options\n    svg.SetUserScale((double)m_scale / 100, (double)m_scale / 100);\n    svg.SetLogicalOrigin(m_border, m_border);\n    \n    // render the page\n    m_rc.DrawPage( &svg, page , false);\n    \n    std::string out_str = svg.GetStringSVG( xml_tag );\n    return out_str;\n}\n\n\nbool MusController::RenderToSvgFile( std::string filename, int pageNo )\n{\n    std::string output = RenderToSvg( pageNo, true );\n    \n    std::ofstream outfile;\n    outfile.open ( filename.c_str() );\n    \n    if ( !outfile.is_open() ) {\n        // add message?\n        return false;\n    }\n    \n    outfile << output;\n    outfile.close();\n    return true;\n}\n","// -*- mode: c++; c-basic-offset: 4; -*-\n\n// Author: Hong Jiang <hong@hjiang.net>\n// Contributors:\n//   Sean Middleditch <sean@middleditch.us>\n//   rlyeh <https://github.com/r-lyeh>\n\n#pragma once\n\n#include <cassert>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// jsonxx versioning: major.minor-extra where\n// major = { number }\n// minor = { number }\n// extra = { 'a':alpha, 'b':beta, 'rc': release candidate, 'r': release, 's':stable }\n#define JSONXX_MAJOR    \"0\"\n#define JSONXX_MINOR    \"22\"\n#define JSONXX_EXTRA    \"a\"\n#define JSONXX_VERSION  JSONXX_MAJOR \".\" JSONXX_MINOR \"-\" JSONXX_EXTRA\n#define JSONXX_XML_TAG  \"<!-- generated by jsonxx \" JSONXX_VERSION \" -->\"\n\n#if __cplusplus > 199711L\n#define JSONXX_COMPILER_HAS_CXX11 1\n#elif defined(_MSC_VER) && _MSC_VER > 1700\n#define JSONXX_COMPILER_HAS_CXX11 1\n#else\n#define JSONXX_COMPILER_HAS_CXX11 0\n#endif\n\n#define JSONXX_ASSERT(...) do { if( jsonxx::Assertions ) \\\n  jsonxx::assertion(__FILE__,__LINE__,#__VA_ARGS__,bool(__VA_ARGS__)); } while(0)\n\nnamespace jsonxx {\n\n// Settings\nenum Settings {\n  // constants\n  Enabled = true,\n  Disabled = false,\n  Permissive = true,\n  Strict = false,\n  // values\n  Parser = Permissive,  // permissive or strict parsing\n  Assertions = Enabled  // enabled or disabled assertions (these asserts work both in DEBUG and RELEASE builds)\n};\n\n// Constants for .write() and .xml() methods\nenum Format {\n  JSON      = 0,     // JSON output\n  JSONx     = 1,     // XML output, JSONx  format. see http://goo.gl/I3cxs\n  JXML      = 2,     // XML output, JXML   format. see https://github.com/r-lyeh/JXML\n  JXMLex    = 3,     // XML output, JXMLex format. see https://github.com/r-lyeh/JXMLex\n  TaggedXML = 4      // XML output, tagged XML format. see https://github.com/hjiang/jsonxx/issues/12\n};\n\n// Types\ntypedef long double Number;\ntypedef bool Boolean;\ntypedef std::string String;\nstruct Null {};\nclass Value;\nclass Object;\nclass Array;\n\n// Tools\nbool validate( const std::string &input );\nbool validate( std::istream &input );\nstd::string xml( const std::string &input, unsigned format = JSONx );\nstd::string xml( std::istream &input, unsigned format = JSONx );\n\n// Detail\nvoid assertion( const char *file, int line, const char *expression, bool result );\n\n// A JSON Object\nclass Object {\n public:\n  Object();\n  ~Object();\n\n  template <typename T>\n  bool has(const std::string& key) const;\n\n  // Always call has<>() first. If the key doesn't exist, consider\n  // the behavior undefined.\n  template <typename T>\n  T& get(const std::string& key);\n  template <typename T>\n  const T& get(const std::string& key) const;\n\n  size_t size() const;\n  bool empty() const;\n\n  const std::map<std::string, Value*>& kv_map() const;\n  std::string json() const;\n  std::string xml( unsigned format = JSONx, const std::string &header = std::string(), const std::string &attrib = std::string() ) const;\n  std::string write( unsigned format ) const;\n\n  void reset();\n  bool parse(std::istream &input);\n  bool parse(const std::string &input);\n  typedef std::map<std::string, Value*> container;\n  void import( const Object &other );\n  void import( const std::string &key, const Value &value );\n  Object &operator<<(const Value &value);\n  Object &operator<<(const Object &value);\n  Object &operator=(const Object &value);\n  Object(const Object &other);\n  Object(const std::string &key, const Value &value);\n  template<size_t N>\n  Object(const char (&key)[N], const Value &value) {\n    import(key,value);\n  }\n  template<typename T>\n  Object &operator<<(const T &value);\n\n protected:\n  static bool parse(std::istream& input, Object& object);\n  container value_map_;\n  std::string odd;\n};\n\nclass Array {\n public:\n  Array();\n  ~Array();\n\n  size_t size() const;\n  bool empty() const;\n\n  template <typename T>\n  bool has(unsigned int i) const;\n\n  template <typename T>\n  T& get(unsigned int i);\n  template <typename T>\n  const T& get(unsigned int i) const;\n\n  const std::vector<Value*>& values() const {\n    return values_;\n  }\n  std::string json() const;\n  std::string xml( unsigned format = JSONx, const std::string &header = std::string(), const std::string &attrib = std::string() ) const;\n\n  std::string write( unsigned format ) const { return format == JSON ? json() : xml(format); }\n  void reset();\n  bool parse(std::istream &input);\n  bool parse(const std::string &input);\n  typedef std::vector<Value*> container;\n  void import(const Array &other);\n  void import(const Value &value);\n  Array &operator<<(const Array &other);\n  Array &operator<<(const Value &value);\n  Array &operator=(const Array &other);\n  Array &operator=(const Value &value);\n  Array(const Array &other);\n  Array(const Value &value);\n protected:\n  static bool parse(std::istream& input, Array& array);\n  container values_;\n};\n\n// A value could be a number, an array, a string, an object, a\n// boolean, or null\nclass Value {\n public:\n\n  Value();\n  ~Value() { reset(); }\n  void reset();\n\n  template<typename T>\n  void import( const T & ) {\n    reset();\n    type_ = INVALID_;\n    // debug\n    // std::cout << \"[WARN] No support for \" << typeid(t).name() << std::endl;\n  }\n  void import( const bool &b ) {\n    reset();\n    type_ = BOOL_;\n    bool_value_ = b;\n  }\n#define $number(TYPE) \\\n  void import( const TYPE &n ) { \\\n    reset(); \\\n    type_ = NUMBER_; \\\n    number_value_ = n; \\\n  }\n  $number( char )\n  $number( int )\n  $number( long )\n  $number( long long )\n  $number( unsigned char )\n  $number( unsigned int )\n  $number( unsigned long )\n  $number( unsigned long long )\n  $number( float )\n  $number( double )\n  $number( long double )\n#undef $number\n#if JSONXX_COMPILER_HAS_CXX11 > 0\n  void import( const std::nullptr_t & ) {\n    reset();\n    type_ = NULL_;\n  }\n#endif\n  void import( const Null & ) {\n    reset();\n    type_ = NULL_;\n  }\n  void import( const String &s ) {\n    reset();\n    type_ = STRING_;\n    *( string_value_ = new String() ) = s;\n  }\n  void import( const Array &a ) {\n    reset();\n    type_ = ARRAY_;\n    *( array_value_ = new Array() ) = a;\n  }\n  void import( const Object &o ) {\n    reset();\n    type_ = OBJECT_;\n    *( object_value_ = new Object() ) = o;\n  }\n  void import( const Value &other ) {\n    if (this != &other)\n    switch (other.type_) {\n      case NULL_:\n        import( Null() );\n        break;\n      case BOOL_:\n        import( other.bool_value_ );\n        break;\n      case NUMBER_:\n        import( other.number_value_ );\n        break;\n      case STRING_:\n        import( *other.string_value_ );\n        break;\n      case ARRAY_:\n        import( *other.array_value_ );\n        break;\n      case OBJECT_:\n        import( *other.object_value_ );\n        break;\n      case INVALID_:\n        type_ = INVALID_;\n        break;\n      default:\n        JSONXX_ASSERT( !\"not implemented\" );\n    }\n  }\n  template<typename T>\n  Value &operator <<( const T &t ) {\n    import(t);\n    return *this;\n  }\n  template<typename T>\n  Value &operator =( const T &t ) {\n    reset();\n    import(t);\n    return *this;\n  }\n  Value(const Value &other);\n  template<typename T>\n  Value( const T&t ) : type_(INVALID_) { import(t); }\n  template<size_t N>\n  Value( const char (&t)[N] ) : type_(INVALID_) { import( std::string(t) ); }\n\n  bool parse(std::istream &input);\n  bool parse(const std::string &input);\n\n  template<typename T>\n  bool is() const;\n  template<typename T>\n  T& get();\n  template<typename T>\n  const T& get() const;\n\n  bool empty() const;\n\n public:\n  enum {\n    NUMBER_,\n    STRING_,\n    BOOL_,\n    NULL_,\n    ARRAY_,\n    OBJECT_,\n    INVALID_\n  } type_;\n  union {\n    Number number_value_;\n    String* string_value_;\n    Boolean bool_value_;\n    Array* array_value_;\n    Object* object_value_;\n  };\n\nprotected:\n  static bool parse(std::istream& input, Value& value);\n};\n\ntemplate <typename T>\nbool Array::has(unsigned int i) const {\n  if (i >= size()) {\n    return false;\n  } else {\n    Value* v = values_.at(i);\n    return v->is<T>();\n  }\n}\n\ntemplate <typename T>\nT& Array::get(unsigned int i) {\n  JSONXX_ASSERT(i < size());\n  Value* v = values_.at(i);\n  return v->get<T>();\n}\n\ntemplate <typename T>\nconst T& Array::get(unsigned int i) const {\n  JSONXX_ASSERT(i < size());\n  const Value* v = values_.at(i);\n  return v->get<T>();\n}\n\ntemplate <typename T>\nbool Object::has(const std::string& key) const {\n  container::const_iterator it(value_map_.find(key));\n  return it != value_map_.end() && it->second->is<T>();\n}\n\ntemplate <typename T>\nT& Object::get(const std::string& key) {\n  JSONXX_ASSERT(has<T>(key));\n  return value_map_.find(key)->second->get<T>();\n}\n\ntemplate <typename T>\nconst T& Object::get(const std::string& key) const {\n  JSONXX_ASSERT(has<T>(key));\n  return value_map_.find(key)->second->get<T>();\n}\n\ntemplate<>\ninline bool Value::is<Null>() const {\n  return type_ == NULL_;\n}\n\ntemplate<>\ninline bool Value::is<Boolean>() const {\n  return type_ == BOOL_;\n}\n\ntemplate<>\ninline bool Value::is<String>() const {\n  return type_ == STRING_;\n}\n\ntemplate<>\ninline bool Value::is<Number>() const {\n  return type_ == NUMBER_;\n}\n\ntemplate<>\ninline bool Value::is<Array>() const {\n  return type_ == ARRAY_;\n}\n\ntemplate<>\ninline bool Value::is<Object>() const {\n  return type_ == OBJECT_;\n}\n\ntemplate<>\ninline bool& Value::get<Boolean>() {\n  JSONXX_ASSERT(is<Boolean>());\n  return bool_value_;\n}\n\ntemplate<>\ninline std::string& Value::get<String>() {\n  JSONXX_ASSERT(is<String>());\n  return *string_value_;\n}\n\ntemplate<>\ninline Number& Value::get<Number>() {\n  JSONXX_ASSERT(is<Number>());\n  return number_value_;\n}\n\ntemplate<>\ninline Array& Value::get<Array>() {\n  JSONXX_ASSERT(is<Array>());\n  return *array_value_;\n}\n\ntemplate<>\ninline Object& Value::get<Object>() {\n  JSONXX_ASSERT(is<Object>());\n  return *object_value_;\n}\n\ntemplate<>\ninline const Boolean& Value::get<Boolean>() const {\n  JSONXX_ASSERT(is<Boolean>());\n  return bool_value_;\n}\n\ntemplate<>\ninline const String& Value::get<String>() const {\n  JSONXX_ASSERT(is<String>());\n  return *string_value_;\n}\n\ntemplate<>\ninline const Number& Value::get<Number>() const {\n  JSONXX_ASSERT(is<Number>());\n  return number_value_;\n}\n\ntemplate<>\ninline const Array& Value::get<Array>() const {\n  JSONXX_ASSERT(is<Array>());\n  return *array_value_;\n}\n\ntemplate<>\ninline const Object& Value::get<Object>() const {\n  JSONXX_ASSERT(is<Object>());\n  return *object_value_;\n}\n\ntemplate<typename T>\ninline Object &Object::operator<<(const T &value) {\n  return *this << Value(value), *this;\n}\n\n}  // namespace jsonxx\n\nstd::ostream& operator<<(std::ostream& stream, const jsonxx::Value& v);\nstd::ostream& operator<<(std::ostream& stream, const jsonxx::Object& v);\nstd::ostream& operator<<(std::ostream& stream, const jsonxx::Array& v);\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value\n#if __has_feature(is_final)\n                                                        && !__is_final(_Compare)\n#endif\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#if __cplusplus >= 201103L\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(_Args&& ...__args)\n        : __cc(std::forward<_Args>(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const __value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type&& __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__value_type() {__cc.~value_type();}\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type() {}\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0)\n        : __cc(__a0) {}\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0, const _A1& __a1)\n        : __cc(__a0, __a1) {}\n};\n\n#endif\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_const_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(\n            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)\n                _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp = key_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            __tree_.clear();\n            __tree_.value_comp() = __m.__tree_.value_comp();\n            __tree_.__copy_assign_alloc(__m.__tree_);\n            insert(__m.begin(), __m.end());\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        pair<iterator, bool>\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif\n    __node_holder __construct_node_with_key(const key_type& __k);\n\n    __node_base_pointer&\n        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);\n    __node_base_const_pointer\n        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;\n};\n\n// Find place to insert if __k doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k)\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_const_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_const_pointer __parent;\n    __node_base_const_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_const_pointer>(__child)->__value_.__cc.second;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\npair<typename map<_Key, _Tp, _Compare, _Allocator>::iterator, bool>\nmap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __tree_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::iterator\nmap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                   _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_unique(__p.__i_, __h.get());\n    if (__r.__i_.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                                    __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp = key_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            __tree_.clear();\n            __tree_.value_comp() = __m.__tree_.value_comp();\n            __tree_.__copy_assign_alloc(__m.__tree_);\n            insert(__m.begin(), __m.end());\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        iterator\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                        _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multimap;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY set;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multiset;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Allocator> class __map_node_destructor;\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(false)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_end_node\n             <\n                typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__tree_node_base<_VoidPtr> >\n#else\n                     rebind<__tree_node_base<_VoidPtr> >::other\n#endif\n             >\n{\n    __tree_node_base(const __tree_node_base&);\n    __tree_node_base& operator=(const __tree_node_base&);\npublic:\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__tree_node_base>\n#else\n            rebind<__tree_node_base>::other\n#endif\n                                                pointer;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const __tree_node_base>\n#else\n            rebind<const __tree_node_base>::other\n#endif\n                                                const_pointer;\n    typedef __tree_end_node<pointer> base;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_node_base() _NOEXCEPT\n        : __right_(), __parent_(), __is_black_(false) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef __tree_node_base<_VoidPtr> base;\n    typedef _Tp value_type;\n\n    value_type __value_;\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tree_node(_Args&& ...__args)\n            : __value_(_VSTD::forward<_Args>(__args)...) {}\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node(const value_type& __v)\n            : __value_(__v) {}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n};\n\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_iterator\n{\n    typedef _NodePtr                                              __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename __node_base::pointer                         __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag iterator_category;\n    typedef _Tp                        value_type;\n    typedef _DiffType                  difference_type;\n    typedef value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n};\n\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator\n{\n    typedef _ConstNodePtr                                         __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node_base>\n#else\n            rebind<__node_base>::other\n#endif\n                                                                  __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef _DiffType                        difference_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef typename remove_const<__node>::type  __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                 __non_const_node_pointer;\n    typedef __tree_iterator<value_type, __non_const_node_pointer, difference_type>\n                                                 __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef typename __alloc_traits::void_pointer  __void_pointer;\n\n    typedef __tree_node<value_type, __void_pointer> __node;\n    typedef __tree_node_base<__void_pointer>        __node_base;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef typename __node_base::pointer            __node_base_pointer;\n    typedef typename __node_base::pointer            __node_base_const_pointer;\nprivate:\n    typedef typename __node_base::base __end_node_t;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_ptr;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_const_ptr;\n\n    __node_pointer                                          __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>\n               (\n                   pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_const_pointer>\n               (\n                   pointer_traits<__end_node_const_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first()))\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() _NOEXCEPT\n        {return static_cast<__node_pointer>      (__end_node()->__left_);}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_const_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value));\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        pair<iterator, bool>\n        __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n        iterator\n        __emplace_hint_unique(const_iterator __p, _Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Vp>\n        pair<iterator, bool> __insert_unique(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_unique(const_iterator __p, _Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(const_iterator __p, _Vp&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    pair<iterator, bool> __insert_unique(const value_type& __v);\n    iterator __insert_unique(const_iterator __p, const value_type& __v);\n    iterator __insert_multi(const value_type& __v);\n    iterator __insert_multi(const_iterator __p, const value_type& __v);\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const value_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        __node_holder __construct_node(const value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _VSTD::move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _VSTD::addressof(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n    _NOEXCEPT_(\n        __is_nothrow_swappable<value_compare>::value &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value))\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_alloc(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const value_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    iterator __r = __node_insert_unique(__p, __h.get());\n    if (__r.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __node_traits::destroy(__na, const_cast<value_type*>(_VSTD::addressof(*__p)));\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_const_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muscontroller.h\n// Author:      Laurent Pugin\n// Created:     17/10/2013\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_CONTROLLER_H__\n#define __MUS_CONTROLLER_H__\n\n#include \"musdoc.h\"\n#include \"musrc.h\"\n\n#include <string>\n\ntypedef enum _file_formats {\n    mei_file = 0,\n    pae_file,\n    darms_file\n} ConvertFileFormat;\n\n//----------------------------------------------------------------------------\n// MusController\n//----------------------------------------------------------------------------\n\nclass MusController\n{\npublic:\n    // constructors and destructors\n    MusController();\n    virtual ~MusController();\n    \n    /**\n     * Load a file with the specified type.\n     */\n    bool LoadFile( std::string filename );\n    \n    /**\n     * Load a string data witht he specified type.\n     */\n    bool LoadString( std::string data );\n    \n    /**\n     * Parse the options passed as JSON string\n     * only available for Emscripten based compiles\n     **/\n    bool ParseOptions( std::string json_options );\n    \n    /**\n     * Render the page in SVG and returns it as a string\n     */\n    std::string RenderToSvg( int pageNo =  1, bool xml_tag = false );\n\n    /**\n     * Render the page in SVG and save it to the file.\n     */\n    bool RenderToSvgFile( std::string filename, int pageNo =  1 );\n    \n    /**\n     * @name Set and get the border\n     */\n    ///@{\n    void SetBorder( int border ) { m_border = border; };\n    int GetBorder() { return m_border; };\n    ///@}\n    \n    /**\n     * @name Set and get the scale\n     */\n    ///@{\n    void SetScale( int scale ) { m_scale = scale; };\n    int GetScale() { return m_scale; };\n    ///@}\n    \n    /**\n     * @name Get the input file format (defined as ConvertFileFormat)\n     */\n    ///@{\n    void SetFormat( ConvertFileFormat format ) { m_format = format; };\n    int GetFormat() { return m_format; };\n    ///@}\n    \nprivate:\n    \npublic:\n    \nprivate:\n    MusDoc m_doc;\n    MusRC m_rc;\n    int m_border;\n    int m_scale;\n    ConvertFileFormat m_format;\n};\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#if _LIBCPP_STD_VER > 11\n    basic_ostream& operator=(const basic_ostream&) = delete;\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    void swap(basic_ostream& __rhs);\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&));\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type __pos);\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)\n{\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type,traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 (char*)&__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (char*)&__c + 1 :\n                                     (char*)&__c,\n                                 (char*)&__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 (char*)&__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (char*)&__c + 1 :\n                                     (char*)&__c,\n                                 (char*)&__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = _Traits::length(__str);\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length(__str);\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length((const char*)__str);\n            if (__pad_and_output(_Ip(__os),\n                                 (const char*)__str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (const char*)__str + __len :\n                                     (const char*)__str,\n                                 (const char*)__str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length((const char*)__str);\n            if (__pad_and_output(_Ip(__os),\n                                 (const char*)__str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (const char*)__str + __len :\n                                     (const char*)__str,\n                                 (const char*)__str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = __str.size();\n            if (__pad_and_output(_Ip(__os),\n                                 __str.data(),\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str.data() + __len :\n                                     __str.data(),\n                                 __str.data() + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#ifdef _LIBCPP_DEBUG\n#   include <__debug>\n#else\n#   define _LIBCPP_ASSERT(x, m) ((void)0)\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct ____iterator_traits {};\n\ntemplate <class _Iter>\nstruct ____iterator_traits<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  ____iterator_traits\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {__t = current; return *--__t;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(&__x) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(&__x) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(&__x), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;\n    typedef typename traits::pos_type pos_type;\n    typedef typename traits::off_type off_type;\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if __has_feature(cxx_atomic)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_TYPE_VIS failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    typedef iostate      io_state;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    typedef openmode     open_mode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n    typedef seekdir seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n#if __has_feature(cxx_atomic) && !defined(__EMSCRIPTEN__)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif _AIX\n# include <support/ibm/xlocale.h>\n#elif (defined(__GLIBC__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__sun__)) || defined(__EMSCRIPTEN__) || defined(__IBMCPP__)\n# include <xlocale.h>\n#endif  // _WIN32 || __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!_VSTD::has_facet<_Facet>(__other))\n        throw runtime_error(\"locale::combine: locale missing facet\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#ifdef __GLIBC__\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_WIN32)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n#ifdef __APPLE__\n    typedef __uint32_t mask;\n#elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n#elif defined(__EMSCRIPTEN__) ||  defined(__NetBSD__)\n    typedef unsigned short mask;\n#endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#else  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__ || __EMSCRIPTEN__ || __sun__\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TYPE_VIS_ONLY codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class charT> class _LIBCPP_TYPE_VIS_ONLY numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===------------------------- fstream ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FSTREAM\n#define _LIBCPP_FSTREAM\n\n/*\n    fstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_filebuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n    basic_filebuf(basic_filebuf&& rhs);\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n    basic_filebuf& operator=(basic_filebuf&& rhs);\n    void swap(basic_filebuf& rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* s, ios_base::openmode mode);\n    basic_filebuf* open(const string& s, ios_base::openmode mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual streamsize showmanyc();\n    virtual int_type underflow();\n    virtual int_type uflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& loc);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_filebuf<charT, traits>& x, basic_filebuf<charT, traits>& y);\n\ntypedef basic_filebuf<char>    filebuf;\ntypedef basic_filebuf<wchar_t> wfilebuf;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ifstream\n    : public basic_istream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* s, ios_base::openmode mode = ios_base::in);\n    explicit basic_ifstream(const string& s, ios_base::openmode mode = ios_base::in);\n    basic_ifstream(basic_ifstream&& rhs);\n\n    basic_ifstream& operator=(basic_ifstream&& rhs);\n    void swap(basic_ifstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in);\n    void open(const string& s, ios_base::openmode mode = ios_base::in);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ifstream<charT, traits>& x, basic_ifstream<charT, traits>& y);\n\ntypedef basic_ifstream<char>    ifstream;\ntypedef basic_ifstream<wchar_t> wifstream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ofstream\n    : public basic_ostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* s, ios_base::openmode mode = ios_base::out);\n    explicit basic_ofstream(const string& s, ios_base::openmode mode = ios_base::out);\n    basic_ofstream(basic_ofstream&& rhs);\n\n    basic_ofstream& operator=(basic_ofstream&& rhs);\n    void swap(basic_ofstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_ofstream<charT, traits>& x, basic_ofstream<charT, traits>& y);\n\ntypedef basic_ofstream<char>    ofstream;\ntypedef basic_ofstream<wchar_t> wofstream;\n\ntemplate <class charT, class traits=char_traits<charT> >\nclass basic_fstream\n    : public basic_iostream<charT,traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    explicit basic_fstream(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    basic_fstream(basic_fstream&& rhs);\n\n    basic_fstream& operator=(basic_fstream&& rhs);\n    void swap(basic_fstream& rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void open(const string& s, ios_base::openmode mode = ios_base::in|ios_base::out);\n    void close();\n};\n\ntemplate <class charT, class traits>\n  void swap(basic_fstream<charT, traits>& x, basic_fstream<charT, traits>& y);\n\ntypedef basic_fstream<char>    fstream;\ntypedef basic_fstream<wchar_t> wfstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <__locale>\n#include <cstdio>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_filebuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                           char_type;\n    typedef _Traits                          traits_type;\n    typedef typename traits_type::int_type   int_type;\n    typedef typename traits_type::pos_type   pos_type;\n    typedef typename traits_type::off_type   off_type;\n    typedef typename traits_type::state_type state_type;\n\n    // 27.9.1.2 Constructors/destructor:\n    basic_filebuf();\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf(basic_filebuf&& __rhs);\n#endif\n    virtual ~basic_filebuf();\n\n    // 27.9.1.3 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_filebuf& operator=(basic_filebuf&& __rhs);\n#endif\n    void swap(basic_filebuf& __rhs);\n\n    // 27.9.1.4 Members:\n    bool is_open() const;\n    basic_filebuf* open(const char* __s, ios_base::openmode __mode);\n    basic_filebuf* open(const string& __s, ios_base::openmode __mode);\n    basic_filebuf* close();\n\nprotected:\n    // 27.9.1.5 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n    virtual void imbue(const locale& __loc);\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    FILE* __file_;\n    const codecvt<char_type, char, state_type>* __cv_;\n    state_type __st_;\n    state_type __st_last_;\n    ios_base::openmode __om_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    bool __read_mode();\n    void __write_mode();\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf()\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __file_(0),\n      __cv_(nullptr),\n      __st_(),\n      __st_last_(),\n      __om_(0),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(false)\n{\n    if (has_facet<codecvt<char_type, char, state_type> >(this->getloc()))\n    {\n        __cv_ = &use_facet<codecvt<char_type, char, state_type> >(this->getloc());\n        __always_noconv_ = __cv_->always_noconv();\n    }\n    setbuf(0, 4096);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::basic_filebuf(basic_filebuf&& __rhs)\n    : basic_streambuf<_CharT, _Traits>(__rhs)\n{\n    if (__rhs.__extbuf_ == __rhs.__extbuf_min_)\n    {\n        __extbuf_ = __extbuf_min_;\n        __extbufnext_ = __extbuf_ + (__rhs.__extbufnext_ - __rhs.__extbuf_);\n        __extbufend_ = __extbuf_ + (__rhs.__extbufend_ - __rhs.__extbuf_);\n    }\n    else\n    {\n        __extbuf_ = __rhs.__extbuf_;\n        __extbufnext_ = __rhs.__extbufnext_;\n        __extbufend_ = __rhs.__extbufend_;\n    }\n    __ebs_ = __rhs.__ebs_;\n    __intbuf_ = __rhs.__intbuf_;\n    __ibs_ = __rhs.__ibs_;\n    __file_ = __rhs.__file_;\n    __cv_ = __rhs.__cv_;\n    __st_ = __rhs.__st_;\n    __st_last_ = __rhs.__st_last_;\n    __om_ = __rhs.__om_;\n    __cm_ = __rhs.__cm_;\n    __owns_eb_ = __rhs.__owns_eb_;\n    __owns_ib_ = __rhs.__owns_ib_;\n    __always_noconv_ = __rhs.__always_noconv_;\n    if (__rhs.pbase())\n    {\n        if (__rhs.pbase() == __rhs.__intbuf_)\n            this->setp(__intbuf_, __intbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        else\n            this->setp((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs. epptr() - __rhs.pbase()));\n        this->pbump(__rhs. pptr() - __rhs.pbase());\n    }\n    else if (__rhs.eback())\n    {\n        if (__rhs.eback() == __rhs.__intbuf_)\n            this->setg(__intbuf_, __intbuf_ + (__rhs.gptr() - __rhs.eback()),\n                                  __intbuf_ + (__rhs.egptr() - __rhs.eback()));\n        else\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + (__rhs.gptr() - __rhs.eback()),\n                       (char_type*)__extbuf_ + (__rhs.egptr() - __rhs.eback()));\n    }\n    __rhs.__extbuf_ = 0;\n    __rhs.__extbufnext_ = 0;\n    __rhs.__extbufend_ = 0;\n    __rhs.__ebs_ = 0;\n    __rhs.__intbuf_ = 0;\n    __rhs.__ibs_ = 0;\n    __rhs.__file_ = 0;\n    __rhs.__st_ = state_type();\n    __rhs.__st_last_ = state_type();\n    __rhs.__om_ = 0;\n    __rhs.__cm_ = 0;\n    __rhs.__owns_eb_ = false;\n    __rhs.__owns_ib_ = false;\n    __rhs.setg(0, 0, 0);\n    __rhs.setp(0, 0);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>&\nbasic_filebuf<_CharT, _Traits>::operator=(basic_filebuf&& __rhs)\n{\n    close();\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>::~basic_filebuf()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        close();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::swap(basic_filebuf& __rhs)\n{\n    basic_streambuf<char_type, traits_type>::swap(__rhs);\n    if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n    {\n        _VSTD::swap(__extbuf_, __rhs.__extbuf_);\n        _VSTD::swap(__extbufnext_, __rhs.__extbufnext_);\n        _VSTD::swap(__extbufend_, __rhs.__extbufend_);\n    }\n    else\n    {\n        ptrdiff_t __ln = __extbufnext_ - __extbuf_;\n        ptrdiff_t __le = __extbufend_ - __extbuf_;\n        ptrdiff_t __rn = __rhs.__extbufnext_ - __rhs.__extbuf_;\n        ptrdiff_t __re = __rhs.__extbufend_ - __rhs.__extbuf_;\n        if (__extbuf_ == __extbuf_min_ && __rhs.__extbuf_ != __rhs.__extbuf_min_)\n        {\n            __extbuf_ = __rhs.__extbuf_;\n            __rhs.__extbuf_ = __rhs.__extbuf_min_;\n        }\n        else if (__extbuf_ != __extbuf_min_ && __rhs.__extbuf_ == __rhs.__extbuf_min_)\n        {\n            __rhs.__extbuf_ = __extbuf_;\n            __extbuf_ = __extbuf_min_;\n        }\n        __extbufnext_ = __extbuf_ + __rn;\n        __extbufend_ = __extbuf_ + __re;\n        __rhs.__extbufnext_ = __rhs.__extbuf_ + __ln;\n        __rhs.__extbufend_ = __rhs.__extbuf_ + __le;\n    }\n    _VSTD::swap(__ebs_, __rhs.__ebs_);\n    _VSTD::swap(__intbuf_, __rhs.__intbuf_);\n    _VSTD::swap(__ibs_, __rhs.__ibs_);\n    _VSTD::swap(__file_, __rhs.__file_);\n    _VSTD::swap(__cv_, __rhs.__cv_);\n    _VSTD::swap(__st_, __rhs.__st_);\n    _VSTD::swap(__st_last_, __rhs.__st_last_);\n    _VSTD::swap(__om_, __rhs.__om_);\n    _VSTD::swap(__cm_, __rhs.__cm_);\n    _VSTD::swap(__owns_eb_, __rhs.__owns_eb_);\n    _VSTD::swap(__owns_ib_, __rhs.__owns_ib_);\n    _VSTD::swap(__always_noconv_, __rhs.__always_noconv_);\n    if (this->eback() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->gptr() - this->eback();\n        ptrdiff_t __e = this->egptr() - this->eback();\n        this->setg((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __n,\n                   (char_type*)__extbuf_min_ + __e);\n    }\n    else if (this->pbase() == (char_type*)__rhs.__extbuf_min_)\n    {\n        ptrdiff_t __n = this->pptr() - this->pbase();\n        ptrdiff_t __e = this->epptr() - this->pbase();\n        this->setp((char_type*)__extbuf_min_,\n                   (char_type*)__extbuf_min_ + __e);\n        this->pbump(__n);\n    }\n    if (__rhs.eback() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.gptr() - __rhs.eback();\n        ptrdiff_t __e = __rhs.egptr() - __rhs.eback();\n        __rhs.setg((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __n,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n    }\n    else if (__rhs.pbase() == (char_type*)__extbuf_min_)\n    {\n        ptrdiff_t __n = __rhs.pptr() - __rhs.pbase();\n        ptrdiff_t __e = __rhs.epptr() - __rhs.pbase();\n        __rhs.setp((char_type*)__rhs.__extbuf_min_,\n                   (char_type*)__rhs.__extbuf_min_ + __e);\n        __rhs.pbump(__n);\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_filebuf<_CharT, _Traits>& __x, basic_filebuf<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_filebuf<_CharT, _Traits>::is_open() const\n{\n    return __file_ != 0;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_ == 0)\n    {\n        __rt = this;\n        const char* __mdstr;\n        switch (__mode & ~ios_base::ate)\n        {\n        case ios_base::out:\n        case ios_base::out | ios_base::trunc:\n            __mdstr = \"w\";\n            break;\n        case ios_base::out | ios_base::app:\n        case ios_base::app:\n            __mdstr = \"a\";\n            break;\n        case ios_base::in:\n            __mdstr = \"r\";\n            break;\n        case ios_base::in | ios_base::out:\n            __mdstr = \"r+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc:\n            __mdstr = \"w+\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app:\n        case ios_base::in | ios_base::app:\n            __mdstr = \"a+\";\n            break;\n        case ios_base::out | ios_base::binary:\n        case ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"wb\";\n            break;\n        case ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::app | ios_base::binary:\n            __mdstr = \"ab\";\n            break;\n        case ios_base::in | ios_base::binary:\n            __mdstr = \"rb\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::binary:\n            __mdstr = \"r+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::trunc | ios_base::binary:\n            __mdstr = \"w+b\";\n            break;\n        case ios_base::in | ios_base::out | ios_base::app | ios_base::binary:\n        case ios_base::in | ios_base::app | ios_base::binary:\n            __mdstr = \"a+b\";\n            break;\n        default:\n            __rt = 0;\n            break;\n        }\n        if (__rt)\n        {\n            __file_ = fopen(__s, __mdstr);\n            if (__file_)\n            {\n                __om_ = __mode;\n                if (__mode & ios_base::ate)\n                {\n                    if (fseek(__file_, 0, SEEK_END))\n                    {\n                        fclose(__file_);\n                        __file_ = 0;\n                        __rt = 0;\n                    }\n                }\n            }\n            else\n                __rt = 0;\n        }\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    return open(__s.c_str(), __mode);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_filebuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::close()\n{\n    basic_filebuf<_CharT, _Traits>* __rt = 0;\n    if (__file_)\n    {\n        __rt = this;\n        unique_ptr<FILE, int(*)(FILE*)> __h(__file_, fclose);\n        if (sync())\n            __rt = 0;\n        if (fclose(__h.release()) == 0)\n            __file_ = 0;\n        else\n            __rt = 0;\n    }\n    return __rt;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::underflow()\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = fread(this->eback() + __unget_sz, 1, __nmemb, __file_);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = traits_type::to_int_type(*this->gptr());\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            size_t __nmemb = _VSTD::min(static_cast<size_t>(__ibs_ - __unget_sz),\n                                 static_cast<size_t>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            __st_last_ = __st_;\n            size_t __nr = fread((void*)__extbufnext_, 1, __nmemb, __file_);\n            if (__nr != 0)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->eback() + __ibs_, __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = traits_type::to_int_type(*this->gptr());\n                }\n            }\n        }\n    }\n    else\n        __c = traits_type::to_int_type(*this->gptr());\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::pbackfail(int_type __c)\n{\n    if (__file_ && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if ((__om_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::int_type\nbasic_filebuf<_CharT, _Traits>::overflow(int_type __c)\n{\n    if (__file_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n            if (fwrite(this->pbase(), sizeof(char_type), __nmemb, __file_) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                if (!__cv_)\n                    throw bad_cast();\n#endif\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    size_t __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (fwrite(this->pbase(), 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_filebuf<_CharT, _Traits>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    int __width = __cv_->encoding();\n    if (__file_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    int __whence;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __whence = SEEK_SET;\n        break;\n    case ios_base::cur:\n        __whence = SEEK_CUR;\n        break;\n    case ios_base::end:\n        __whence = SEEK_END;\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n#if _WIN32\n    if (fseek(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftell(__file_);\n#else\n    if (fseeko(__file_, __width > 0 ? __width * __off : 0, __whence))\n        return pos_type(off_type(-1));\n    pos_type __r = ftello(__file_);\n#endif\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_filebuf<_CharT, _Traits>::pos_type\nbasic_filebuf<_CharT, _Traits>::seekpos(pos_type __sp, ios_base::openmode)\n{\n    if (__file_ == 0 || sync())\n        return pos_type(off_type(-1));\n#if _WIN32\n    if (fseek(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#else\n    if (fseeko(__file_, __sp, SEEK_SET))\n        return pos_type(off_type(-1));\n#endif\n    __st_ = __sp.state();\n    return __sp;\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_filebuf<_CharT, _Traits>::sync()\n{\n    if (__file_ == 0)\n        return 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!__cv_)\n        throw bad_cast();\n#endif\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            size_t __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n            if (fwrite(__extbuf_, 1, __nmemb, __file_) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (fflush(__file_))\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        state_type __state = __st_last_;\n        bool __update_st = false;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    const int __off =  __cv_->length(__state, __extbuf_,\n                                                     __extbufnext_,\n                                                     this->gptr() - this->eback());\n                    __c += __extbufnext_ - __extbuf_ - __off;\n                    __update_st = true;\n                }\n            }\n        }\n#if _WIN32\n        if (fseek(__file_, -__c, SEEK_CUR))\n            return -1;\n#else\n        if (fseeko(__file_, -__c, SEEK_CUR))\n            return -1;\n#endif\n        if (__update_st)\n            __st_ = __state;\n        __extbufnext_ = __extbufend_ = __extbuf_;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    sync();\n    __cv_ = &use_facet<codecvt<char_type, char, state_type> >(__loc);\n    bool __old_anc = __always_noconv_;\n    __always_noconv_ = __cv_->always_noconv();\n    if (__old_anc != __always_noconv_)\n    {\n        this->setg(0, 0, 0);\n        this->setp(0, 0);\n        // invariant, char_type is char, else we couldn't get here\n        if (__always_noconv_)  // need to dump __intbuf_\n        {\n            if (__owns_eb_)\n                delete [] __extbuf_;\n            __owns_eb_ = __owns_ib_;\n            __ebs_ = __ibs_;\n            __extbuf_ = (char*)__intbuf_;\n            __ibs_ = 0;\n            __intbuf_ = 0;\n            __owns_ib_ = false;\n        }\n        else  // need to obtain an __intbuf_.\n        {     // If __extbuf_ is user-supplied, use it, else new __intbuf_\n            if (!__owns_eb_ && __extbuf_ != __extbuf_min_)\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = (char_type*)__extbuf_;\n                __owns_ib_ = false;\n                __extbuf_ = new char[__ebs_];\n                __owns_eb_ = true;\n            }\n            else\n            {\n                __ibs_ = __ebs_;\n                __intbuf_ = new char_type[__ibs_];\n                __owns_ib_ = true;\n            }\n        }\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbool\nbasic_filebuf<_CharT, _Traits>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_filebuf<_CharT, _Traits>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\n// basic_ifstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ifstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ifstream();\n    explicit basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in);\n    explicit basic_ifstream(const string& __s, ios_base::openmode __mode = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ifstream(basic_ifstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ifstream& operator=(basic_ifstream&& __rhs);\n#endif\n    void swap(basic_ifstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream()\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const char* __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(const string& __s, ios_base::openmode __mode)\n    : basic_istream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::in) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>::basic_ifstream(basic_ifstream&& __rhs)\n    : basic_istream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ifstream<_CharT, _Traits>&\nbasic_ifstream<_CharT, _Traits>::operator=(basic_ifstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ifstream<_CharT, _Traits>::swap(basic_ifstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ifstream<_CharT, _Traits>& __x, basic_ifstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_ifstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_ifstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ifstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::in))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ifstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_ofstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ofstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_ofstream();\n    explicit basic_ofstream(const char* __s, ios_base::openmode __mode = ios_base::out);\n    explicit basic_ofstream(const string& __s, ios_base::openmode __mode = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ofstream(basic_ofstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ofstream& operator=(basic_ofstream&& __rhs);\n#endif\n    void swap(basic_ofstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::out);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream()\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const char* __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(const string& __s, ios_base::openmode __mode)\n    : basic_ostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode | ios_base::out) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>::basic_ofstream(basic_ofstream&& __rhs)\n    : basic_ostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ofstream<_CharT, _Traits>&\nbasic_ofstream<_CharT, _Traits>::operator=(basic_ofstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ofstream<_CharT, _Traits>::swap(basic_ofstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ofstream<_CharT, _Traits>& __x, basic_ofstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_ofstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_ofstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_ofstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode | ios_base::out))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ofstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n// basic_fstream\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_fstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    basic_fstream();\n    explicit basic_fstream(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    explicit basic_fstream(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_fstream(basic_fstream&& __rhs);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_fstream& operator=(basic_fstream&& __rhs);\n#endif\n    void swap(basic_fstream& __rhs);\n\n    basic_filebuf<char_type, traits_type>* rdbuf() const;\n    bool is_open() const;\n    void open(const char* __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void open(const string& __s, ios_base::openmode __mode = ios_base::in | ios_base::out);\n    void close();\n\nprivate:\n    basic_filebuf<char_type, traits_type> __sb_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream()\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(const char* __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(const string& __s, ios_base::openmode __mode)\n    : basic_iostream<char_type, traits_type>(&__sb_)\n{\n    if (__sb_.open(__s, __mode) == 0)\n        this->setstate(ios_base::failbit);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>::basic_fstream(basic_fstream&& __rhs)\n    : basic_iostream<char_type, traits_type>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    this->set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_fstream<_CharT, _Traits>&\nbasic_fstream<_CharT, _Traits>::operator=(basic_fstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_fstream<_CharT, _Traits>::swap(basic_fstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_fstream<_CharT, _Traits>& __x, basic_fstream<_CharT, _Traits>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_filebuf<_CharT, _Traits>*\nbasic_fstream<_CharT, _Traits>::rdbuf() const\n{\n    return const_cast<basic_filebuf<char_type, traits_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_fstream<_CharT, _Traits>::is_open() const\n{\n    return __sb_.is_open();\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const char* __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_fstream<_CharT, _Traits>::open(const string& __s, ios_base::openmode __mode)\n{\n    if (__sb_.open(__s, __mode))\n        this->clear();\n    else\n        this->setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_fstream<_CharT, _Traits>::close()\n{\n    if (__sb_.close() == 0)\n        this->setstate(ios_base::failbit);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FSTREAM\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#else // _LIBCPP_MSVCRT\n#include <nl_types.h>\n#endif  // !_LIBCPP_MSVCRT\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n#ifndef _LIBCPP_LOCALE__L_EXTENSIONS\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&uselocale)> __locale_raii;\n#endif\n\n// OSX has nice foo_l() functions that let you turn off use of the global\n// locale.  Linux, not so much.  The following functions avoid the locale when\n// that's possible and otherwise do the wrong thing.  FIXME.\n#if defined(__linux__) || defined(__EMSCRIPTEN__) || defined(_AIX)\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\ndecltype(MB_CUR_MAX_L(_VSTD::declval<locale_t>()))\ninline _LIBCPP_INLINE_VISIBILITY\n__mb_cur_max_l(locale_t __l)\n{\n  return MB_CUR_MAX_L(__l);\n}\n#else  // _LIBCPP_LOCALE__L_EXTENSIONS\ninline _LIBCPP_ALWAYS_INLINE\ndecltype(MB_CUR_MAX) __mb_cur_max_l(locale_t __l)\n{\n  __locale_raii __current(uselocale(__l), uselocale);\n  return MB_CUR_MAX;\n}\n#endif // _LIBCPP_LOCALE__L_EXTENSIONS\n\ninline _LIBCPP_ALWAYS_INLINE\nwint_t __btowc_l(int __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return btowc_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return btowc(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __wctob_l(wint_t __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wctob_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wctob(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcsnrtombs_l(__dest, __src, __nwc, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcrtomb_l(__s, __wc, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcrtomb(__s, __wc, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsnrtowcs_l(__dest, __src, __nms, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,\n                   mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrtowc_l(__pwc, __s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrtowc(__pwc, __s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbtowc_l(__pwc, __pmb, __max, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbtowc(__pwc, __pmb, __max);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrlen_l(__s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrlen(__s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nlconv *__localeconv_l(locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return localeconv_l(__l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return localeconv();\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,\n                     mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsrtowcs_l(__dest, __src, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsrtowcs(__dest, __src, __len, __ps);\n#endif\n}\n\ninline\nint __snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsnprintf_l(__s, __n, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsnprintf(__s, __n, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __asprintf_l(char **__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vasprintf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vasprintf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsscanf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsscanf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\n#endif  // __linux__\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_senstive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long double __ld = strtold_l(__a, &__p2, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return static_cast<_Tp>(__ld);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __a[sizeof(__a)-1] = 0;\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    if (sscanf_l(__a, _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n#else\n    if (__sscanf_l(__a, __cloc(), \"%p\", &__v) != 1)\n#endif\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primatives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primatives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __n = static_cast<size_t>(asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n#else\n        __n = __asprintf_l(&__bb, __cloc(), \"%.0Lf\", __units);\n#endif\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _WIN32\n    return -1;\n#else // _WIN32\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _WIN32\n    return __dflt;\n#else // _WIN32\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#if !defined(_WIN32)\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // !_WIN32\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TYPE_VIS_ONLY wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__wide_err_string_.empty())\n        throw range_error(\"wstring_convert: from_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__byte_err_string_.empty())\n        throw range_error(\"wstring_convert: to_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TYPE_VIS_ONLY wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    switch (__way)\n    {\n    case ios_base::beg:\n        break;\n    case ios_base::cur:\n        break;\n    case ios_base::end:\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* __s, streamsize __n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type __c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type __c);\n    streamsize sputn(const char_type* __s, streamsize __n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n    void gbump(int __n);\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n    void pbump(int __n);\n    void setp(char_type* __pbeg, char_type* __pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)\n{\n    imbue(__loc);\n    locale __r = __loc_;\n    __loc_ = __loc;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::getloc() const\n{\n    return __loc_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)\n{\n    return setbuf(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,\n                                             ios_base::seekdir __way,\n                                             ios_base::openmode __which)\n{\n    return seekoff(__off, __way, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,\n                                             ios_base::openmode __which)\n{\n    return seekpos(__sp, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_streambuf<_CharT, _Traits>::pubsync()\n{\n    return sync();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::in_avail()\n{\n    if (__ninp_ < __einp_)\n        return static_cast<streamsize>(__einp_ - __ninp_);\n    return showmanyc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::snextc()\n{\n    if (sbumpc() == traits_type::eof())\n        return traits_type::eof();\n    return sgetc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sbumpc()\n{\n    if (__ninp_ == __einp_)\n        return uflow();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sgetc()\n{\n    if (__ninp_ == __einp_)\n        return underflow();\n    return traits_type::to_int_type(*__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)\n{\n    return xsgetn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)\n{\n    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n        return pbackfail(traits_type::to_int_type(__c));\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sungetc()\n{\n    if (__binp_ == __ninp_)\n        return pbackfail();\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputc(char_type __c)\n{\n    if (__nout_ == __eout_)\n        return overflow(traits_type::to_int_type(__c));\n    *__nout_++ = __c;\n    return traits_type::to_int_type(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)\n{\n    return xsputn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::gbump(int __n)\n{\n    __ninp_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,\n                                                          char_type* __gend)\n{\n    __binp_ = __gbeg;\n    __ninp_ = __gnext;\n    __einp_ = __gend;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::pbump(int __n)\n{\n    __nout_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)\n{\n    __bout_ = __nout_ = __pbeg;\n    __eout_ = __pend;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    for (;__i < __n; ++__i, ++__s)\n    {\n        if (__ninp_ < __einp_)\n            *__s = *__ninp_++;\n        else if ((__c = uflow()) != __eof)\n            *__s = traits_type::to_char_type(__c);\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    for (; __i < __n; ++__s, ++__i)\n    {\n        if (__nout_ < __eout_)\n            *__nout_++ = *__s;\n        else if (overflow(traits_type::to_int_type(*__s)) == __eof)\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musdc.cpp\n// Author:      Laurent Pugin\n// Created:     2010\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musdc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <sstream>\n#include <string>\n\n//----------------------------------------------------------------------------\n\n#include \"musdoc.h\"\n\n//----------------------------------------------------------------------------\n// MusFontInfo\n//----------------------------------------------------------------------------\n\nbool MusFontInfo::FromString(const std::string& ss)\n{\n    std::istringstream iss( ss );\n    std::string token;\n\n    getline( iss, token, ';');\n    //\n    //  Ignore the version for now\n    //\n\n    getline( iss, token, ';');\n    pointSize = atoi( token.c_str() );\n\n    getline( iss, token, ';');\n    family = atoi( token.c_str() );\n\n    getline( iss, token, ';');\n    style = atoi( token.c_str() );\n\n    getline( iss, token, ';');\n    weight = atoi( token.c_str() );\n\n    getline( iss, token, ';');\n    underlined = (atoi( token.c_str() ) != 0);\n\n    getline( iss, token, ';');\n    faceName = token;\n#ifndef __WXMAC__\n    if( faceName.empty() )\n        return false;\n#endif\n\n    getline( iss, token, ';');\n    encoding = atoi( token.c_str() );;\n\n    return true;\n}\n\nstd::string MusFontInfo::ToString() const\n{\n    std::string s = Mus::StringFormat( \"%d;%d;%d;%d;%d;%d;%s;%d\",\n             0,                                 // version\n             pointSize,\n             family,\n             style,\n             weight,\n             underlined,\n             faceName.c_str(),\n             encoding);\n\n    return s;\n}\n\n\n","// -*- C++ -*-\n//===--------------------------- istream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ISTREAM\n#define _LIBCPP_ISTREAM\n\n/*\n    istream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_istream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream(basic_istream&& rhs);\n    virtual ~basic_istream();\n\n    // 27.7.1.1.2 Assign/swap:\n    basic_istream& operator=(basic_istream&& rhs);\n    void swap(basic_istream& rhs);\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* sb);\n    basic_istream& operator>>(bool& n);\n    basic_istream& operator>>(short& n);\n    basic_istream& operator>>(unsigned short& n);\n    basic_istream& operator>>(int& n);\n    basic_istream& operator>>(unsigned int& n);\n    basic_istream& operator>>(long& n);\n    basic_istream& operator>>(unsigned long& n);\n    basic_istream& operator>>(long long& n);\n    basic_istream& operator>>(unsigned long long& n);\n    basic_istream& operator>>(float& f);\n    basic_istream& operator>>(double& f);\n    basic_istream& operator>>(long double& f);\n    basic_istream& operator>>(void*& p);\n\n    // 27.7.1.3 Unformatted input:\n    streamsize gcount() const;\n    int_type get();\n    basic_istream& get(char_type& c);\n    basic_istream& get(char_type* s, streamsize n);\n    basic_istream& get(char_type* s, streamsize n, char_type delim);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb);\n    basic_istream& get(basic_streambuf<char_type,traits_type>& sb, char_type delim);\n\n    basic_istream& getline(char_type* s, streamsize n);\n    basic_istream& getline(char_type* s, streamsize n, char_type delim);\n\n    basic_istream& ignore(streamsize n = 1, int_type delim = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* s, streamsize n);\n    streamsize readsome(char_type* s, streamsize n);\n\n    basic_istream& putback(char_type c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type);\n    basic_istream& seekg(off_type, ios_base::seekdir);\n};\n\n// 27.7.1.2.3 character extraction templates:\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char&);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char&);\n\ntemplate<class charT, class traits>\n  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&, charT*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, unsigned char*);\n\ntemplate<class traits>\n  basic_istream<char,traits>& operator>>(basic_istream<char,traits>&, signed char*);\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_istream<charT, traits>& x, basic_istream<charT, traits>& y);\n\ntypedef basic_istream<char> istream;\ntypedef basic_istream<wchar_t> wistream;\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_iostream :\n    public basic_istream<charT,traits>,\n    public basic_ostream<charT,traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* sb);\n    basic_iostream(basic_iostream&& rhs);\n    virtual ~basic_iostream();\n\n    // assign/swap\n    basic_iostream& operator=(basic_iostream&& rhs);\n    void swap(basic_iostream& rhs);\n};\n\ntemplate <class charT, class traits>\n  void\n  swap(basic_iostream<charT, traits>& x, basic_iostream<charT, traits>& y);\n\ntypedef basic_iostream<char> iostream;\ntypedef basic_iostream<wchar_t> wiostream;\n\ntemplate <class charT, class traits>\n  basic_istream<charT,traits>&\n  ws(basic_istream<charT,traits>& is);\n\ntemplate <class charT, class traits, class T>\n  basic_istream<charT, traits>&\n  operator>>(basic_istream<charT, traits>&& is, T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_istream\n    : virtual public basic_ios<_CharT, _Traits>\n{\n    streamsize __gc_;\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.1.1.1 Constructor/destructor:\n    explicit basic_istream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_istream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream(basic_istream&& __rhs);\n#endif\n\n    // 27.7.1.1.2 Assign/swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream& operator=(basic_istream&& __rhs);\n#endif\n    void swap(basic_istream& __rhs);\npublic:\n\n    // 27.7.1.1.3 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.1.2 Formatted input:\n    basic_istream& operator>>(basic_istream& (*__pf)(basic_istream&));\n    basic_istream& operator>>(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type, traits_type>&));\n    basic_istream& operator>>(ios_base& (*__pf)(ios_base&));\n    basic_istream& operator>>(basic_streambuf<char_type, traits_type>* __sb);\n    basic_istream& operator>>(bool& __n);\n    basic_istream& operator>>(short& __n);\n    basic_istream& operator>>(unsigned short& __n);\n    basic_istream& operator>>(int& __n);\n    basic_istream& operator>>(unsigned int& __n);\n    basic_istream& operator>>(long& __n);\n    basic_istream& operator>>(unsigned long& __n);\n    basic_istream& operator>>(long long& __n);\n    basic_istream& operator>>(unsigned long long& __n);\n    basic_istream& operator>>(float& __f);\n    basic_istream& operator>>(double& __f);\n    basic_istream& operator>>(long double& __f);\n    basic_istream& operator>>(void*& __p);\n\n    // 27.7.1.3 Unformatted input:\n    _LIBCPP_INLINE_VISIBILITY\n    streamsize gcount() const {return __gc_;}\n    int_type get();\n    basic_istream& get(char_type& __c);\n    basic_istream& get(char_type* __s, streamsize __n);\n    basic_istream& get(char_type* __s, streamsize __n, char_type __dlm);\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb);\n    basic_istream& get(basic_streambuf<char_type, traits_type>& __sb, char_type __dlm);\n\n    basic_istream& getline(char_type* __s, streamsize __n);\n    basic_istream& getline(char_type* __s, streamsize __n, char_type __dlm);\n\n    basic_istream& ignore(streamsize __n = 1, int_type __dlm = traits_type::eof());\n    int_type peek();\n    basic_istream& read (char_type* __s, streamsize __n);\n    streamsize readsome(char_type* __s, streamsize __n);\n\n    basic_istream& putback(char_type __c);\n    basic_istream& unget();\n    int sync();\n\n    pos_type tellg();\n    basic_istream& seekg(pos_type __pos);\n    basic_istream& seekg(off_type __off, ios_base::seekdir __dir);\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_istream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n//    ~sentry() = default;\n\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits>& __is,\n                                               bool __noskipws)\n    : __ok_(false)\n{\n    if (__is.good())\n    {\n        if (__is.tie())\n            __is.tie()->flush();\n        if (!__noskipws && (__is.flags() & ios_base::skipws))\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            _Ip __i(__is);\n            _Ip __eof;\n            for (; __i != __eof; ++__i)\n                if (!__ct.is(__ct.space, *__i))\n                    break;\n            if (__i == __eof)\n                __is.setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        __ok_ = __is.good();\n    }\n    else\n        __is.setstate(ios_base::failbit);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>::basic_istream(basic_streambuf<char_type, traits_type>* __sb)\n    : __gc_(0)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>::basic_istream(basic_istream&& __rhs)\n    : __gc_(__rhs.__gc_)\n{\n    __rhs.__gc_ = 0;\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator=(basic_istream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>::~basic_istream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istream<_CharT, _Traits>::swap(basic_istream& __rhs)\n{\n    _VSTD::swap(__gc_, __rhs.__gc_);\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(unsigned long long& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(float& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(long double& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(bool& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(void*& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(short& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<short>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::min();\n            }\n            else if (__temp > numeric_limits<short>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<short>::max();\n            }\n            else\n                __n = static_cast<short>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(int& __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef istreambuf_iterator<char_type, traits_type> _Ip;\n            typedef num_get<char_type, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            long __temp;\n            use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __temp);\n            if (__temp < numeric_limits<int>::min())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::min();\n            }\n            else if (__temp > numeric_limits<int>::max())\n            {\n                __err |= ios_base::failbit;\n                __n = numeric_limits<int>::max();\n            }\n            else\n                __n = static_cast<int>(__temp);\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_istream& (*__pf)(basic_istream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type, traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT* __s)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n-1)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                *__s++ = __ch;\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            *__s = _CharT();\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char* __s)\n{\n    return __is >> (char*)__s;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, _CharT& __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n            if (_Traits::eq_int_type(__i, _Traits::eof()))\n                __is.setstate(ios_base::eofbit | ios_base::failbit);\n            else\n                __c = _Traits::to_char_type(__i);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, unsigned char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<char, _Traits>&\noperator>>(basic_istream<char, _Traits>& __is, signed char& __c)\n{\n    return __is >> (char&)__c;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::operator>>(basic_streambuf<char_type, traits_type>* __sb)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    ios_base::iostate __err = ios_base::goodbit;\n                    while (true)\n                    {\n                        typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                        if (traits_type::eq_int_type(__i, _Traits::eof()))\n                        {\n                           __err |= ios_base::eofbit;\n                           break;\n                        }\n                        if (traits_type::eq_int_type(\n                                __sb->sputc(traits_type::to_char_type(__i)),\n                                traits_type::eof()))\n                            break;\n                        ++__gc_;\n                        this->rdbuf()->sbumpc();\n                    }\n                    if (__gc_ == 0)\n                       __err |= ios_base::failbit;\n                    this->setstate(__err);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    if (__gc_ == 0)\n                        this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::get()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this, true);\n        if (__s)\n        {\n            __r = this->rdbuf()->sbumpc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n               this->setstate(ios_base::failbit | ios_base::eofbit);\n            else\n                __gc_ = 1;\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type& __c)\n{\n    int_type __ch = get();\n    if (__ch != traits_type::eof())\n        __c = traits_type::to_char_type(__ch);\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (__n > 0)\n            {\n                ios_base::iostate __err = ios_base::goodbit;\n                while (__gc_ < __n-1)\n                {\n                    int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    *__s++ = __ch;\n                    ++__gc_;\n                     this->rdbuf()->sbumpc();\n                }\n                *__s = char_type();\n                if (__gc_ == 0)\n                   __err |= ios_base::failbit;\n                this->setstate(__err);\n            }\n            else\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(char_type* __s, streamsize __n)\n{\n    return get(__s, __n, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb,\n                                    char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    char_type __ch = traits_type::to_char_type(__i);\n                    if (traits_type::eq(__ch, __dlm))\n                        break;\n                    if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))\n                        break;\n                    ++__gc_;\n                    this->rdbuf()->sbumpc();\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::get(basic_streambuf<char_type, traits_type>& __sb)\n{\n    return get(__sb, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n, char_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            while (true)\n            {\n                typename traits_type::int_type __i = this->rdbuf()->sgetc();\n                if (traits_type::eq_int_type(__i, traits_type::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                char_type __ch = traits_type::to_char_type(__i);\n                if (traits_type::eq(__ch, __dlm))\n                {\n                    this->rdbuf()->sbumpc();\n                    ++__gc_;\n                    break;\n                }\n                if (__gc_ >= __n-1)\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n                *__s++ = __ch;\n                this->rdbuf()->sbumpc();\n                ++__gc_;\n            }\n            if (__n > 0)\n                *__s = char_type();\n            if (__gc_ == 0)\n               __err |= ios_base::failbit;\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::getline(char_type* __s, streamsize __n)\n{\n    return getline(__s, __n, this->widen('\\n'));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            ios_base::iostate __err = ios_base::goodbit;\n            if (__n == numeric_limits<streamsize>::max())\n            {\n                while (true)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            else\n            {\n                while (__gc_ < __n)\n                {\n                    typename traits_type::int_type __i = this->rdbuf()->sbumpc();\n                    if (traits_type::eq_int_type(__i, traits_type::eof()))\n                    {\n                       __err |= ios_base::eofbit;\n                       break;\n                    }\n                    ++__gc_;\n                    if (traits_type::eq_int_type(__i, __dlm))\n                        break;\n                }\n            }\n            this->setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::int_type\nbasic_istream<_CharT, _Traits>::peek()\n{\n    __gc_ = 0;\n    int_type __r = traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __r = this->rdbuf()->sgetc();\n            if (traits_type::eq_int_type(__r, traits_type::eof()))\n                this->setstate(ios_base::eofbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::read(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            __gc_ = this->rdbuf()->sgetn(__s, __n);\n            if (__gc_ != __n)\n                this->setstate(ios_base::failbit | ios_base::eofbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nstreamsize\nbasic_istream<_CharT, _Traits>::readsome(char_type* __s, streamsize __n)\n{\n    __gc_ = 0;\n    streamsize __c = this->rdbuf()->in_avail();\n    switch (__c)\n    {\n    case -1:\n        this->setstate(ios_base::eofbit);\n        break;\n    case 0:\n        break;\n    default:\n        read(__s, _VSTD::min(__c, __n));\n        break;\n    }\n    return __gc_;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::putback(char_type __c)\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sputbackc(__c) == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::unget()\n{\n    __gc_ = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())\n                this->setstate(ios_base::badbit);\n        }\n        else\n            this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nint\nbasic_istream<_CharT, _Traits>::sync()\n{\n    int __r = 0;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf() == 0)\n                return -1;\n            if (this->rdbuf()->pubsync() == -1)\n            {\n                this->setstate(ios_base::badbit);\n                return -1;\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\ntypename basic_istream<_CharT, _Traits>::pos_type\nbasic_istream<_CharT, _Traits>::tellg()\n{\n    pos_type __r(-1);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n            __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(pos_type __pos)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        this->clear(this->rdstate() & ~ios_base::eofbit);\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nbasic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this, true);\n        if (__sen)\n        {\n            if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))\n                this->setstate(ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\nws(basic_istream<_CharT, _Traits>& __is)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __is.setstate(ios_base::eofbit);\n                   break;\n                }\n                if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))\n                    break;\n                __is.rdbuf()->sbumpc();\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)\n{\n    __is >> __x;\n    return __is;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_iostream\n    : public basic_istream<_CharT, _Traits>,\n      public basic_ostream<_CharT, _Traits>\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // constructor/destructor\n    explicit basic_iostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_iostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_iostream(basic_iostream&& __rhs);\n#endif\n\n    // assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_iostream& operator=(basic_iostream&& __rhs);\n#endif\n    void swap(basic_iostream& __rhs);\npublic:\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_streambuf<char_type, traits_type>* __sb)\n    : basic_istream<_CharT, _Traits>(__sb)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs))\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_iostream<_CharT, _Traits>&\nbasic_iostream<_CharT, _Traits>::operator=(basic_iostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_iostream<_CharT, _Traits>::~basic_iostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_iostream<_CharT, _Traits>::swap(basic_iostream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            __str.clear();\n            streamsize __n = __is.width();\n            if (__n <= 0)\n                __n = __str.max_size();\n            if (__n <= 0)\n                __n = numeric_limits<streamsize>::max();\n            streamsize __c = 0;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            ios_base::iostate __err = ios_base::goodbit;\n            while (__c < __n)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (__ct.is(__ct.space, __ch))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __is.width(0);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);\n        if (__sen)\n        {\n            __str.clear();\n            ios_base::iostate __err = ios_base::goodbit;\n            streamsize __extr = 0;\n            while (true)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sbumpc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                ++__extr;\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (_Traits::eq(__ch, __dlm))\n                    break;\n                __str.push_back(__ch);\n                if (__str.size() == __str.max_size())\n                {\n                    __err |= ios_base::failbit;\n                    break;\n                }\n            }\n            if (__extr == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm)\n{\n    return getline(__is, __str, __dlm);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return getline(__is, __str, __is.widen('\\n'));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __sen(__is);\n        if (__sen)\n        {\n            basic_string<_CharT, _Traits> __str;\n            const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__is.getloc());\n            streamsize __c = 0;\n            ios_base::iostate __err = ios_base::goodbit;\n            _CharT __zero = __ct.widen('0');\n            _CharT __one = __ct.widen('1');\n            while (__c < _Size)\n            {\n                typename _Traits::int_type __i = __is.rdbuf()->sgetc();\n                if (_Traits::eq_int_type(__i, _Traits::eof()))\n                {\n                   __err |= ios_base::eofbit;\n                   break;\n                }\n                _CharT __ch = _Traits::to_char_type(__i);\n                if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))\n                    break;\n                __str.push_back(__ch);\n                ++__c;\n                 __is.rdbuf()->sbumpc();\n            }\n            __x = bitset<_Size>(__str);\n            if (__c == 0)\n               __err |= ios_base::failbit;\n            __is.setstate(__err);\n        }\n        else\n            __is.setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_istream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_istream<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_iostream<char>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ISTREAM\n","// -*- C++ -*-\n//===--------------------------- sstream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SSTREAM\n#define _LIBCPP_SSTREAM\n\n/*\n    sstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringbuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const basic_string<char_type, traits_type, allocator_type>& str,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    basic_stringbuf(basic_stringbuf&& rhs);\n\n    // 27.8.1.2 Assign and swap:\n    basic_stringbuf& operator=(basic_stringbuf&& rhs);\n    void swap(basic_stringbuf& rhs);\n\n    // 27.8.1.3 Get and set:\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type*, streamsize);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringbuf<charT, traits, Allocator>& x,\n            basic_stringbuf<charT, traits, Allocator>& y);\n\ntypedef basic_stringbuf<char>    stringbuf;\ntypedef basic_stringbuf<wchar_t> wstringbuf;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_istringstream\n    : public basic_istream<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode which = ios_base::in);\n    explicit basic_istringstream(const basic_string<char_type, traits_type,allocator_type>& str,\n                                 ios_base::openmode which = ios_base::in);\n    basic_istringstream(basic_istringstream&& rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& rhs);\n    void swap(basic_istringstream& rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_istringstream<charT, traits, Allocator>& x,\n            basic_istringstream<charT, traits, Allocator>& y);\n\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_istringstream<wchar_t> wistringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_ostringstream\n    : public basic_ostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.3.1 Constructors/destructor:\n    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);\n    explicit basic_ostringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                 ios_base::openmode which = ios_base::out);\n    basic_ostringstream(basic_ostringstream&& rhs);\n\n    // 27.8.3.2 Assign/swap:\n    basic_ostringstream& operator=(basic_ostringstream&& rhs);\n    void swap(basic_ostringstream& rhs);\n\n    // 27.8.3.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_ostringstream<charT, traits, Allocator>& x,\n            basic_ostringstream<charT, traits, Allocator>& y);\n\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringstream\n    : public basic_iostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // constructors/destructor\n    explicit basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in);\n    explicit basic_stringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                ios_base::openmode which = ios_base::out|ios_base::in);\n    basic_stringstream(basic_stringstream&& rhs);\n\n    // 27.8.5.1 Assign/swap:\n    basic_stringstream& operator=(basic_stringstream&& rhs);\n    void swap(basic_stringstream& rhs);\n\n    // Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& str);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringstream<charT, traits, Allocator>& x,\n            basic_stringstream<charT, traits, Allocator>& y);\n\ntypedef basic_stringstream<char>    stringstream;\ntypedef basic_stringstream<wchar_t> wstringstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <string>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// basic_stringbuf\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_stringbuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n\n    string_type __str_;\n    mutable char_type* __hm_;\n    ios_base::openmode __mode_;\n\npublic:\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf(basic_stringbuf&& __rhs);\n#endif\n\n    // 27.8.1.2 Assign and swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf& operator=(basic_stringbuf&& __rhs);\n#endif\n    void swap(basic_stringbuf& __rhs);\n\n    // 27.8.1.3 Get and set:\n    string_type str() const;\n    void str(const string_type& __s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(string_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(__s);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)\n    : __mode_(__rhs.__mode_)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>&\nbasic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __mode_ = __rhs.__mode_;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __rbinp = -1;\n    ptrdiff_t __rninp = -1;\n    ptrdiff_t __reinp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __rbinp = __rhs.eback() - __p;\n        __rninp = __rhs.gptr() - __p;\n        __reinp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __rbout = -1;\n    ptrdiff_t __rnout = -1;\n    ptrdiff_t __reout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __rbout = __rhs.pbase() - __p;\n        __rnout = __rhs.pptr() - __p;\n        __reout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __p = const_cast<char_type*>(__str_.data());\n    ptrdiff_t __lbinp = -1;\n    ptrdiff_t __lninp = -1;\n    ptrdiff_t __leinp = -1;\n    if (this->eback() != nullptr)\n    {\n        __lbinp = this->eback() - __p;\n        __lninp = this->gptr() - __p;\n        __leinp = this->egptr() - __p;\n    }\n    ptrdiff_t __lbout = -1;\n    ptrdiff_t __lnout = -1;\n    ptrdiff_t __leout = -1;\n    if (this->pbase() != nullptr)\n    {\n        __lbout = this->pbase() - __p;\n        __lnout = this->pptr() - __p;\n        __leout = this->epptr() - __p;\n    }\n    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;\n    _VSTD::swap(__mode_, __rhs.__mode_);\n    __str_.swap(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__rbinp != -1)\n        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__rbout != -1)\n    {\n        this->setp(__p + __rbout, __p + __reout);\n        this->pbump(__rnout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    if (__lbinp != -1)\n        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);\n    else\n        __rhs.setg(nullptr, nullptr, nullptr);\n    if (__lbout != -1)\n    {\n        __rhs.setp(__p + __lbout, __p + __leout);\n        __rhs.pbump(__lnout);\n    }\n    else\n        __rhs.setp(nullptr, nullptr);\n    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;\n    locale __tl = __rhs.getloc();\n    __rhs.pubimbue(this->getloc());\n    this->pubimbue(__tl);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str() const\n{\n    if (__mode_ & ios_base::out)\n    {\n        if (__hm_ < this->pptr())\n            __hm_ = this->pptr();\n        return string_type(this->pbase(), __hm_, __str_.get_allocator());\n    }\n    else if (__mode_ & ios_base::in)\n        return string_type(this->eback(), this->egptr(), __str_.get_allocator());\n    return string_type(__str_.get_allocator());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __str_ = __s;\n    __hm_ = 0;\n    if (__mode_ & ios_base::in)\n    {\n        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();\n        this->setg(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()),\n                   __hm_);\n    }\n    if (__mode_ & ios_base::out)\n    {\n        typename string_type::size_type __sz = __str_.size();\n        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;\n        __str_.resize(__str_.capacity());\n        this->setp(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()) + __str_.size());\n        if (__mode_ & (ios_base::app | ios_base::ate))\n            this->pbump(__sz);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::underflow()\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (__mode_ & ios_base::in)\n    {\n        if (this->egptr() < __hm_)\n            this->setg(this->eback(), this->gptr(), __hm_);\n        if (this->gptr() < this->egptr())\n            return traits_type::to_int_type(*this->gptr());\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            return traits_type::not_eof(__c);\n        }\n        if ((__mode_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)\n{\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        ptrdiff_t __ninp = this->gptr()  - this->eback();\n        if (this->pptr() == this->epptr())\n        {\n            if (!(__mode_ & ios_base::out))\n                return traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                ptrdiff_t __nout = this->pptr()  - this->pbase();\n                ptrdiff_t __hm = __hm_ - this->pbase();\n                __str_.push_back(char_type());\n                __str_.resize(__str_.capacity());\n                char_type* __p = const_cast<char_type*>(__str_.data());\n                this->setp(__p, __p + __str_.size());\n                this->pbump(__nout);\n                __hm_ = this->pbase() + __hm;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                return traits_type::eof();\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        }\n        __hm_ = _VSTD::max(this->pptr() + 1, __hm_);\n        if (__mode_ & ios_base::in)\n        {\n            char_type* __p = const_cast<char_type*>(__str_.data());\n            this->setg(__p, __p + __ninp, __hm_);\n        }\n        return this->sputc(__c);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,\n                                                      ios_base::seekdir __way,\n                                                      ios_base::openmode __wch)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if ((__wch & (ios_base::in | ios_base::out)) == 0)\n        return pos_type(-1);\n    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)\n        && __way == ios_base::cur)\n        return pos_type(-1);\n    off_type __noff;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __noff = 0;\n        break;\n    case ios_base::cur:\n        if (__wch & ios_base::in)\n            __noff = this->gptr() - this->eback();\n        else\n            __noff = this->pptr() - this->pbase();\n        break;\n    case ios_base::end:\n        __noff = __hm_ - __str_.data();\n        break;\n    default:\n        return pos_type(-1);\n    }\n    __noff += __off;\n    if (__noff < 0 || __hm_ - __str_.data() < __noff)\n        return pos_type(-1);\n    if (__noff != 0)\n    {\n        if ((__wch & ios_base::in) && this->gptr() == 0)\n            return pos_type(-1);\n        if ((__wch & ios_base::out) && this->pptr() == 0)\n            return pos_type(-1);\n    }\n    if (__wch & ios_base::in)\n        this->setg(this->eback(), this->eback() + __noff, __hm_);\n    if (__wch & ios_base::out)\n    {\n        this->setp(this->pbase(), this->epptr());\n        this->pbump(__noff);\n    }\n    return pos_type(__noff);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,\n                                                      ios_base::openmode __wch)\n{\n    return seekoff(__sp, ios_base::beg, __wch);\n}\n\n// basic_istringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_istringstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);\n    explicit basic_istringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_istringstream(basic_istringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_istringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::in)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::in)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>&\nbasic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_ostringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostringstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);\n    explicit basic_ostringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ostringstream(basic_ostringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_ostringstream& operator=(basic_ostringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_ostringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::out)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::out)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)\n    : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>&\nbasic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_stringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_stringstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringstream(const string_type& __s,\n                                ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringstream(basic_stringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_stringstream& operator=(basic_stringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_stringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,\n                                                                    ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)\n    : basic_iostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>&\nbasic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SSTREAM\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musdoc.cpp\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musdoc.h\"\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"muslayer.h\"\n#include \"muslayerelement.h\"\n#include \"muspage.h\"\n#include \"musstaff.h\"\n#include \"mussystem.h\"\n\n//----------------------------------------------------------------------------\n\n#include <math.h>\n\n//----------------------------------------------------------------------------\n// MusDoc\n//----------------------------------------------------------------------------\n\nMusDoc::MusDoc() :\n    MusObject(\"doc-\")\n{\n    Reset( Raw );\n}\n\nMusDoc::~MusDoc()\n{\n    \n}\n\nvoid MusDoc::Reset( DocType type )\n{\n    UpdateFontValues();\n    \n    m_type = type;\n    \n    ClearChildren();\n    \n    m_pageWidth = -1;\n    m_pageHeight = -1;\n    m_pageRightMar = 0;\n    m_pageLeftMar = 0;\n    m_pageTopMar = 0;\n    \n    m_rendPage = NULL;\n    \n    m_scoreDef.Clear();\n}\n\nint MusDoc::Save( ArrayPtrVoid params )\n{  \n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];       \n    if (!output->WriteDoc( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n}\n\nvoid MusDoc::AddPage( MusPage *page )\n{\n\tpage->SetParent( this );\n\tm_children.push_back( page );\n    Modify();\n}\n\nvoid MusDoc::Refresh()\n{\n    RefreshViews();\n}\n\nvoid MusDoc::Layout( )\n{\n    MusScoreDef currentScoreDef;\n    currentScoreDef = m_scoreDef;\n    MusStaffDef *staffDef = NULL;\n    ArrayPtrVoid params;\n    params.push_back( &currentScoreDef );\n    params.push_back( &staffDef );\n    MusFunctor setPageScoreDef( &MusObject::SetPageScoreDef );\n    this->Process( &setPageScoreDef, params );\n    \n    int i;\n\tMusPage *page = NULL;\n    for (i = 0; i < this->GetChildCount(); i++)\n\t{\n\t\tpage = (MusPage*)this->m_children[i];\n        page->Layout( );\n        //break;\n     }\n}\n\nvoid MusDoc::SetRendPage( MusPage *page )\n{\n    if ( !page || (page == m_rendPage) ) {\n        return;\n    }\n    m_rendPage = page;\n    \n    // we use the page members only if set (!= -1) \n    if ( page->m_pageHeight != -1 )\n    {\n        m_rendPageHeight = page->m_pageHeight;\n        m_rendPageWidth = page->m_pageWidth;\n        m_rendPageLeftMar = page->m_pageLeftMar;\n        m_rendPageRightMar = page->m_pageRightMar;\n        m_rendPageTopMar = page->m_pageTopMar;\n\t}\n\telse if ( this->m_pageHeight != -1 )\n\t{\n        m_rendPageHeight = this->m_pageHeight;\n        m_rendPageWidth = this->m_pageWidth;\n        m_rendPageLeftMar = this->m_pageLeftMar;\n        m_rendPageRightMar = this->m_pageRightMar;\n        m_rendPageTopMar = this->m_pageTopMar;\n    }\n    else\n    {\n        m_rendPageHeight = m_env.m_pageHeight;\n        m_rendPageWidth = m_env.m_pageWidth;\n        m_rendPageLeftMar = m_env.m_pageLeftMar;\n        m_rendPageRightMar = m_env.m_pageRightMar;\n        m_rendPageTopMar = m_env.m_pageTopMar;\n    }\n    \n    if (this->m_env.m_landscape)\n    {\t\n        int pageHeight = m_rendPageWidth;\n        m_rendPageWidth = m_rendPageHeight;\n        m_rendPageHeight = pageHeight;\n        int pageRightMar = m_rendPageLeftMar;\n        m_rendPageLeftMar = m_rendPageRightMar;\n        m_rendPageRightMar = pageRightMar;\n    }\n    \n    // From here we could check if values have changed\n    // Since  m_env.m_interlDefin stays the same, it useless to do it\n    // every time for now.\n    \n\tm_rendBeamMaxSlope = this->m_env.m_beamMaxSlope;\n\tm_rendBeamMinSlope = this->m_env.m_beamMinSlope;\n\tm_rendBeamMaxSlope /= 100;\n\tm_rendBeamMinSlope /= 100;\n    \n    m_rendSmallStaffRatio[0] = this->m_env.m_smallStaffNum;\n    m_rendSmallStaffRatio[1] = this->m_env.m_smallStaffDen;\n    m_rendGraceRatio[0] = this->m_env.m_graceNum;\n    m_rendGraceRatio[1] = this->m_env.m_graceDen;\n    \n    // half of the space between two lines\n    m_rendHalfInterl[0] = m_env.m_interlDefin/2;\n    // same for small staves\n    m_rendHalfInterl[1] = (m_rendHalfInterl[0] * m_rendSmallStaffRatio[0]) / m_rendSmallStaffRatio[1];\n    // space between two lines\n    m_rendInterl[0] = m_rendHalfInterl[0] * 2;\n    // same for small staves\n    m_rendInterl[1] = m_rendHalfInterl[1] * 2;\n    // staff (with five lines)\n    m_rendStaffSize[0] = m_rendInterl[0] * 4;\n    m_rendStaffSize[1] = m_rendInterl[1] * 4;\n    //\n    m_rendOctaveSize[0] = m_rendHalfInterl[0] * 7;\n    m_rendOctaveSize[1] = m_rendHalfInterl[1] * 7;\n    \n    m_rendStep1 = m_rendHalfInterl[0];\n    m_rendStep2 = m_rendStep1 * 3;\n    m_rendStep3 = m_rendStep1 * 6;\n    \n    // values for beams\n    m_rendBeamWidth[0] = this->m_env.m_beamWidth;\n    m_rendBeamWhiteWidth[0] = this->m_env.m_beamWhiteWidth;\n    m_rendBeamWidth[1] = (m_rendBeamWidth[0] * m_rendSmallStaffRatio[0]) / m_rendSmallStaffRatio[1];\n    m_rendBeamWhiteWidth[1] = (m_rendBeamWhiteWidth[0] * m_rendSmallStaffRatio[0]) / m_rendSmallStaffRatio[1];\n    \n    m_rendFontHeight = CalcLeipzigFontSize();\n    m_rendFontHeightAscent[0][0] = floor(LEIPZIG_ASCENT * (double)m_rendFontHeight / LEIPZIG_UNITS_PER_EM);\n\tm_rendFontHeightAscent[0][0] +=  Mus::GetFontPosCorrection();\n\tm_rendFontHeightAscent[0][1] = (m_rendFontHeightAscent[0][0] * m_rendGraceRatio[0]) / m_rendGraceRatio[1];\n    m_rendFontHeightAscent[1][0] = (m_rendFontHeightAscent[0][0] * m_rendSmallStaffRatio[0]) / m_rendSmallStaffRatio[1];\n\tm_rendFontHeightAscent[1][1] = (m_rendFontHeightAscent[1][0] * m_rendGraceRatio[0]) / m_rendGraceRatio[1];\n    \n    m_rendFontSize[0][0] = m_rendFontHeight;\n    m_rendFontSize[0][1] = (m_rendFontSize[0][0] * m_rendGraceRatio[0]) / m_rendGraceRatio[1];\n    m_rendFontSize[1][0] = (m_rendFontSize[0][0] * m_rendSmallStaffRatio[0]) / m_rendSmallStaffRatio[1];\n    m_rendFontSize[1][1]= (m_rendFontSize[1][0] * m_rendGraceRatio[0])/ m_rendGraceRatio[1];\n    \n\tm_rendFonts[0][0].SetPointSize( m_rendFontSize[0][0] ); //160\n    m_rendFonts[0][1].SetPointSize( m_rendFontSize[0][1] ); //120\n    m_rendFonts[1][0].SetPointSize( m_rendFontSize[1][0] ); //128\n    m_rendFonts[1][1].SetPointSize( m_rendFontSize[1][1] ); //100\n    \n\tm_rendLyricFonts[0].SetPointSize( m_rendLyricFont.GetPointSize() );\n    m_rendLyricFonts[1].SetPointSize( m_rendLyricFont.GetPointSize() );\n    \n    m_rendVerticalUnit1[0] = (float)m_rendInterl[0]/4;\n    m_rendVerticalUnit2[0] = (float)m_rendInterl[0]/8;\n    m_rendVerticalUnit1[1] = (float)m_rendInterl[1]/4;\n    m_rendVerticalUnit2[1] = (float)m_rendInterl[1]/8;\n    \n    float glyph_size;\n    glyph_size = (LEIPZIG_HALF_NOTE_HEAD_WIDTH * (float)m_rendFontHeight / LEIPZIG_UNITS_PER_EM);\n    m_rendNoteRadius[0][0] = ceil(glyph_size / 2);\n    m_rendNoteRadius[0][1] = (m_rendNoteRadius[0][0] * m_rendGraceRatio[0])/m_rendGraceRatio[1];\n    m_rendNoteRadius[1][0] = (m_rendNoteRadius[0][0] * m_rendSmallStaffRatio[0])/m_rendSmallStaffRatio[1];\n    m_rendNoteRadius[1][1] = (m_rendNoteRadius[1][0] * m_rendGraceRatio[0])/m_rendGraceRatio[1];\n    \n    m_rendLedgerLine[0][0] = (int)(glyph_size * .72);\n    m_rendLedgerLine[0][1] = (m_rendLedgerLine[0][0] * m_rendGraceRatio[0])/m_rendGraceRatio[1];\n    m_rendLedgerLine[1][0] = (m_rendLedgerLine[0][0] * m_rendSmallStaffRatio[0])/m_rendSmallStaffRatio[1];\n    m_rendLedgerLine[1][1] = (m_rendLedgerLine[1][0] * m_rendGraceRatio[0])/m_rendGraceRatio[1];\n    \n    glyph_size = round(LEIPZIG_WHOLE_NOTE_HEAD_WIDTH * (double)m_rendFontHeight / LEIPZIG_UNITS_PER_EM);\n    m_rendLedgerLine[0][2] = (int)(glyph_size * .66);\n    m_rendLedgerLine[1][2] = (m_rendLedgerLine[0][2] * m_rendSmallStaffRatio[0]) /m_rendSmallStaffRatio[1];\n    \n    m_rendBrevisWidth[0] = (int)((glyph_size * 0.8) / 2);\n    m_rendBrevisWidth[1] = (m_rendBrevisWidth[0] * m_rendSmallStaffRatio[0]) /m_rendSmallStaffRatio[1];\n    \n    glyph_size = round(LEIPZIG_SHARP_WIDTH * (double)m_rendFontHeight / LEIPZIG_UNITS_PER_EM);\n    m_rendAccidWidth[0][0] = glyph_size;\n    m_rendAccidWidth[0][1] = (m_rendAccidWidth[0][0] * m_rendGraceRatio[0])/m_rendGraceRatio[1];\n    m_rendAccidWidth[1][0] = (m_rendAccidWidth[0][0] * m_rendSmallStaffRatio[0]) /m_rendSmallStaffRatio[1];\n    m_rendAccidWidth[1][1] = (m_rendAccidWidth[1][0] * m_rendGraceRatio[0])/m_rendGraceRatio[1];\n    \n\treturn;\n}\n\nint MusDoc::CalcLeipzigFontSize( )\n{\n    // We just have the Leipzig font for now\n    return round((double)m_env.m_interlDefin * LEIPZIG_UNITS_PER_EM / LEIPZIG_WHOLE_NOTE_HEAD_HEIGHT);\n}\n\nvoid MusDoc::UpdateFontValues() \n{\t\n\tif ( !m_rendLeipzigFont.FromString( Mus::GetMusicFontDescStr() ) )\n        Mus::LogWarning( \"Impossible to load font 'Leipzig'\" );\n\t\n\t//Mus::LogMessage( \"Size %d, Family %d, Style %d, Weight %d, Underline %d, Face %s, Desc %s\",\n\t//\tm_rendLeipzigFont.GetPointSize(),\n\t//\tm_rendLeipzigFont.GetFamily(),\n\t//\tm_rendLeipzigFont.GetStyle(),\n\t//\tm_rendLeipzigFont.GetWeight(),\n\t//\tm_rendLeipzigFont.GetUnderlined(),\n\t//\tm_rendLeipzigFont.GetFaceName().c_str(),\n\t//\tm_rendLeipzigFont.GetNativeFontInfoDesc().c_str());\n    \n\tm_rendFonts[0][0] = m_rendLeipzigFont;\n    m_rendFonts[0][1] = m_rendLeipzigFont;\n    m_rendFonts[1][0] = m_rendLeipzigFont;\n    m_rendFonts[1][1] = m_rendLeipzigFont;\n\t\n\t// Lyrics\n\tif ( !m_rendLyricFont.FromString( Mus::GetLyricFontDescStr() ) )\n\t\tMus::LogWarning( \"Impossible to load font for the lyrics\" );\n    \n\tm_rendLyricFonts[0] = m_rendLyricFont;\n    m_rendLyricFonts[1] = m_rendLyricFont;\n}\n\n\nint MusDoc::Save( MusFileOutputStream *output )\n{\n    ArrayPtrVoid params;\n\tparams.push_back( output );\n\n    MusFunctor save( &MusObject::Save );\n    this->Process( &save, params );\n    \n    return true;\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musdoc.h\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_DOC_H__\n#define __MUS_DOC_H__\n\n#include \"mus.h\"\n#include \"musdc.h\"\n#include \"musdef.h\"\n#include \"musio.h\"\n#include \"musobject.h\"\n#include \"musscoredef.h\"\n\nclass MusPage;\n\nenum DocType {\n    Raw = 0,\n    Rendering,\n    Transcription\n};\n\n\n//----------------------------------------------------------------------------\n// MusDoc\n//----------------------------------------------------------------------------\n\n/** \n * This class is a hold the data and corresponds to the model of a MVC design pattern.\n */\nclass MusDoc: public MusObject\n{\n\npublic:\n    // constructors and destructors\n    MusDoc();\n    virtual ~MusDoc();\n\t\n\tvoid AddPage( MusPage *page );\n    \n    /*\n     * Clear the content of the document.\n     */ \n    void Reset( DocType type );\n    \n    /**\n     * Refreshes the views from MusDoc.\n     */\n    virtual void Refresh();\n    \n    /**\n     * Getter for the DocType.\n     * The setter is MusDoc::Reset.\n     */\n    DocType GetType() { return m_type; };\n    \n    /**\n     * @name Setters for the page dimensions and margins\n     */\n    ///@{\n    void SetPageHeight( int pageHeight ) { m_pageHeight = pageHeight; };\n    void SetPageWidth( int pageWidth ) { m_pageWidth = pageWidth; };\n    void SetPageLeftMar( int pageLeftMar ) { m_pageLeftMar = pageLeftMar; };\n    void SetPageRightMar( int pageRightMar ) { m_pageRightMar = pageRightMar; };\n    void SetPageTopMar( int pageTopMar ) { m_pageTopMar = pageTopMar; };\n    ///@}\n    \n    /**\n     * Saves the document using the specified output stream.\n     * Creates a functors that will parse the full tree.\n     */\n    virtual int Save( MusFileOutputStream *output );\n\n    \n    /**\n     * Performs the layout of the entire document\n     */\n    void Layout( );\n    \n    /**\n     * To be implemented.\n     */\n    void RefreshViews( ) {};\n\t\n\t/**\n     * Set the paper size for the (when drawing it)\n     * By default, the page size of the document is taken.\n     * If a page is given, the size of the page is taken.\n     * calculFormatPapier() in Wolfgang\n     */\n\tvoid SetRendPage( MusPage *page );\n\n    /**\n     * Initializes fonts from the resources (music and lyrics)\n     * The method is called when the doc is reset.\n     */\n\tvirtual void UpdateFontValues();\n        \n    //----------//\n    // Functors //\n    //----------//\n    \n    /**\n     * Functor method for saving the page\n     */\n    virtual int Save( ArrayPtrVoid params );\n    \nprivate:\n    /**\n     * Calculates the Leipzig font size according to the m_interlDefin reference value.\n     * The size is calculated using  LEIPZIG_UNITS_PER_EM and LEIPZIG_WHOLE_NOTE_HEAD_HEIGHT.\n     * See musdef.h for more information about these values.\n     */\n    int CalcLeipzigFontSize( );\n    \npublic:\n    \n\n    /** \n     * The full name of the file. Exact use to be clarified.\n     */\n    std::string m_fname;\n    \n    /**\n     * The object with the default values.\n     * This could be saved somewhere as preferences (todo).\n     */\n    MusEnv m_env;\n    \n    /** \n     * The source id. Exact use to be clarified.\n     */\n    std::string m_source;\n    \n    /**\n     * Holds the top scoreDef.\n     * In a standard MEI file, this is the <scoreDef> encoded before the first <section>.\n     */\n    MusScoreDef m_scoreDef;\n    \n    /*\n     * The following values are set in the MusDoc::SetRenderedPage.\n     * They are all current values to be used when rendering a page in a MusRC and \n     * reset for every page. However, most of them are based on the m_staffDefin values\n     * and will remain the same. This can be optimized.\n     * The pages dimensions and margins are based on the page ones, the document ones or \n     * the default in the following order and if available.\n     */\n  \n    /** The page currently being rendered */\n    MusPage *m_rendPage;\n    /** Editor step (10 by default) */\n    int m_rendStep1;\n    /** Editor medium step (3 * m_rendStep1) */\n    int m_rendStep2;\n    /** Editor large step (6 * m_rendStep1) */\n    int m_rendStep3;\n    /** Half a the space between to staff lines for normal and small staff (10 and 8 by default) */\n    int m_rendHalfInterl[2];\n    /** Space between to staff lines for normal and small staff (20 and 16 by default) */\n    int m_rendInterl[2];\n    /** Height of a five line staff for normal and small staff (80 and 64 by default) */\n    int m_rendStaffSize[2];\n    /** Height of an octave for normal and small staff (70 and 56 by default) */\n    int m_rendOctaveSize[2];\n    /** Font height (100 par defaut) */\n    int m_rendFontHeight;\n    /** Font height with ascent for normal and small staff and normal and grace size */\n\tint m_rendFontHeightAscent[2][2];\n    /** Normal and small staff ration (16 / 20 by default) */\n    int m_rendSmallStaffRatio[2];\n    /** Normal and grace size (3 / 4 by default) */\n    int m_rendGraceRatio[2];\n    /** Height of a beam for normal and small staff (10 and 6 by default) */\n    int m_rendBeamWidth[2];\n    /** Height of a beam spacing (white) for normal and small staff (10 and 6 by default) */\n    int m_rendBeamWhiteWidth[2];\n    /** Current font height with ascent for normal and small staff and normal and grace size */\n    int m_rendFontSize[2][2];\n    /** Note radius for normal and small staff and normal and grace size */\n    int m_rendNoteRadius[2][2];\n    /** Ledger line length for normal and small staff and normal and grace size */\n    int m_rendLedgerLine[2][3];\n    /** Brevis width for normal and small staff */\n    int m_rendBrevisWidth[2];\n    /** Accident width for normal and small staff and normal and grace size */\n    int m_rendAccidWidth[2][2];\n    /** A vertical unit corresponding to the 1/4 of an interline */\n    float m_rendVerticalUnit1[2];\n    /** A vertical unit corresponding to the 1/8 of an interline */\n    float m_rendVerticalUnit2[2];\n    /** Current Leipzig font for normal and small staff and normal and grace size */\n    MusFontInfo m_rendFonts[2][2];\t\t\t\t\n    /** Leipzig font */\n    MusFontInfo m_rendLeipzigFont;\n    /** Current lyric font for normal and small staff and normal and grace size */\n    MusFontInfo m_rendLyricFonts[2];\n    /** Lyric font by default */\n    MusFontInfo m_rendLyricFont;\n    /** The current page height */\n    int m_rendPageHeight;\n    /** The current page height */\n    int m_rendPageWidth;\n    /** The current page witdth */\n    int m_rendPageLeftMar;\n    /** The current page left margin */\n    int m_rendPageRightMar;\n    /** The current page right margin */\n    int m_rendPageTopMar;\n    /** the current beam minimal slope */\n\tfloat m_rendBeamMinSlope;\n    /** the current beam maximal slope */\n    float m_rendBeamMaxSlope;\n    \nprivate:\n    /**\n     * The type of document indicates how to deal with the layout information.\n     * A Transcription document types means that the layout information is included\n     * and that no layout algorithm should be applied.\n     */\n    DocType m_type;\n    \n    /** Page width (MEI scoredef@page.width) - currently not saved */\n    int m_pageWidth;\n    /** Page height (MEI scoredef@page.height) - currently not saved */\n    int m_pageHeight;\n    /** Page left margin (MEI scoredef@page.leftmar) - currently not saved */\n    short m_pageLeftMar;\n    /** Page right margin (MEI scoredef@page.rightmar) - currently not saved */\n    short m_pageRightMar;\n    /** Page top margin (MEI scoredef@page.topmar) - currently not saved */\n    short m_pageTopMar;\n\t\n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musscoredef.h\n// Author:      Laurent Pugin\n// Created:     2013/11/08\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_SCOREDEF_H__\n#define __MUS_SCOREDEF_H__\n\n#include \"musobject.h\"\n\nclass MusClef;\nclass MusKeySig;\nclass MusMensur;\nclass MusStaffGrp;\nclass MusStaffDef;\n\n#define STAFFDEF_DRAW_NONE  0\n#define STAFFDEF_DRAW_CLEF  (1<<0)\n#define STAFFDEF_DRAW_KEYSIG  (1<<1)\n#define STAFFDEF_DRAW_MENSUR  (1<<2)\n#define STAFFDEF_DRAW_ALL (1<<3) - 1\n\n//----------------------------------------------------------------------------\n// MusScoreOrStaffDefAttrInterface\n//----------------------------------------------------------------------------\n\n/**\n * This class is an interface for MEI scoreDef or staffDef attributes clef, keysig and mensur.\n * For simplification, the attributes are stored as MusClef, MusKeySig and MusMensur.\n */\nclass MusScoreOrStaffDefAttrInterface\n{\npublic:\n    // constructors and destructors\n    MusScoreOrStaffDefAttrInterface();\n    virtual ~MusScoreOrStaffDefAttrInterface();\n    MusScoreOrStaffDefAttrInterface( const MusScoreOrStaffDefAttrInterface& interface ); // copy contructor\n    MusScoreOrStaffDefAttrInterface& operator=( const MusScoreOrStaffDefAttrInterface& interface ); // copy assignement;\n    \n    /**\n     * Replace the clef (if any) with the newClef (if any).\n     */\n    void ReplaceClef( MusClef *newClef );\n    \n    /**\n     * Replace the keysig (if any) with the newKeysig (if any).\n     */\n    void ReplaceKeySig( MusKeySig *newKeySig );\n    \n    /**\n     * Replace the mensur (if any) with the newMensur (if any).\n     */\n    void ReplaceMensur( MusMensur *newMensur );\n    \n    /**\n     * @name Get  the clef, keysig and mensure.\n     */\n    ///@{\n    MusClef *GetClefAttr() const { return m_clef; };\n    MusKeySig *GetKeySigAttr() const { return m_keySig; };\n    MusMensur *GetMensurAttr() const { return m_mensur; };\n    ///@}\n    \nprotected:\n    /** The clef attribute */\n    MusClef *m_clef;\n    /** The key signature */\n    MusKeySig *m_keySig;\n    /** The mensure (time signature */\n    MusMensur *m_mensur;\n    \n};\n\n\n\n//----------------------------------------------------------------------------\n// MusScoreDef\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a MEI scoreDef.\n * It contains MusStaffGrp objects.\n*/\nclass MusScoreDef: public MusObject, public MusScoreOrStaffDefAttrInterface, public MusObjectListInterface\n{\npublic:\n    // constructors and destructors\n    MusScoreDef();\n    virtual ~MusScoreDef();\n        \n    virtual std::string MusClassName( ) { return \"MusScoreDef\"; };\n    \n    void Clear();\n    \n\tvoid AddStaffGrp( MusStaffGrp *staffGrp );\n    \n    /**\n     * Replace the scoreDef with the content of the newScoreDef.\n     */\n    void Replace( MusScoreDef *newScoreDef );\n    \n    /**\n     * Replace the corresponding staffDef with the content of the newStaffDef.\n     * Looks for the staffDef with the same m_n (@n) and replace the attribute set.\n     * Attribute set is provided by the MusScoreOrStaffDefAttrInterface.\n     */\n    void Replace( MusStaffDef *newStaffDef );\n    \n    /**\n     * Get the staffDef with number n (NULL if not found).\n     */\n    MusStaffDef *GetStaffDef( int n );\n    \n    /**\n     * Set the redraw flag to all staffDefs.\n     * This is necessary at the beginning or when a scoreDef occurs.\n     */\n    void SetRedraw( bool clef, bool keysig, bool mensur );\n    \nprotected:\n    /**\n     * Filter the list for a specific class.\n     * For example, keep staffGrp for fast access.\n     */\n    virtual void FilterList();\n    \nprivate:\n    \npublic:\n\nprivate:\n    \n};\n\n\n//----------------------------------------------------------------------------\n// MusStaffGrp\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a MEI staffGrp.\n * It contains MusStaffDef objects.\n */\nclass MusStaffGrp: public MusObject, public MusObjectListInterface\n{\npublic:\n    // constructors and destructors\n    MusStaffGrp();\n    virtual ~MusStaffGrp();\n    virtual MusObject* Clone() { return new MusStaffGrp(*this); };\n    \n    virtual std::string MusClassName( ) { return \"MusStaffGrp\"; };\n\t\n\tvoid AddStaffDef( MusStaffDef *staffDef );\n    \n\tvoid AddStaffGrp( MusStaffGrp *staffGrp );\n    \n    /**\n     * @name Set and get the staffGrp @symbol\n     */\n    ///@{\n    StaffGrpSymbol GetSymbol() const { return m_symbol; };\n    void SetSymbol( StaffGrpSymbol symbol ) { m_symbol = symbol; };\n    ///@}\n    \n    /**\n     * @name Set and get the staffGrp @barthru\n     */\n    ///@{\n    bool GetBarthru() const { return m_barthru; };\n    void SetBarthru( bool barthru ) { m_barthru = barthru; };\n    ///@}\n    \n    // functors\n    virtual int Save( ArrayPtrVoid params );\n    \nprotected:\n    /**\n     * Filter the list for a specific class.\n     * For example, keep staffDef for fast access.\n     */\n    virtual void FilterList();\n    \nprivate:\n    \npublic:\n    \nprivate:\n    StaffGrpSymbol m_symbol;\n    bool m_barthru;\n    \n};\n\n\n//----------------------------------------------------------------------------\n// MusStaffDef\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a MEI staffDef.\n */\nclass MusStaffDef: public MusObject, public MusScoreOrStaffDefAttrInterface\n{\npublic:\n    // constructors and destructors\n    MusStaffDef();\n    virtual ~MusStaffDef();\n    virtual MusObject* Clone() { return new MusStaffDef(*this); };\n    \n    virtual std::string MusClassName( ) { return \"MusStaffDef\"; };\n    \n    /**\n     * @name Set and get  the staff number which is 1-based.\n     * This can be different from the index position in the parent measure.\n     */\n    ///@{\n    int GetStaffNo() const { return m_n; };\n    void SetStaffNo( int n ) { m_n = n; };\n    ///@}\n    \n    /**\n     * @name Set and get the layer drawing flags for clef, keysig and mensur.\n     * This will be true when starting a new system or when a scoreDef or staffDef changes occurs\n     * This will be true only for the first layer in the staff.\n     */\n    ///@{\n    int DrawClef() const { return m_drawClef; };\n    void SetDrawClef( bool drawClef ) { m_drawClef = drawClef; };\n    int DrawKeySig() const { return m_drawKeySig; };\n    void SetDrawKeySig( bool drawKeySig ) { m_drawKeySig = drawKeySig; };\n    int DrawMensur() const { return m_drawMensur; };\n    void SetDrawMensur( bool drawMensur ) { m_drawClef = drawMensur; };\n    ///@}\n\n    // functors\n    virtual int Save( ArrayPtrVoid params );\n    \n    /**\n     * Replace all the staffDefs in a scoreDef.\n     * Calls MusScoreDef::Replace.\n     * param 0: a pointer to the scoreDef we are going to replace the staffDefs\n     */\n    virtual int ReplaceStaffDefsInScoreDef( ArrayPtrVoid params );\n    \n    /**\n     * Set the initial scoreDef of each page.\n     * This is necessary for integrating changes that occur within a page.\n     * param 0: bool clef flag.\n     * param 1: bool keysig flag.\n     * param 2: bool the mensur flag.\n     */\n    virtual int SetStaffDefDraw( ArrayPtrVoid params );\n    \nprivate:\n    \npublic:\n    \nprivate:\n    /** The staff number */\n    int m_n;\n    \n    /**\n     *  @name Flags for indicating where the clef, keysig and mensur needs to be drawn or not\n     */\n    ///@{\n    bool m_drawClef;\n    bool m_drawKeySig;\n    bool m_drawMensur;\n    ///@}\n    \n};\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musdurationinterface.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musdurationinterface.h\"\n\n//----------------------------------------------------------------------------\n\n#include <math.h>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musdef.h\"\n#include \"musbeam.h\"\n\n/**\n * Define the maximum levels between a beam and its notes\n */\n#define MAX_BEAM_DEPTH 5 \n\n\n//----------------------------------------------------------------------------\n// MusDurationInterface\n//----------------------------------------------------------------------------\n\nMusDurationInterface::MusDurationInterface()\n{\n    m_breakSec = 0;\n    m_dots = 0;\n    m_dur = 0;\n    m_num = 1;\n    m_numBase = 1;\n    memset(m_tuplet, 0, DURATION_MAX_TUPLETS * sizeof(unsigned char));\n    m_fermata = false;\n}\n\n\nMusDurationInterface::~MusDurationInterface()\n{\n}\n\nvoid MusDurationInterface::SetDuration( int value )\n{\n    this->m_dur = value;\n}\n\n\ndouble MusDurationInterface::GetAlignementDuration( int num, int numbase )\n{\n    double duration = DUR_MAX / pow (2.0, (double)(m_dur - 2.0)) * numbase / num;\n    if ( m_dots > 0 ) {\n        duration = 2 * duration - (duration / pow(2, m_dots));\n    }\n    //Mus::LogDebug(\"Duration %d; Dot %d; Alignement %f\", m_dur, m_dots, duration );\n    return duration;\n}\n\nbool MusDurationInterface::IsInBeam( MusObject *noteOrRest )\n{\n    MusBeam *beam = dynamic_cast<MusBeam*>( noteOrRest->GetFirstParent( &typeid(MusBeam), MAX_BEAM_DEPTH ) );\n    if ( !beam ) {\n        return false;\n    }\n    return true;\n}\n\nbool MusDurationInterface::IsFirstInBeam( MusObject *noteOrRest )\n{\n    MusBeam *beam = dynamic_cast<MusBeam*>( noteOrRest->GetFirstParent( &typeid(MusBeam), MAX_BEAM_DEPTH ) );\n    if ( !beam ) {\n        return false;\n    }\n    ListOfMusObjects *notesOrRests = beam->GetList( beam );\n    ListOfMusObjects::iterator iter = notesOrRests->begin();\n    if ( *iter == noteOrRest ) {\n        return true;\n    }\n    return false;    \n}\n\nbool MusDurationInterface::IsLastInBeam( MusObject *noteOrRest )\n{\n    MusBeam *beam = dynamic_cast<MusBeam*>( noteOrRest->GetFirstParent( &typeid(MusBeam), MAX_BEAM_DEPTH ) );\n    if ( !beam ) {\n        return false;\n    }\n    ListOfMusObjects *notesOrRests = beam->GetList( beam );\n    ListOfMusObjects::reverse_iterator iter = notesOrRests->rbegin();\n    if ( *iter == noteOrRest ) {\n        return true;\n    }\n    return false;    \n    \n}\n\n\nbool MusDurationInterface::HasIdenticalDurationInterface( MusDurationInterface *otherDurationInterface )\n{\n    if ( !otherDurationInterface ) {\n        return false;\n    }\n    // beam requires value by value comparison\n    //if ( this->m_beam != otherDurationInterface->m_beam ) {\n    //    return false;\n    //}\n    if ( this->m_breakSec != otherDurationInterface->m_breakSec ) {\n        return false;\n    }\n    if ( this->m_dots != otherDurationInterface->m_dots ) {\n        return false;\n    }\n    if ( this->m_dur != otherDurationInterface->m_dur ) {\n        return false;\n    }\n    if ( this->m_num != otherDurationInterface->m_num ) {\n        return false;\n    }\n    if ( this->m_numBase != otherDurationInterface->m_numBase ) {\n        return false;\n    }\n    // tuplet requires value by value comparison\n    //if ( this->m_tuplet != otherDurationInterface->m_tuplet ) {\n    //    return false;\n    //}\n    if ( this->m_fermata != otherDurationInterface->m_fermata ) {\n        return false;\n    }\n    return true;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musio.cpp\n// Author:      Laurent Pugin\n// Created:     2012\n// Copyright (c) Laurent Pugin. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musio.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n// MusFileOutputStream\n//----------------------------------------------------------------------------\n\nMusFileOutputStream::MusFileOutputStream( MusDoc *doc, std::string filename ) :\n    std::ofstream( filename.c_str() )\n{\n\tassert(doc); // Document cannot be NULL\"\n\tm_doc = doc;\n}\n\nMusFileOutputStream::MusFileOutputStream( MusDoc *doc ) :\n    std::ofstream(  )\n{\n\tassert(doc); // Document cannot be NULL\"\n\tm_doc = doc;\n}\n\nMusFileOutputStream::~MusFileOutputStream()\n{\n    if ( this->is_open()) {\n        this->close();\n    }\n}\n\n\n\n//----------------------------------------------------------------------------\n// MusFileInputStream\n//----------------------------------------------------------------------------\n\nMusFileInputStream::MusFileInputStream( MusDoc *doc, std::string filename  ) :\n    std::ifstream( filename.c_str() )\n{\n\tassert(doc); // Document cannot be NULL\"\n\tm_doc = doc;\n    m_hasLayoutInformation = false;\n}\n\nMusFileInputStream::MusFileInputStream( MusDoc *doc ) :\n    std::ifstream(  )\n{\n\tassert(doc); // Document cannot be NULL\"\n\tm_doc = doc;\n    m_hasLayoutInformation = false;\n}\n\nMusFileInputStream::~MusFileInputStream()\n{\n    if ( this->is_open()) {\n        this->close();\n    }\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musio.h\n// Author:      Laurent Pugin\n// Created:     2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n#ifndef __MUS_IO_H__\n#define __MUS_IO_H__\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nclass MusDoc;\nclass MusLayer;\nclass MusLayerApp;\nclass MusLayerElement;\nclass MusLayerRdg;\nclass MusMeasure;\nclass MusPage;\nclass MusStaff;\nclass MusStaffDef;\nclass MusStaffGrp;\nclass MusSystem;\n\n//----------------------------------------------------------------------------\n// MusFileOutputStream\n//----------------------------------------------------------------------------\n\n/** \n * This class is a base class for file output stream classes.\n * It is not an abstract class but should not be instanciate directly.\n */ \nclass MusFileOutputStream: public std::ofstream\n{\npublic:\n    // constructors and destructors\n    MusFileOutputStream( MusDoc *doc, std::string filename );\n\tMusFileOutputStream( MusDoc *doc );\n    MusFileOutputStream() {};\n\t//MusFileOutputStream( MusDoc *file, wxFile *wxfile );\n    virtual ~MusFileOutputStream();\n    \n    virtual bool ExportFile( ) { return true; }\n    \n    /** @name Writing element methods\n     * The following methods actually write the elements.\n     * They must be overriden in the child classes.\n     * The children of the elements do not have to be writen from theses methods.\n     * This actually happen in the Save method of the MusObject classes\n     */\n    ///@{\n    virtual bool WriteDoc( MusDoc *doc ) { return true; };\n    virtual bool WritePage( MusPage *page ) { return true; };\n    virtual bool WriteSystem( MusSystem *system ) { return true; };\n    virtual bool WriteStaffGrp( MusStaffGrp *system ) { return true; };\n    virtual bool WriteStaffDef( MusStaffDef *system ) { return true; };\n    virtual bool WriteMeasure( MusMeasure *measure ) { return true; };\n    virtual bool WriteStaff( MusStaff *staff ) { return true; };\n    virtual bool WriteLayer( MusLayer *layer ) { return true; };\n    virtual bool WriteLayerElement( MusLayerElement *element ) { return true; };\n    // app\n    virtual bool WriteLayerApp( MusLayerApp *app ) { return true; };\n    virtual bool WriteLayerRdg( MusLayerRdg *rdg ) { return true; };\n    ///@}\n    \npublic:\n    \nprotected:\n    MusDoc *m_doc;\n    \nprivate:\n    \n};\n\n//----------------------------------------------------------------------------\n// MusFileInputStream\n//----------------------------------------------------------------------------\n\n/** \n * This class is a base class for file input stream classes.\n * It is not an abstract class but should not be instanciate directly.\n */ \nclass MusFileInputStream: public std::ifstream\n{\npublic:\n    // constructors and destructors\n    MusFileInputStream( MusDoc *doc, std::string filename );\n    MusFileInputStream( MusDoc *doc );\n    MusFileInputStream() {};\n    virtual ~MusFileInputStream();\n    \n    // read\n    virtual bool ImportFile( ) { return true; }\n    virtual bool ImportString( std::string data ) { return true; }\n    \n    bool HasLayoutInformation() { return m_hasLayoutInformation; };\n    \npublic:\n    \nprotected:\n    MusDoc *m_doc;\n    \n    /**\n     * Becomes true if layout information is found during the import.\n     * This will be true if the file is page-based MEI or if the MEI\n     * file contains <pb> and <sb>. This will stay wrong with PAE import\n     */\n    bool m_hasLayoutInformation;\n    \n    \n};\n\n#endif\n","/*\nwww.sourceforge.net/projects/tinyxml\nOriginal code by Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n\n#ifndef TINYXML_INCLUDED\n#define TINYXML_INCLUDED\n\n#ifdef _MSC_VER\n#pragma warning( push )\n#pragma warning( disable : 4530 )\n#pragma warning( disable : 4786 )\n#endif\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n// Help out windows:\n#if defined( _DEBUG ) && !defined( DEBUG )\n#define DEBUG\n#endif\n\n#ifdef TIXML_USE_STL\n\t#include <string>\n \t#include <iostream>\n\t#include <sstream>\n\t#define TIXML_STRING\t\twxString\n#else\n\t#include \"tinystr.h\"\n\t#define TIXML_STRING\t\tTiXmlString\n#endif\n\n// Deprecated library function hell. Compilers want to use the\n// new safe versions. This probably doesn't fully address the problem,\n// but it gets closer. There are too many compilers for me to fully\n// test. If you get compilation troubles, undefine TIXML_SAFE\n#define TIXML_SAFE\n\n#ifdef TIXML_SAFE\n\t#if defined(_MSC_VER) && (_MSC_VER >= 1400 )\n\t\t// Microsoft visual studio, version 2005 and higher.\n\t\t#define TIXML_SNPRINTF _snprintf_s\n\t\t#define TIXML_SSCANF   sscanf_s\n\t#elif defined(_MSC_VER) && (_MSC_VER >= 1200 )\n\t\t// Microsoft visual studio, version 6 and higher.\n\t\t//#pragma message( \"Using _sn* functions.\" )\n\t\t#define TIXML_SNPRINTF _snprintf\n\t\t#define TIXML_SSCANF   sscanf\n\t#elif defined(__GNUC__) && (__GNUC__ >= 3 )\n\t\t// GCC version 3 and higher.s\n\t\t//#warning( \"Using sn* functions.\" )\n\t\t#define TIXML_SNPRINTF snprintf\n\t\t#define TIXML_SSCANF   sscanf\n\t#else\n\t\t#define TIXML_SNPRINTF snprintf\n\t\t#define TIXML_SSCANF   sscanf\n\t#endif\n#endif\t\n\nclass TiXmlDocument;\nclass TiXmlElement;\nclass TiXmlComment;\nclass TiXmlUnknown;\nclass TiXmlAttribute;\nclass TiXmlText;\nclass TiXmlDeclaration;\nclass TiXmlParsingData;\n\nconst int TIXML_MAJOR_VERSION = 2;\nconst int TIXML_MINOR_VERSION = 6;\nconst int TIXML_PATCH_VERSION = 2;\n\n/*\tInternal structure for tracking location of items \n\tin the XML file.\n*/\nstruct TiXmlCursor\n{\n\tTiXmlCursor()\t\t{ Clear(); }\n\tvoid Clear()\t\t{ row = col = -1; }\n\n\tint row;\t// 0 based.\n\tint col;\t// 0 based.\n};\n\n\n/**\n\tImplements the interface to the \"Visitor pattern\" (see the Accept() method.)\n\tIf you call the Accept() method, it requires being passed a TiXmlVisitor\n\tclass to handle callbacks. For nodes that contain other nodes (Document, Element)\n\tyou will get called with a VisitEnter/VisitExit pair. Nodes that are always leaves\n\tare simply called with Visit().\n\n\tIf you return 'true' from a Visit method, recursive parsing will continue. If you return\n\tfalse, <b>no children of this node or its sibilings</b> will be Visited.\n\n\tAll flavors of Visit methods have a default implementation that returns 'true' (continue \n\tvisiting). You need to only override methods that are interesting to you.\n\n\tGenerally Accept() is called on the TiXmlDocument, although all nodes suppert Visiting.\n\n\tYou should never change the document from a callback.\n\n\t@sa TiXmlNode::Accept()\n*/\nclass TiXmlVisitor\n{\npublic:\n\tvirtual ~TiXmlVisitor() {}\n\n\t/// Visit a document.\n\tvirtual bool VisitEnter( const TiXmlDocument& /*doc*/ )\t\t\t{ return true; }\n\t/// Visit a document.\n\tvirtual bool VisitExit( const TiXmlDocument& /*doc*/ )\t\t\t{ return true; }\n\n\t/// Visit an element.\n\tvirtual bool VisitEnter( const TiXmlElement& /*element*/, const TiXmlAttribute* /*firstAttribute*/ )\t{ return true; }\n\t/// Visit an element.\n\tvirtual bool VisitExit( const TiXmlElement& /*element*/ )\t\t{ return true; }\n\n\t/// Visit a declaration\n\tvirtual bool Visit( const TiXmlDeclaration& /*declaration*/ )\t{ return true; }\n\t/// Visit a text node\n\tvirtual bool Visit( const TiXmlText& /*text*/ )\t\t\t\t\t{ return true; }\n\t/// Visit a comment node\n\tvirtual bool Visit( const TiXmlComment& /*comment*/ )\t\t\t{ return true; }\n\t/// Visit an unknown node\n\tvirtual bool Visit( const TiXmlUnknown& /*unknown*/ )\t\t\t{ return true; }\n};\n\n// Only used by Attribute::Query functions\nenum \n{ \n\tTIXML_SUCCESS,\n\tTIXML_NO_ATTRIBUTE,\n\tTIXML_WRONG_TYPE\n};\n\n\n// Used by the parsing routines.\nenum TiXmlEncoding\n{\n\tTIXML_ENCODING_UNKNOWN,\n\tTIXML_ENCODING_UTF8,\n\tTIXML_ENCODING_LEGACY\n};\n\nconst TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;\n\n/** TiXmlBase is a base class for every class in TinyXml.\n\tIt does little except to establish that TinyXml classes\n\tcan be printed and provide some utility functions.\n\n\tIn XML, the document and elements can contain\n\tother elements and other types of nodes.\n\n\t@verbatim\n\tA Document can contain:\tElement\t(container or leaf)\n\t\t\t\t\t\t\tComment (leaf)\n\t\t\t\t\t\t\tUnknown (leaf)\n\t\t\t\t\t\t\tDeclaration( leaf )\n\n\tAn Element can contain:\tElement (container or leaf)\n\t\t\t\t\t\t\tText\t(leaf)\n\t\t\t\t\t\t\tAttributes (not on tree)\n\t\t\t\t\t\t\tComment (leaf)\n\t\t\t\t\t\t\tUnknown (leaf)\n\n\tA Decleration contains: Attributes (not on tree)\n\t@endverbatim\n*/\nclass TiXmlBase\n{\n\tfriend class TiXmlNode;\n\tfriend class TiXmlElement;\n\tfriend class TiXmlDocument;\n\npublic:\n\tTiXmlBase()\t:\tuserData(0)\t\t{}\n\tvirtual ~TiXmlBase()\t\t\t{}\n\n\t/**\tAll TinyXml classes can print themselves to a filestream\n\t\tor the string class (TiXmlString in non-STL mode, wxString\n\t\tin STL mode.) Either or both cfile and str can be null.\n\t\t\n\t\tThis is a formatted print, and will insert \n\t\ttabs and newlines.\n\t\t\n\t\t(For an unformatted stream, use the << operator.)\n\t*/\n\tvirtual void Print( FILE* cfile, int depth ) const = 0;\n\n\t/**\tThe world does not agree on whether white space should be kept or\n\t\tnot. In order to make everyone happy, these global, static functions\n\t\tare provided to set whether or not TinyXml will condense all white space\n\t\tinto a single space or not. The default is to condense. Note changing this\n\t\tvalue is not thread safe.\n\t*/\n\tstatic void SetCondenseWhiteSpace( bool condense )\t\t{ condenseWhiteSpace = condense; }\n\n\t/// Return the current white space setting.\n\tstatic bool IsWhiteSpaceCondensed()\t\t\t\t\t\t{ return condenseWhiteSpace; }\n\n\t/** Return the position, in the original source file, of this node or attribute.\n\t\tThe row and column are 1-based. (That is the first row and first column is\n\t\t1,1). If the returns values are 0 or less, then the parser does not have\n\t\ta row and column value.\n\n\t\tGenerally, the row and column value will be set when the TiXmlDocument::Load(),\n\t\tTiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set\n\t\twhen the DOM was created from operator>>.\n\n\t\tThe values reflect the initial load. Once the DOM is modified programmatically\n\t\t(by adding or changing nodes and attributes) the new values will NOT update to\n\t\treflect changes in the document.\n\n\t\tThere is a minor performance cost to computing the row and column. Computation\n\t\tcan be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.\n\n\t\t@sa TiXmlDocument::SetTabSize()\n\t*/\n\tint Row() const\t\t\t{ return location.row + 1; }\n\tint Column() const\t\t{ return location.col + 1; }\t///< See Row()\n\n\tvoid  SetUserData( void* user )\t\t\t{ userData = user; }\t///< Set a pointer to arbitrary user data.\n\tvoid* GetUserData()\t\t\t\t\t\t{ return userData; }\t///< Get a pointer to arbitrary user data.\n\tconst void* GetUserData() const \t\t{ return userData; }\t///< Get a pointer to arbitrary user data.\n\n\t// Table that returs, for a given lead byte, the total number of bytes\n\t// in the UTF-8 sequence.\n\tstatic const int utf8ByteTable[256];\n\n\tvirtual const char* Parse(\tconst char* p, \n\t\t\t\t\t\t\t\tTiXmlParsingData* data, \n\t\t\t\t\t\t\t\tTiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;\n\n\t/** Expands entities in a string. Note this should not contian the tag's '<', '>', etc, \n\t\tor they will be transformed into entities!\n\t*/\n\tstatic void EncodeString( const TIXML_STRING& str, TIXML_STRING* out );\n\n\tenum\n\t{\n\t\tTIXML_NO_ERROR = 0,\n\t\tTIXML_ERROR,\n\t\tTIXML_ERROR_OPENING_FILE,\n\t\tTIXML_ERROR_PARSING_ELEMENT,\n\t\tTIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,\n\t\tTIXML_ERROR_READING_ELEMENT_VALUE,\n\t\tTIXML_ERROR_READING_ATTRIBUTES,\n\t\tTIXML_ERROR_PARSING_EMPTY,\n\t\tTIXML_ERROR_READING_END_TAG,\n\t\tTIXML_ERROR_PARSING_UNKNOWN,\n\t\tTIXML_ERROR_PARSING_COMMENT,\n\t\tTIXML_ERROR_PARSING_DECLARATION,\n\t\tTIXML_ERROR_DOCUMENT_EMPTY,\n\t\tTIXML_ERROR_EMBEDDED_NULL,\n\t\tTIXML_ERROR_PARSING_CDATA,\n\t\tTIXML_ERROR_DOCUMENT_TOP_ONLY,\n\n\t\tTIXML_ERROR_STRING_COUNT\n\t};\n\nprotected:\n\n\tstatic const char* SkipWhiteSpace( const char*, TiXmlEncoding encoding );\n\n\tinline static bool IsWhiteSpace( char c )\t\t\n\t{ \n\t\treturn ( isspace( (unsigned char) c ) || c == '\\n' || c == '\\r' ); \n\t}\n\tinline static bool IsWhiteSpace( int c )\n\t{\n\t\tif ( c < 256 )\n\t\t\treturn IsWhiteSpace( (char) c );\n\t\treturn false;\t// Again, only truly correct for English/Latin...but usually works.\n\t}\n\n\t#ifdef TIXML_USE_STL\n\tstatic bool\tStreamWhiteSpace( std::istream * in, TIXML_STRING * tag );\n\tstatic bool StreamTo( std::istream * in, int character, TIXML_STRING * tag );\n\t#endif\n\n\t/*\tReads an XML name into the string provided. Returns\n\t\ta pointer just past the last character of the name,\n\t\tor 0 if the function has an error.\n\t*/\n\tstatic const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );\n\n\t/*\tReads text. Returns a pointer past the given end tag.\n\t\tWickedly complex options, but it keeps the (sensitive) code in one place.\n\t*/\n\tstatic const char* ReadText(\tconst char* in,\t\t\t\t// where to start\n\t\t\t\t\t\t\t\t\tTIXML_STRING* text,\t\t\t// the string read\n\t\t\t\t\t\t\t\t\tbool ignoreWhiteSpace,\t\t// whether to keep the white space\n\t\t\t\t\t\t\t\t\tconst char* endTag,\t\t\t// what ends this text\n\t\t\t\t\t\t\t\t\tbool ignoreCase,\t\t\t// whether to ignore case in the end tag\n\t\t\t\t\t\t\t\t\tTiXmlEncoding encoding );\t// the current encoding\n\n\t// If an entity has been found, transform it into a character.\n\tstatic const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );\n\n\t// Get a character, while interpreting entities.\n\t// The length can be from 0 to 4 bytes.\n\tinline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )\n\t{\n\t\tassert( p );\n\t\tif ( encoding == TIXML_ENCODING_UTF8 )\n\t\t{\n\t\t\t*length = utf8ByteTable[ *((const unsigned char*)p) ];\n\t\t\tassert( *length >= 0 && *length < 5 );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*length = 1;\n\t\t}\n\n\t\tif ( *length == 1 )\n\t\t{\n\t\t\tif ( *p == '&' )\n\t\t\t\treturn GetEntity( p, _value, length, encoding );\n\t\t\t*_value = *p;\n\t\t\treturn p+1;\n\t\t}\n\t\telse if ( *length )\n\t\t{\n\t\t\t//strncpy( _value, p, *length );\t// lots of compilers don't like this function (unsafe),\n\t\t\t\t\t\t\t\t\t\t\t\t// and the null terminator isn't needed\n\t\t\tfor( int i=0; p[i] && i<*length; ++i ) {\n\t\t\t\t_value[i] = p[i];\n\t\t\t}\n\t\t\treturn p + (*length);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Not valid text.\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// Return true if the next characters in the stream are any of the endTag sequences.\n\t// Ignore case only works for english, and should only be relied on when comparing\n\t// to English words: StringEqual( p, \"version\", true ) is fine.\n\tstatic bool StringEqual(\tconst char* p,\n\t\t\t\t\t\t\t\tconst char* endTag,\n\t\t\t\t\t\t\t\tbool ignoreCase,\n\t\t\t\t\t\t\t\tTiXmlEncoding encoding );\n\n\tstatic const char* errorString[ TIXML_ERROR_STRING_COUNT ];\n\n\tTiXmlCursor location;\n\n    /// Field containing a generic user pointer\n\tvoid*\t\t\tuserData;\n\t\n\t// None of these methods are reliable for any language except English.\n\t// Good for approximation, not great for accuracy.\n\tstatic int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );\n\tstatic int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );\n\tinline static int ToLower( int v, TiXmlEncoding encoding )\n\t{\n\t\tif ( encoding == TIXML_ENCODING_UTF8 )\n\t\t{\n\t\t\tif ( v < 128 ) return tolower( v );\n\t\t\treturn v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn tolower( v );\n\t\t}\n\t}\n\tstatic void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );\n\nprivate:\n\tTiXmlBase( const TiXmlBase& );\t\t\t\t// not implemented.\n\tvoid operator=( const TiXmlBase& base );\t// not allowed.\n\n\tstruct Entity\n\t{\n\t\tconst char*     str;\n\t\tunsigned int\tstrLength;\n\t\tchar\t\t    chr;\n\t};\n\tenum\n\t{\n\t\tNUM_ENTITY = 5,\n\t\tMAX_ENTITY_LENGTH = 6\n\n\t};\n\tstatic Entity entity[ NUM_ENTITY ];\n\tstatic bool condenseWhiteSpace;\n};\n\n\n/** The parent class for everything in the Document Object Model.\n\t(Except for attributes).\n\tNodes have siblings, a parent, and children. A node can be\n\tin a document, or stand on its own. The type of a TiXmlNode\n\tcan be queried, and it can be cast to its more defined type.\n*/\nclass TiXmlNode : public TiXmlBase\n{\n\tfriend class TiXmlDocument;\n\tfriend class TiXmlElement;\n\npublic:\n\t#ifdef TIXML_USE_STL\t\n\n\t    /** An input stream operator, for every class. Tolerant of newlines and\n\t\t    formatting, but doesn't expect them.\n\t    */\n\t    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);\n\n\t    /** An output stream operator, for every class. Note that this outputs\n\t\t    without any newlines or formatting, as opposed to Print(), which\n\t\t    includes tabs and new lines.\n\n\t\t    The operator<< and operator>> are not completely symmetric. Writing\n\t\t    a node to a stream is very well defined. You'll get a nice stream\n\t\t    of output, without any extra whitespace or newlines.\n\t\t    \n\t\t    But reading is not as well defined. (As it always is.) If you create\n\t\t    a TiXmlElement (for example) and read that from an input stream,\n\t\t    the text needs to define an element or junk will result. This is\n\t\t    true of all input streams, but it's worth keeping in mind.\n\n\t\t    A TiXmlDocument will read nodes until it reads a root element, and\n\t\t\tall the children of that root element.\n\t    */\t\n\t    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);\n\n\t\t/// Appends the XML node or attribute to a wxString.\n\t\tfriend wxString& operator<< (wxString& out, const TiXmlNode& base );\n\n\t#endif\n\n\t/** The types of XML nodes supported by TinyXml. (All the\n\t\t\tunsupported types are picked up by UNKNOWN.)\n\t*/\n\tenum NodeType\n\t{\n\t\tTINYXML_DOCUMENT,\n\t\tTINYXML_ELEMENT,\n\t\tTINYXML_COMMENT,\n\t\tTINYXML_UNKNOWN,\n\t\tTINYXML_TEXT,\n\t\tTINYXML_DECLARATION,\n\t\tTINYXML_TYPECOUNT\n\t};\n\n\tvirtual ~TiXmlNode();\n\n\t/** The meaning of 'value' changes for the specific type of\n\t\tTiXmlNode.\n\t\t@verbatim\n\t\tDocument:\tfilename of the xml file\n\t\tElement:\tname of the element\n\t\tComment:\tthe comment text\n\t\tUnknown:\tthe tag contents\n\t\tText:\t\tthe text string\n\t\t@endverbatim\n\n\t\tThe subclasses will wrap this function.\n\t*/\n\tconst char *Value() const { return value.c_str (); }\n\n    #ifdef TIXML_USE_STL\n\t/** Return Value() as a wxString. If you only use STL,\n\t    this is more efficient than calling Value().\n\t\tOnly available in STL mode.\n\t*/\n\tconst wxString& ValueStr() const { return value; }\n\t#endif\n\n\tconst TIXML_STRING& ValueTStr() const { return value; }\n\n\t/** Changes the value of the node. Defined as:\n\t\t@verbatim\n\t\tDocument:\tfilename of the xml file\n\t\tElement:\tname of the element\n\t\tComment:\tthe comment text\n\t\tUnknown:\tthe tag contents\n\t\tText:\t\tthe text string\n\t\t@endverbatim\n\t*/\n\tvoid SetValue(const char * _value) { value = _value;}\n\n    #ifdef TIXML_USE_STL\n\t/// STL wxString form.\n\tvoid SetValue( const wxString& _value )\t{ value = _value; }\n\t#endif\n\n\t/// Delete all the children of this node. Does not affect 'this'.\n\tvoid Clear();\n\n\t/// One step up the DOM.\n\tTiXmlNode* Parent()\t\t\t\t\t\t\t{ return parent; }\n\tconst TiXmlNode* Parent() const\t\t\t\t{ return parent; }\n\n\tconst TiXmlNode* FirstChild()\tconst\t\t{ return firstChild; }\t///< The first child of this node. Will be null if there are no children.\n\tTiXmlNode* FirstChild()\t\t\t\t\t\t{ return firstChild; }\n\tconst TiXmlNode* FirstChild( const char * value ) const;\t\t\t///< The first child of this node with the matching 'value'. Will be null if none found.\n\t/// The first child of this node with the matching 'value'. Will be null if none found.\n\tTiXmlNode* FirstChild( const char * _value ) {\n\t\t// Call through to the const version - safe since nothing is changed. Exiting syntax: cast this to a const (always safe)\n\t\t// call the method, cast the return back to non-const.\n\t\treturn const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->FirstChild( _value ));\n\t}\n\tconst TiXmlNode* LastChild() const\t{ return lastChild; }\t\t/// The last child of this node. Will be null if there are no children.\n\tTiXmlNode* LastChild()\t{ return lastChild; }\n\t\n\tconst TiXmlNode* LastChild( const char * value ) const;\t\t\t/// The last child of this node matching 'value'. Will be null if there are no children.\n\tTiXmlNode* LastChild( const char * _value ) {\n\t\treturn const_cast< TiXmlNode* > ((const_cast< const TiXmlNode* >(this))->LastChild( _value ));\n\t}\n\n    #ifdef TIXML_USE_STL\n\tconst TiXmlNode* FirstChild( const wxString& _value ) const\t{\treturn FirstChild (_value.c_str ());\t}\t///< STL wxString form.\n\tTiXmlNode* FirstChild( const wxString& _value )\t\t\t\t{\treturn FirstChild (_value.c_str ());\t}\t///< STL wxString form.\n\tconst TiXmlNode* LastChild( const wxString& _value ) const\t{\treturn LastChild (_value.c_str ());\t}\t///< STL wxString form.\n\tTiXmlNode* LastChild( const wxString& _value )\t\t\t\t{\treturn LastChild (_value.c_str ());\t}\t///< STL wxString form.\n\t#endif\n\n\t/** An alternate way to walk the children of a node.\n\t\tOne way to iterate over nodes is:\n\t\t@verbatim\n\t\t\tfor( child = parent->FirstChild(); child; child = child->NextSibling() )\n\t\t@endverbatim\n\n\t\tIterateChildren does the same thing with the syntax:\n\t\t@verbatim\n\t\t\tchild = 0;\n\t\t\twhile( child = parent->IterateChildren( child ) )\n\t\t@endverbatim\n\n\t\tIterateChildren takes the previous child as input and finds\n\t\tthe next one. If the previous child is null, it returns the\n\t\tfirst. IterateChildren will return null when done.\n\t*/\n\tconst TiXmlNode* IterateChildren( const TiXmlNode* previous ) const;\n\tTiXmlNode* IterateChildren( const TiXmlNode* previous ) {\n\t\treturn const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( previous ) );\n\t}\n\n\t/// This flavor of IterateChildren searches for children with a particular 'value'\n\tconst TiXmlNode* IterateChildren( const char * value, const TiXmlNode* previous ) const;\n\tTiXmlNode* IterateChildren( const char * _value, const TiXmlNode* previous ) {\n\t\treturn const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->IterateChildren( _value, previous ) );\n\t}\n\n    #ifdef TIXML_USE_STL\n\tconst TiXmlNode* IterateChildren( const wxString& _value, const TiXmlNode* previous ) const\t{\treturn IterateChildren (_value.c_str (), previous);\t}\t///< STL wxString form.\n\tTiXmlNode* IterateChildren( const wxString& _value, const TiXmlNode* previous ) {\treturn IterateChildren (_value.c_str (), previous);\t}\t///< STL wxString form.\n\t#endif\n\n\t/** Add a new node related to this. Adds a child past the LastChild.\n\t\tReturns a pointer to the new object or NULL if an error occured.\n\t*/\n\tTiXmlNode* InsertEndChild( const TiXmlNode& addThis );\n\n\n\t/** Add a new node related to this. Adds a child past the LastChild.\n\n\t\tNOTE: the node to be added is passed by pointer, and will be\n\t\thenceforth owned (and deleted) by tinyXml. This method is efficient\n\t\tand avoids an extra copy, but should be used with care as it\n\t\tuses a different memory model than the other insert functions.\n\n\t\t@sa InsertEndChild\n\t*/\n\tTiXmlNode* LinkEndChild( TiXmlNode* addThis );\n\n\t/** Add a new node related to this. Adds a child before the specified child.\n\t\tReturns a pointer to the new object or NULL if an error occured.\n\t*/\n\tTiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );\n\n\t/** Add a new node related to this. Adds a child after the specified child.\n\t\tReturns a pointer to the new object or NULL if an error occured.\n\t*/\n\tTiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );\n\n\t/** Replace a child of this node.\n\t\tReturns a pointer to the new object or NULL if an error occured.\n\t*/\n\tTiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );\n\n\t/// Delete a child of this node.\n\tbool RemoveChild( TiXmlNode* removeThis );\n\n\t/// Navigate to a sibling node.\n\tconst TiXmlNode* PreviousSibling() const\t\t\t{ return prev; }\n\tTiXmlNode* PreviousSibling()\t\t\t\t\t\t{ return prev; }\n\n\t/// Navigate to a sibling node.\n\tconst TiXmlNode* PreviousSibling( const char * ) const;\n\tTiXmlNode* PreviousSibling( const char *_prev ) {\n\t\treturn const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->PreviousSibling( _prev ) );\n\t}\n\n    #ifdef TIXML_USE_STL\n\tconst TiXmlNode* PreviousSibling( const wxString& _value ) const\t{\treturn PreviousSibling (_value.c_str ());\t}\t///< STL wxString form.\n\tTiXmlNode* PreviousSibling( const wxString& _value ) \t\t\t{\treturn PreviousSibling (_value.c_str ());\t}\t///< STL wxString form.\n\tconst TiXmlNode* NextSibling( const wxString& _value) const\t\t{\treturn NextSibling (_value.c_str ());\t}\t///< STL wxString form.\n\tTiXmlNode* NextSibling( const wxString& _value) \t\t\t\t\t{\treturn NextSibling (_value.c_str ());\t}\t///< STL wxString form.\n\t#endif\n\n\t/// Navigate to a sibling node.\n\tconst TiXmlNode* NextSibling() const\t\t\t\t{ return next; }\n\tTiXmlNode* NextSibling()\t\t\t\t\t\t\t{ return next; }\n\n\t/// Navigate to a sibling node with the given 'value'.\n\tconst TiXmlNode* NextSibling( const char * ) const;\n\tTiXmlNode* NextSibling( const char* _next ) {\n\t\treturn const_cast< TiXmlNode* >( (const_cast< const TiXmlNode* >(this))->NextSibling( _next ) );\n\t}\n\n\t/** Convenience function to get through elements.\n\t\tCalls NextSibling and ToElement. Will skip all non-Element\n\t\tnodes. Returns 0 if there is not another element.\n\t*/\n\tconst TiXmlElement* NextSiblingElement() const;\n\tTiXmlElement* NextSiblingElement() {\n\t\treturn const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement() );\n\t}\n\n\t/** Convenience function to get through elements.\n\t\tCalls NextSibling and ToElement. Will skip all non-Element\n\t\tnodes. Returns 0 if there is not another element.\n\t*/\n\tconst TiXmlElement* NextSiblingElement( const char * ) const;\n\tTiXmlElement* NextSiblingElement( const char *_next ) {\n\t\treturn const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->NextSiblingElement( _next ) );\n\t}\n\n    #ifdef TIXML_USE_STL\n\tconst TiXmlElement* NextSiblingElement( const wxString& _value) const\t{\treturn NextSiblingElement (_value.c_str ());\t}\t///< STL wxString form.\n\tTiXmlElement* NextSiblingElement( const wxString& _value)\t\t\t\t{\treturn NextSiblingElement (_value.c_str ());\t}\t///< STL wxString form.\n\t#endif\n\n\t/// Convenience function to get through elements.\n\tconst TiXmlElement* FirstChildElement()\tconst;\n\tTiXmlElement* FirstChildElement() {\n\t\treturn const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement() );\n\t}\n\n\t/// Convenience function to get through elements.\n\tconst TiXmlElement* FirstChildElement( const char * _value ) const;\n\tTiXmlElement* FirstChildElement( const char * _value ) {\n\t\treturn const_cast< TiXmlElement* >( (const_cast< const TiXmlNode* >(this))->FirstChildElement( _value ) );\n\t}\n\n    #ifdef TIXML_USE_STL\n\tconst TiXmlElement* FirstChildElement( const wxString& _value ) const\t{\treturn FirstChildElement (_value.c_str ());\t}\t///< STL wxString form.\n\tTiXmlElement* FirstChildElement( const wxString& _value )\t\t\t\t{\treturn FirstChildElement (_value.c_str ());\t}\t///< STL wxString form.\n\t#endif\n\n\t/** Query the type (as an enumerated value, above) of this node.\n\t\tThe possible types are: TINYXML_DOCUMENT, TINYXML_ELEMENT, TINYXML_COMMENT,\n\t\t\t\t\t\t\t\tTINYXML_UNKNOWN, TINYXML_TEXT, and TINYXML_DECLARATION.\n\t*/\n\tint Type() const\t{ return type; }\n\n\t/** Return a pointer to the Document this node lives in.\n\t\tReturns null if not in a document.\n\t*/\n\tconst TiXmlDocument* GetDocument() const;\n\tTiXmlDocument* GetDocument() {\n\t\treturn const_cast< TiXmlDocument* >( (const_cast< const TiXmlNode* >(this))->GetDocument() );\n\t}\n\n\t/// Returns true if this node has no children.\n\tbool NoChildren() const\t\t\t\t\t\t{ return !firstChild; }\n\n\tvirtual const TiXmlDocument*    ToDocument()    const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual const TiXmlElement*     ToElement()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual const TiXmlComment*     ToComment()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual const TiXmlUnknown*     ToUnknown()     const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual const TiXmlText*        ToText()        const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual const TiXmlDeclaration* ToDeclaration() const { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\n\tvirtual TiXmlDocument*          ToDocument()    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual TiXmlElement*           ToElement()\t    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual TiXmlComment*           ToComment()     { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual TiXmlUnknown*           ToUnknown()\t    { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual TiXmlText*\t            ToText()        { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\tvirtual TiXmlDeclaration*       ToDeclaration() { return 0; } ///< Cast to a more defined type. Will return null if not of the requested type.\n\n\t/** Create an exact duplicate of this node and return it. The memory must be deleted\n\t\tby the caller. \n\t*/\n\tvirtual TiXmlNode* Clone() const = 0;\n\n\t/** Accept a hierchical visit the nodes in the TinyXML DOM. Every node in the \n\t\tXML tree will be conditionally visited and the host will be called back\n\t\tvia the TiXmlVisitor interface.\n\n\t\tThis is essentially a SAX interface for TinyXML. (Note however it doesn't re-parse\n\t\tthe XML for the callbacks, so the performance of TinyXML is unchanged by using this\n\t\tinterface versus any other.)\n\n\t\tThe interface has been based on ideas from:\n\n\t\t- http://www.saxproject.org/\n\t\t- http://c2.com/cgi/wiki?HierarchicalVisitorPattern \n\n\t\tWhich are both good references for \"visiting\".\n\n\t\tAn example of using Accept():\n\t\t@verbatim\n\t\tTiXmlPrinter printer;\n\t\ttinyxmlDoc.Accept( &printer );\n\t\tconst char* xmlcstr = printer.CStr();\n\t\t@endverbatim\n\t*/\n\tvirtual bool Accept( TiXmlVisitor* visitor ) const = 0;\n\nprotected:\n\tTiXmlNode( NodeType _type );\n\n\t// Copy to the allocated object. Shared functionality between Clone, Copy constructor,\n\t// and the assignment operator.\n\tvoid CopyTo( TiXmlNode* target ) const;\n\n\t#ifdef TIXML_USE_STL\n\t    // The real work of the input operator.\n\tvirtual void StreamIn( std::istream* in, TIXML_STRING* tag ) = 0;\n\t#endif\n\n\t// Figure out what is at *p, and parse it. Returns null if it is not an xml node.\n\tTiXmlNode* Identify( const char* start, TiXmlEncoding encoding );\n\n\tTiXmlNode*\t\tparent;\n\tNodeType\t\ttype;\n\n\tTiXmlNode*\t\tfirstChild;\n\tTiXmlNode*\t\tlastChild;\n\n\tTIXML_STRING\tvalue;\n\n\tTiXmlNode*\t\tprev;\n\tTiXmlNode*\t\tnext;\n\nprivate:\n\tTiXmlNode( const TiXmlNode& );\t\t\t\t// not implemented.\n\tvoid operator=( const TiXmlNode& base );\t// not allowed.\n};\n\n\n/** An attribute is a name-value pair. Elements have an arbitrary\n\tnumber of attributes, each with a unique name.\n\n\t@note The attributes are not TiXmlNodes, since they are not\n\t\t  part of the tinyXML document object model. There are other\n\t\t  suggested ways to look at this problem.\n*/\nclass TiXmlAttribute : public TiXmlBase\n{\n\tfriend class TiXmlAttributeSet;\n\npublic:\n\t/// Construct an empty attribute.\n\tTiXmlAttribute() : TiXmlBase()\n\t{\n\t\tdocument = 0;\n\t\tprev = next = 0;\n\t}\n\n\t#ifdef TIXML_USE_STL\n\t/// wxString constructor.\n\tTiXmlAttribute( const wxString& _name, const wxString& _value )\n\t{\n\t\tname = _name;\n\t\tvalue = _value;\n\t\tdocument = 0;\n\t\tprev = next = 0;\n\t}\n\t#endif\n\n\t/// Construct an attribute with a name and value.\n\tTiXmlAttribute( const char * _name, const char * _value )\n\t{\n\t\tname = _name;\n\t\tvalue = _value;\n\t\tdocument = 0;\n\t\tprev = next = 0;\n\t}\n\n\tconst char*\t\tName()  const\t\t{ return name.c_str(); }\t\t///< Return the name of this attribute.\n\tconst char*\t\tValue() const\t\t{ return value.c_str(); }\t\t///< Return the value of this attribute.\n\t#ifdef TIXML_USE_STL\n\tconst wxString& ValueStr() const\t{ return value; }\t\t\t\t///< Return the value of this attribute.\n\t#endif\n\tint\t\t\t\tIntValue() const;\t\t\t\t\t\t\t\t\t///< Return the value of this attribute, converted to an integer.\n\tdouble\t\t\tDoubleValue() const;\t\t\t\t\t\t\t\t///< Return the value of this attribute, converted to a double.\n\n\t// Get the tinyxml string representation\n\tconst TIXML_STRING& NameTStr() const { return name; }\n\n\t/** QueryIntValue examines the value string. It is an alternative to the\n\t\tIntValue() method with richer error checking.\n\t\tIf the value is an integer, it is stored in 'value' and \n\t\tthe call returns TIXML_SUCCESS. If it is not\n\t\tan integer, it returns TIXML_WRONG_TYPE.\n\n\t\tA specialized but useful call. Note that for success it returns 0,\n\t\twhich is the opposite of almost all other TinyXml calls.\n\t*/\n\tint QueryIntValue( int* _value ) const;\n\t/// QueryDoubleValue examines the value string. See QueryIntValue().\n\tint QueryDoubleValue( double* _value ) const;\n\n\tvoid SetName( const char* _name )\t{ name = _name; }\t\t\t\t///< Set the name of this attribute.\n\tvoid SetValue( const char* _value )\t{ value = _value; }\t\t\t\t///< Set the value.\n\n\tvoid SetIntValue( int _value );\t\t\t\t\t\t\t\t\t\t///< Set the value from an integer.\n\tvoid SetDoubleValue( double _value );\t\t\t\t\t\t\t\t///< Set the value from a double.\n\n    #ifdef TIXML_USE_STL\n\t/// STL wxString form.\n\tvoid SetName( const wxString& _name )\t{ name = _name; }\t\n\t/// STL wxString form.\t\n\tvoid SetValue( const wxString& _value )\t{ value = _value; }\n\t#endif\n\n\t/// Get the next sibling attribute in the DOM. Returns null at end.\n\tconst TiXmlAttribute* Next() const;\n\tTiXmlAttribute* Next() {\n\t\treturn const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Next() ); \n\t}\n\n\t/// Get the previous sibling attribute in the DOM. Returns null at beginning.\n\tconst TiXmlAttribute* Previous() const;\n\tTiXmlAttribute* Previous() {\n\t\treturn const_cast< TiXmlAttribute* >( (const_cast< const TiXmlAttribute* >(this))->Previous() ); \n\t}\n\n\tbool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }\n\tbool operator<( const TiXmlAttribute& rhs )\t const { return name < rhs.name; }\n\tbool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }\n\n\t/*\tAttribute parsing starts: first letter of the name\n\t\t\t\t\t\t returns: the next char after the value end quote\n\t*/\n\tvirtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );\n\n\t// Prints this Attribute to a FILE stream.\n\tvirtual void Print( FILE* cfile, int depth ) const {\n\t\tPrint( cfile, depth, 0 );\n\t}\n\tvoid Print( FILE* cfile, int depth, TIXML_STRING* str ) const;\n\n\t// [internal use]\n\t// Set the document pointer so the attribute can report errors.\n\tvoid SetDocument( TiXmlDocument* doc )\t{ document = doc; }\n\nprivate:\n\tTiXmlAttribute( const TiXmlAttribute& );\t\t\t\t// not implemented.\n\tvoid operator=( const TiXmlAttribute& base );\t// not allowed.\n\n\tTiXmlDocument*\tdocument;\t// A pointer back to a document, for error reporting.\n\tTIXML_STRING name;\n\tTIXML_STRING value;\n\tTiXmlAttribute*\tprev;\n\tTiXmlAttribute*\tnext;\n};\n\n\n/*\tA class used to manage a group of attributes.\n\tIt is only used internally, both by the ELEMENT and the DECLARATION.\n\t\n\tThe set can be changed transparent to the Element and Declaration\n\tclasses that use it, but NOT transparent to the Attribute\n\twhich has to implement a next() and previous() method. Which makes\n\tit a bit problematic and prevents the use of STL.\n\n\tThis version is implemented with circular lists because:\n\t\t- I like circular lists\n\t\t- it demonstrates some independence from the (typical) doubly linked list.\n*/\nclass TiXmlAttributeSet\n{\npublic:\n\tTiXmlAttributeSet();\n\t~TiXmlAttributeSet();\n\n\tvoid Add( TiXmlAttribute* attribute );\n\tvoid Remove( TiXmlAttribute* attribute );\n\n\tconst TiXmlAttribute* First()\tconst\t{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }\n\tTiXmlAttribute* First()\t\t\t\t\t{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }\n\tconst TiXmlAttribute* Last() const\t\t{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }\n\tTiXmlAttribute* Last()\t\t\t\t\t{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }\n\n\tTiXmlAttribute*\tFind( const char* _name ) const;\n\tTiXmlAttribute* FindOrCreate( const char* _name );\n\n#\tifdef TIXML_USE_STL\n\tTiXmlAttribute*\tFind( const wxString& _name ) const;\n\tTiXmlAttribute* FindOrCreate( const wxString& _name );\n#\tendif\n\n\nprivate:\n\t//*ME:\tBecause of hidden/disabled copy-construktor in TiXmlAttribute (sentinel-element),\n\t//*ME:\tthis class must be also use a hidden/disabled copy-constructor !!!\n\tTiXmlAttributeSet( const TiXmlAttributeSet& );\t// not allowed\n\tvoid operator=( const TiXmlAttributeSet& );\t// not allowed (as TiXmlAttribute)\n\n\tTiXmlAttribute sentinel;\n};\n\n\n/** The element is a container class. It has a value, the element name,\n\tand can contain other elements, text, comments, and unknowns.\n\tElements also contain an arbitrary number of attributes.\n*/\nclass TiXmlElement : public TiXmlNode\n{\npublic:\n\t/// Construct an element.\n\tTiXmlElement (const char * in_value);\n\n\t#ifdef TIXML_USE_STL\n\t/// wxString constructor.\n\tTiXmlElement( const wxString& _value );\n\t#endif\n\n\tTiXmlElement( const TiXmlElement& );\n\n\tTiXmlElement& operator=( const TiXmlElement& base );\n\n\tvirtual ~TiXmlElement();\n\n\t/** Given an attribute name, Attribute() returns the value\n\t\tfor the attribute of that name, or null if none exists.\n\t*/\n\tconst char* Attribute( const char* name ) const;\n\n\t/** Given an attribute name, Attribute() returns the value\n\t\tfor the attribute of that name, or null if none exists.\n\t\tIf the attribute exists and can be converted to an integer,\n\t\tthe integer value will be put in the return 'i', if 'i'\n\t\tis non-null.\n\t*/\n\tconst char* Attribute( const char* name, int* i ) const;\n\n\t/** Given an attribute name, Attribute() returns the value\n\t\tfor the attribute of that name, or null if none exists.\n\t\tIf the attribute exists and can be converted to an double,\n\t\tthe double value will be put in the return 'd', if 'd'\n\t\tis non-null.\n\t*/\n\tconst char* Attribute( const char* name, double* d ) const;\n\n\t/** QueryIntAttribute examines the attribute - it is an alternative to the\n\t\tAttribute() method with richer error checking.\n\t\tIf the attribute is an integer, it is stored in 'value' and \n\t\tthe call returns TIXML_SUCCESS. If it is not\n\t\tan integer, it returns TIXML_WRONG_TYPE. If the attribute\n\t\tdoes not exist, then TIXML_NO_ATTRIBUTE is returned.\n\t*/\t\n\tint QueryIntAttribute( const char* name, int* _value ) const;\n\t/// QueryUnsignedAttribute examines the attribute - see QueryIntAttribute().\n\tint QueryUnsignedAttribute( const char* name, unsigned* _value ) const;\n\t/** QueryBoolAttribute examines the attribute - see QueryIntAttribute(). \n\t\tNote that '1', 'true', or 'yes' are considered true, while '0', 'false'\n\t\tand 'no' are considered false.\n\t*/\n\tint QueryBoolAttribute( const char* name, bool* _value ) const;\n\t/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().\n\tint QueryDoubleAttribute( const char* name, double* _value ) const;\n\t/// QueryFloatAttribute examines the attribute - see QueryIntAttribute().\n\tint QueryFloatAttribute( const char* name, float* _value ) const {\n\t\tdouble d;\n\t\tint result = QueryDoubleAttribute( name, &d );\n\t\tif ( result == TIXML_SUCCESS ) {\n\t\t\t*_value = (float)d;\n\t\t}\n\t\treturn result;\n\t}\n\n    #ifdef TIXML_USE_STL\n\t/// QueryStringAttribute examines the attribute - see QueryIntAttribute().\n\tint QueryStringAttribute( const char* name, wxString* _value ) const {\n\t\tconst char* cstr = Attribute( name );\n\t\tif ( cstr ) {\n\t\t\t*_value = wxString( cstr );\n\t\t\treturn TIXML_SUCCESS;\n\t\t}\n\t\treturn TIXML_NO_ATTRIBUTE;\n\t}\n\n\t/** Template form of the attribute query which will try to read the\n\t\tattribute into the specified type. Very easy, very powerful, but\n\t\tbe careful to make sure to call this with the correct type.\n\t\t\n\t\tNOTE: This method doesn't work correctly for 'string' types that contain spaces.\n\n\t\t@return TIXML_SUCCESS, TIXML_WRONG_TYPE, or TIXML_NO_ATTRIBUTE\n\t*/\n\ttemplate< typename T > int QueryValueAttribute( const wxString& name, T* outValue ) const\n\t{\n\t\tconst TiXmlAttribute* node = attributeSet.Find( name );\n\t\tif ( !node )\n\t\t\treturn TIXML_NO_ATTRIBUTE;\n\n\t\twxStringstream sstream( node->ValueStr() );\n\t\tsstream >> *outValue;\n\t\tif ( !sstream.fail() )\n\t\t\treturn TIXML_SUCCESS;\n\t\treturn TIXML_WRONG_TYPE;\n\t}\n\n\tint QueryValueAttribute( const wxString& name, wxString* outValue ) const\n\t{\n\t\tconst TiXmlAttribute* node = attributeSet.Find( name );\n\t\tif ( !node )\n\t\t\treturn TIXML_NO_ATTRIBUTE;\n\t\t*outValue = node->ValueStr();\n\t\treturn TIXML_SUCCESS;\n\t}\n\t#endif\n\n\t/** Sets an attribute of name to a given value. The attribute\n\t\twill be created if it does not exist, or changed if it does.\n\t*/\n\tvoid SetAttribute( const char* name, const char * _value );\n\n    #ifdef TIXML_USE_STL\n\tconst wxString* Attribute( const wxString& name ) const;\n\tconst wxString* Attribute( const wxString& name, int* i ) const;\n\tconst wxString* Attribute( const wxString& name, double* d ) const;\n\tint QueryIntAttribute( const wxString& name, int* _value ) const;\n\tint QueryDoubleAttribute( const wxString& name, double* _value ) const;\n\n\t/// STL wxString form.\n\tvoid SetAttribute( const wxString& name, const wxString& _value );\n\t///< STL wxString form.\n\tvoid SetAttribute( const wxString& name, int _value );\n\t///< STL wxString form.\n\tvoid SetDoubleAttribute( const wxString& name, double value );\n\t#endif\n\n\t/** Sets an attribute of name to a given value. The attribute\n\t\twill be created if it does not exist, or changed if it does.\n\t*/\n\tvoid SetAttribute( const char * name, int value );\n\n\t/** Sets an attribute of name to a given value. The attribute\n\t\twill be created if it does not exist, or changed if it does.\n\t*/\n\tvoid SetDoubleAttribute( const char * name, double value );\n\n\t/** Deletes an attribute with the given name.\n\t*/\n\tvoid RemoveAttribute( const char * name );\n    #ifdef TIXML_USE_STL\n\tvoid RemoveAttribute( const wxString& name )\t{\tRemoveAttribute (name.c_str ());\t}\t///< STL wxString form.\n\t#endif\n\n\tconst TiXmlAttribute* FirstAttribute() const\t{ return attributeSet.First(); }\t\t///< Access the first attribute in this element.\n\tTiXmlAttribute* FirstAttribute() \t\t\t\t{ return attributeSet.First(); }\n\tconst TiXmlAttribute* LastAttribute()\tconst \t{ return attributeSet.Last(); }\t\t///< Access the last attribute in this element.\n\tTiXmlAttribute* LastAttribute()\t\t\t\t\t{ return attributeSet.Last(); }\n\n\t/** Convenience function for easy access to the text inside an element. Although easy\n\t\tand concise, GetText() is limited compared to getting the TiXmlText child\n\t\tand accessing it directly.\n\t\n\t\tIf the first child of 'this' is a TiXmlText, the GetText()\n\t\treturns the character string of the Text node, else null is returned.\n\n\t\tThis is a convenient method for getting the text of simple contained text:\n\t\t@verbatim\n\t\t<foo>This is text</foo>\n\t\tconst char* str = fooElement->GetText();\n\t\t@endverbatim\n\n\t\t'str' will be a pointer to \"This is text\". \n\t\t\n\t\tNote that this function can be misleading. If the element foo was created from\n\t\tthis XML:\n\t\t@verbatim\n\t\t<foo><b>This is text</b></foo> \n\t\t@endverbatim\n\n\t\tthen the value of str would be null. The first child node isn't a text node, it is\n\t\tanother element. From this XML:\n\t\t@verbatim\n\t\t<foo>This is <b>text</b></foo> \n\t\t@endverbatim\n\t\tGetText() will return \"This is \".\n\n\t\tWARNING: GetText() accesses a child node - don't become confused with the \n\t\t\t\t similarly named TiXmlHandle::Text() and TiXmlNode::ToText() which are \n\t\t\t\t safe type casts on the referenced node.\n\t*/\n\tconst char* GetText() const;\n\n\t/// Creates a new Element and returns it - the returned element is a copy.\n\tvirtual TiXmlNode* Clone() const;\n\t// Print the Element to a FILE stream.\n\tvirtual void Print( FILE* cfile, int depth ) const;\n\n\t/*\tAttribtue parsing starts: next char past '<'\n\t\t\t\t\t\t returns: next char past '>'\n\t*/\n\tvirtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );\n\n\tvirtual const TiXmlElement*     ToElement()     const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\tvirtual TiXmlElement*           ToElement()\t          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\n\t/** Walk the XML tree visiting this node and all of its children. \n\t*/\n\tvirtual bool Accept( TiXmlVisitor* visitor ) const;\n\nprotected:\n\n\tvoid CopyTo( TiXmlElement* target ) const;\n\tvoid ClearThis();\t// like clear, but initializes 'this' object as well\n\n\t// Used to be public [internal use]\n\t#ifdef TIXML_USE_STL\n\tvirtual void StreamIn( std::istream * in, TIXML_STRING * tag );\n\t#endif\n\t/*\t[internal use]\n\t\tReads the \"value\" of the element -- another element, or text.\n\t\tThis should terminate with the current end tag.\n\t*/\n\tconst char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );\n\nprivate:\n\tTiXmlAttributeSet attributeSet;\n};\n\n\n/**\tAn XML comment.\n*/\nclass TiXmlComment : public TiXmlNode\n{\npublic:\n\t/// Constructs an empty comment.\n\tTiXmlComment() : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {}\n\t/// Construct a comment from text.\n\tTiXmlComment( const char* _value ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT ) {\n\t\tSetValue( _value );\n\t}\n\tTiXmlComment( const TiXmlComment& );\n\tTiXmlComment& operator=( const TiXmlComment& base );\n\n\tvirtual ~TiXmlComment()\t{}\n\n\t/// Returns a copy of this Comment.\n\tvirtual TiXmlNode* Clone() const;\n\t// Write this Comment to a FILE stream.\n\tvirtual void Print( FILE* cfile, int depth ) const;\n\n\t/*\tAttribtue parsing starts: at the ! of the !--\n\t\t\t\t\t\t returns: next char past '>'\n\t*/\n\tvirtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );\n\n\tvirtual const TiXmlComment*  ToComment() const\t{ return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\tvirtual\t\t  TiXmlComment*  ToComment()\t\t{ return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\n\t/** Walk the XML tree visiting this node and all of its children. \n\t*/\n\tvirtual bool Accept( TiXmlVisitor* visitor ) const;\n\nprotected:\n\tvoid CopyTo( TiXmlComment* target ) const;\n\n\t// used to be public\n\t#ifdef TIXML_USE_STL\n\tvirtual void StreamIn( std::istream * in, TIXML_STRING * tag );\n\t#endif\n//\tvirtual void StreamOut( TIXML_OSTREAM * out ) const;\n\nprivate:\n\n};\n\n\n/** XML text. A text node can have 2 ways to output the next. \"normal\" output \n\tand CDATA. It will default to the mode it was parsed from the XML file and\n\tyou generally want to leave it alone, but you can change the output mode with \n\tSetCDATA() and query it with CDATA().\n*/\nclass TiXmlText : public TiXmlNode\n{\n\tfriend class TiXmlElement;\npublic:\n\t/** Constructor for text element. By default, it is treated as \n\t\tnormal, encoded text. If you want it be output as a CDATA text\n\t\telement, set the parameter _cdata to 'true'\n\t*/\n\tTiXmlText (const char * initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)\n\t{\n\t\tSetValue( initValue );\n\t\tcdata = false;\n\t}\n\tvirtual ~TiXmlText() {}\n\n\t#ifdef TIXML_USE_STL\n\t/// Constructor.\n\tTiXmlText( const wxString& initValue ) : TiXmlNode (TiXmlNode::TINYXML_TEXT)\n\t{\n\t\tSetValue( initValue );\n\t\tcdata = false;\n\t}\n\t#endif\n\n\tTiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TINYXML_TEXT )\t{ copy.CopyTo( this ); }\n\tTiXmlText& operator=( const TiXmlText& base )\t\t\t\t\t\t\t \t{ base.CopyTo( this ); return *this; }\n\n\t// Write this text object to a FILE stream.\n\tvirtual void Print( FILE* cfile, int depth ) const;\n\n\t/// Queries whether this represents text using a CDATA section.\n\tbool CDATA() const\t\t\t\t{ return cdata; }\n\t/// Turns on or off a CDATA representation of text.\n\tvoid SetCDATA( bool _cdata )\t{ cdata = _cdata; }\n\n\tvirtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );\n\n\tvirtual const TiXmlText* ToText() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\tvirtual TiXmlText*       ToText()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\n\t/** Walk the XML tree visiting this node and all of its children. \n\t*/\n\tvirtual bool Accept( TiXmlVisitor* content ) const;\n\nprotected :\n\t///  [internal use] Creates a new Element and returns it.\n\tvirtual TiXmlNode* Clone() const;\n\tvoid CopyTo( TiXmlText* target ) const;\n\n\tbool Blank() const;\t// returns true if all white space and new lines\n\t// [internal use]\n\t#ifdef TIXML_USE_STL\n\tvirtual void StreamIn( std::istream * in, TIXML_STRING * tag );\n\t#endif\n\nprivate:\n\tbool cdata;\t\t\t// true if this should be input and output as a CDATA style text element\n};\n\n\n/** In correct XML the declaration is the first entry in the file.\n\t@verbatim\n\t\t<?xml version=\"1.0\" standalone=\"yes\"?>\n\t@endverbatim\n\n\tTinyXml will happily read or write files without a declaration,\n\thowever. There are 3 possible attributes to the declaration:\n\tversion, encoding, and standalone.\n\n\tNote: In this version of the code, the attributes are\n\thandled as special cases, not generic attributes, simply\n\tbecause there can only be at most 3 and they are always the same.\n*/\nclass TiXmlDeclaration : public TiXmlNode\n{\npublic:\n\t/// Construct an empty declaration.\n\tTiXmlDeclaration()   : TiXmlNode( TiXmlNode::TINYXML_DECLARATION ) {}\n\n#ifdef TIXML_USE_STL\n\t/// Constructor.\n\tTiXmlDeclaration(\tconst wxString& _version,\n\t\t\t\t\t\tconst wxString& _encoding,\n\t\t\t\t\t\tconst wxString& _standalone );\n#endif\n\n\t/// Construct.\n\tTiXmlDeclaration(\tconst char* _version,\n\t\t\t\t\t\tconst char* _encoding,\n\t\t\t\t\t\tconst char* _standalone );\n\n\tTiXmlDeclaration( const TiXmlDeclaration& copy );\n\tTiXmlDeclaration& operator=( const TiXmlDeclaration& copy );\n\n\tvirtual ~TiXmlDeclaration()\t{}\n\n\t/// Version. Will return an empty string if none was found.\n\tconst char *Version() const\t\t\t{ return version.c_str (); }\n\t/// Encoding. Will return an empty string if none was found.\n\tconst char *Encoding() const\t\t{ return encoding.c_str (); }\n\t/// Is this a standalone document?\n\tconst char *Standalone() const\t\t{ return standalone.c_str (); }\n\n\t/// Creates a copy of this Declaration and returns it.\n\tvirtual TiXmlNode* Clone() const;\n\t// Print this declaration to a FILE stream.\n\tvirtual void Print( FILE* cfile, int depth, TIXML_STRING* str ) const;\n\tvirtual void Print( FILE* cfile, int depth ) const {\n\t\tPrint( cfile, depth, 0 );\n\t}\n\n\tvirtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );\n\n\tvirtual const TiXmlDeclaration* ToDeclaration() const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\tvirtual TiXmlDeclaration*       ToDeclaration()       { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\n\t/** Walk the XML tree visiting this node and all of its children. \n\t*/\n\tvirtual bool Accept( TiXmlVisitor* visitor ) const;\n\nprotected:\n\tvoid CopyTo( TiXmlDeclaration* target ) const;\n\t// used to be public\n\t#ifdef TIXML_USE_STL\n\tvirtual void StreamIn( std::istream * in, TIXML_STRING * tag );\n\t#endif\n\nprivate:\n\n\tTIXML_STRING version;\n\tTIXML_STRING encoding;\n\tTIXML_STRING standalone;\n};\n\n\n/** Any tag that tinyXml doesn't recognize is saved as an\n\tunknown. It is a tag of text, but should not be modified.\n\tIt will be written back to the XML, unchanged, when the file\n\tis saved.\n\n\tDTD tags get thrown into TiXmlUnknowns.\n*/\nclass TiXmlUnknown : public TiXmlNode\n{\npublic:\n\tTiXmlUnknown() : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )\t{}\n\tvirtual ~TiXmlUnknown() {}\n\n\tTiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::TINYXML_UNKNOWN )\t\t{ copy.CopyTo( this ); }\n\tTiXmlUnknown& operator=( const TiXmlUnknown& copy )\t\t\t\t\t\t\t\t\t\t{ copy.CopyTo( this ); return *this; }\n\n\t/// Creates a copy of this Unknown and returns it.\n\tvirtual TiXmlNode* Clone() const;\n\t// Print this Unknown to a FILE stream.\n\tvirtual void Print( FILE* cfile, int depth ) const;\n\n\tvirtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );\n\n\tvirtual const TiXmlUnknown*     ToUnknown()     const\t{ return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\tvirtual TiXmlUnknown*           ToUnknown()\t\t\t\t{ return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\n\t/** Walk the XML tree visiting this node and all of its children. \n\t*/\n\tvirtual bool Accept( TiXmlVisitor* content ) const;\n\nprotected:\n\tvoid CopyTo( TiXmlUnknown* target ) const;\n\n\t#ifdef TIXML_USE_STL\n\tvirtual void StreamIn( std::istream * in, TIXML_STRING * tag );\n\t#endif\n\nprivate:\n\n};\n\n\n/** Always the top level node. A document binds together all the\n\tXML pieces. It can be saved, loaded, and printed to the screen.\n\tThe 'value' of a document node is the xml file name.\n*/\nclass TiXmlDocument : public TiXmlNode\n{\npublic:\n\t/// Create an empty document, that has no name.\n\tTiXmlDocument();\n\t/// Create a document with a name. The name of the document is also the filename of the xml.\n\tTiXmlDocument( const char * documentName );\n\n\t#ifdef TIXML_USE_STL\n\t/// Constructor.\n\tTiXmlDocument( const wxString& documentName );\n\t#endif\n\n\tTiXmlDocument( const TiXmlDocument& copy );\n\tTiXmlDocument& operator=( const TiXmlDocument& copy );\n\n\tvirtual ~TiXmlDocument() {}\n\n\t/** Load a file using the current document value.\n\t\tReturns true if successful. Will delete any existing\n\t\tdocument data before loading.\n\t*/\n\tbool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );\n\t/// Save a file using the current document value. Returns true if successful.\n\tbool SaveFile() const;\n\t/// Load a file using the given filename. Returns true if successful.\n\tbool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );\n\t/// Save a file using the given filename. Returns true if successful.\n\tbool SaveFile( const char * filename ) const;\n\t/** Load a file using the given FILE*. Returns true if successful. Note that this method\n\t\tdoesn't stream - the entire object pointed at by the FILE*\n\t\twill be interpreted as an XML file. TinyXML doesn't stream in XML from the current\n\t\tfile location. Streaming may be added in the future.\n\t*/\n\tbool LoadFile( FILE*, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );\n\t/// Save a file using the given FILE*. Returns true if successful.\n\tbool SaveFile( FILE* ) const;\n\n\t#ifdef TIXML_USE_STL\n\tbool LoadFile( const wxString& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )\t\t\t///< STL wxString version.\n\t{\n\t\treturn LoadFile( filename.c_str(), encoding );\n\t}\n\tbool SaveFile( const wxString& filename ) const\t\t///< STL wxString version.\n\t{\n\t\treturn SaveFile( filename.c_str() );\n\t}\n\t#endif\n\n\t/** Parse the given null terminated block of xml data. Passing in an encoding to this\n\t\tmethod (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml\n\t\tto use that encoding, regardless of what TinyXml might otherwise try to detect.\n\t*/\n\tvirtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );\n\n\t/** Get the root element -- the only top level element -- of the document.\n\t\tIn well formed XML, there should only be one. TinyXml is tolerant of\n\t\tmultiple elements at the document level.\n\t*/\n\tconst TiXmlElement* RootElement() const\t\t{ return FirstChildElement(); }\n\tTiXmlElement* RootElement()\t\t\t\t\t{ return FirstChildElement(); }\n\n\t/** If an error occurs, Error will be set to true. Also,\n\t\t- The ErrorId() will contain the integer identifier of the error (not generally useful)\n\t\t- The ErrorDesc() method will return the name of the error. (very useful)\n\t\t- The ErrorRow() and ErrorCol() will return the location of the error (if known)\n\t*/\t\n\tbool Error() const\t\t\t\t\t\t{ return error; }\n\n\t/// Contains a textual (english) description of the error if one occurs.\n\tconst char * ErrorDesc() const\t{ return errorDesc.c_str (); }\n\n\t/** Generally, you probably want the error string ( ErrorDesc() ). But if you\n\t\tprefer the ErrorId, this function will fetch it.\n\t*/\n\tint ErrorId()\tconst\t\t\t\t{ return errorId; }\n\n\t/** Returns the location (if known) of the error. The first column is column 1, \n\t\tand the first row is row 1. A value of 0 means the row and column wasn't applicable\n\t\t(memory errors, for example, have no row/column) or the parser lost the error. (An\n\t\terror in the error reporting, in that case.)\n\n\t\t@sa SetTabSize, Row, Column\n\t*/\n\tint ErrorRow() const\t{ return errorLocation.row+1; }\n\tint ErrorCol() const\t{ return errorLocation.col+1; }\t///< The column where the error occured. See ErrorRow()\n\n\t/** SetTabSize() allows the error reporting functions (ErrorRow() and ErrorCol())\n\t\tto report the correct values for row and column. It does not change the output\n\t\tor input in any way.\n\t\t\n\t\tBy calling this method, with a tab size\n\t\tgreater than 0, the row and column of each node and attribute is stored\n\t\twhen the file is loaded. Very useful for tracking the DOM back in to\n\t\tthe source file.\n\n\t\tThe tab size is required for calculating the location of nodes. If not\n\t\tset, the default of 4 is used. The tabsize is set per document. Setting\n\t\tthe tabsize to 0 disables row/column tracking.\n\n\t\tNote that row and column tracking is not supported when using operator>>.\n\n\t\tThe tab size needs to be enabled before the parse or load. Correct usage:\n\t\t@verbatim\n\t\tTiXmlDocument doc;\n\t\tdoc.SetTabSize( 8 );\n\t\tdoc.Load( \"myfile.xml\" );\n\t\t@endverbatim\n\n\t\t@sa Row, Column\n\t*/\n\tvoid SetTabSize( int _tabsize )\t\t{ tabsize = _tabsize; }\n\n\tint TabSize() const\t{ return tabsize; }\n\n\t/** If you have handled the error, it can be reset with this call. The error\n\t\tstate is automatically cleared if you Parse a new XML block.\n\t*/\n\tvoid ClearError()\t\t\t\t\t\t{\terror = false; \n\t\t\t\t\t\t\t\t\t\t\t\terrorId = 0; \n\t\t\t\t\t\t\t\t\t\t\t\terrorDesc = \"\"; \n\t\t\t\t\t\t\t\t\t\t\t\terrorLocation.row = errorLocation.col = 0; \n\t\t\t\t\t\t\t\t\t\t\t\t//errorLocation.last = 0; \n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t/** Write the document to standard out using formatted printing (\"pretty print\"). */\n\tvoid Print() const\t\t\t\t\t\t{ Print( stdout, 0 ); }\n\n\t/* Write the document to a string using formatted printing (\"pretty print\"). This\n\t\twill allocate a character array (new char[]) and return it as a pointer. The\n\t\tcalling code pust call delete[] on the return char* to avoid a memory leak.\n\t*/\n\t//char* PrintToMemory() const; \n\n\t/// Print this Document to a FILE stream.\n\tvirtual void Print( FILE* cfile, int depth = 0 ) const;\n\t// [internal use]\n\tvoid SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );\n\n\tvirtual const TiXmlDocument*    ToDocument()    const { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\tvirtual TiXmlDocument*          ToDocument()          { return this; } ///< Cast to a more defined type. Will return null not of the requested type.\n\n\t/** Walk the XML tree visiting this node and all of its children. \n\t*/\n\tvirtual bool Accept( TiXmlVisitor* content ) const;\n\nprotected :\n\t// [internal use]\n\tvirtual TiXmlNode* Clone() const;\n\t#ifdef TIXML_USE_STL\n\tvirtual void StreamIn( std::istream * in, TIXML_STRING * tag );\n\t#endif\n\nprivate:\n\tvoid CopyTo( TiXmlDocument* target ) const;\n\n\tbool error;\n\tint  errorId;\n\tTIXML_STRING errorDesc;\n\tint tabsize;\n\tTiXmlCursor errorLocation;\n\tbool useMicrosoftBOM;\t\t// the UTF-8 BOM were found when read. Note this, and try to write.\n};\n\n\n/**\n\tA TiXmlHandle is a class that wraps a node pointer with null checks; this is\n\tan incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml\n\tDOM structure. It is a separate utility class.\n\n\tTake an example:\n\t@verbatim\n\t<Document>\n\t\t<Element attributeA = \"valueA\">\n\t\t\t<Child attributeB = \"value1\" />\n\t\t\t<Child attributeB = \"value2\" />\n\t\t</Element>\n\t<Document>\n\t@endverbatim\n\n\tAssuming you want the value of \"attributeB\" in the 2nd \"Child\" element, it's very \n\teasy to write a *lot* of code that looks like:\n\n\t@verbatim\n\tTiXmlElement* root = document.FirstChildElement( \"Document\" );\n\tif ( root )\n\t{\n\t\tTiXmlElement* element = root->FirstChildElement( \"Element\" );\n\t\tif ( element )\n\t\t{\n\t\t\tTiXmlElement* child = element->FirstChildElement( \"Child\" );\n\t\t\tif ( child )\n\t\t\t{\n\t\t\t\tTiXmlElement* child2 = child->NextSiblingElement( \"Child\" );\n\t\t\t\tif ( child2 )\n\t\t\t\t{\n\t\t\t\t\t// Finally do something useful.\n\t@endverbatim\n\n\tAnd that doesn't even cover \"else\" cases. TiXmlHandle addresses the verbosity\n\tof such code. A TiXmlHandle checks for null\tpointers so it is perfectly safe \n\tand correct to use:\n\n\t@verbatim\n\tTiXmlHandle docHandle( &document );\n\tTiXmlElement* child2 = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).Child( \"Child\", 1 ).ToElement();\n\tif ( child2 )\n\t{\n\t\t// do something useful\n\t@endverbatim\n\n\tWhich is MUCH more concise and useful.\n\n\tIt is also safe to copy handles - internally they are nothing more than node pointers.\n\t@verbatim\n\tTiXmlHandle handleCopy = handle;\n\t@endverbatim\n\n\tWhat they should not be used for is iteration:\n\n\t@verbatim\n\tint i=0; \n\twhile ( true )\n\t{\n\t\tTiXmlElement* child = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).Child( \"Child\", i ).ToElement();\n\t\tif ( !child )\n\t\t\tbreak;\n\t\t// do something\n\t\t++i;\n\t}\n\t@endverbatim\n\n\tIt seems reasonable, but it is in fact two embedded while loops. The Child method is \n\ta linear walk to find the element, so this code would iterate much more than it needs \n\tto. Instead, prefer:\n\n\t@verbatim\n\tTiXmlElement* child = docHandle.FirstChild( \"Document\" ).FirstChild( \"Element\" ).FirstChild( \"Child\" ).ToElement();\n\n\tfor( child; child; child=child->NextSiblingElement() )\n\t{\n\t\t// do something\n\t}\n\t@endverbatim\n*/\nclass TiXmlHandle\n{\npublic:\n\t/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.\n\tTiXmlHandle( TiXmlNode* _node )\t\t\t\t\t{ this->node = _node; }\n\t/// Copy constructor\n\tTiXmlHandle( const TiXmlHandle& ref )\t\t\t{ this->node = ref.node; }\n\tTiXmlHandle operator=( const TiXmlHandle& ref ) { if ( &ref != this ) this->node = ref.node; return *this; }\n\n\t/// Return a handle to the first child node.\n\tTiXmlHandle FirstChild() const;\n\t/// Return a handle to the first child node with the given name.\n\tTiXmlHandle FirstChild( const char * value ) const;\n\t/// Return a handle to the first child element.\n\tTiXmlHandle FirstChildElement() const;\n\t/// Return a handle to the first child element with the given name.\n\tTiXmlHandle FirstChildElement( const char * value ) const;\n\n\t/** Return a handle to the \"index\" child with the given name. \n\t\tThe first child is 0, the second 1, etc.\n\t*/\n\tTiXmlHandle Child( const char* value, int index ) const;\n\t/** Return a handle to the \"index\" child. \n\t\tThe first child is 0, the second 1, etc.\n\t*/\n\tTiXmlHandle Child( int index ) const;\n\t/** Return a handle to the \"index\" child element with the given name. \n\t\tThe first child element is 0, the second 1, etc. Note that only TiXmlElements\n\t\tare indexed: other types are not counted.\n\t*/\n\tTiXmlHandle ChildElement( const char* value, int index ) const;\n\t/** Return a handle to the \"index\" child element. \n\t\tThe first child element is 0, the second 1, etc. Note that only TiXmlElements\n\t\tare indexed: other types are not counted.\n\t*/\n\tTiXmlHandle ChildElement( int index ) const;\n\n\t#ifdef TIXML_USE_STL\n\tTiXmlHandle FirstChild( const wxString& _value ) const\t\t\t\t{ return FirstChild( _value.c_str() ); }\n\tTiXmlHandle FirstChildElement( const wxString& _value ) const\t\t{ return FirstChildElement( _value.c_str() ); }\n\n\tTiXmlHandle Child( const wxString& _value, int index ) const\t\t\t{ return Child( _value.c_str(), index ); }\n\tTiXmlHandle ChildElement( const wxString& _value, int index ) const\t{ return ChildElement( _value.c_str(), index ); }\n\t#endif\n\n\t/** Return the handle as a TiXmlNode. This may return null.\n\t*/\n\tTiXmlNode* ToNode() const\t\t\t{ return node; } \n\t/** Return the handle as a TiXmlElement. This may return null.\n\t*/\n\tTiXmlElement* ToElement() const\t\t{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }\n\t/**\tReturn the handle as a TiXmlText. This may return null.\n\t*/\n\tTiXmlText* ToText() const\t\t\t{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }\n\t/** Return the handle as a TiXmlUnknown. This may return null.\n\t*/\n\tTiXmlUnknown* ToUnknown() const\t\t{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }\n\n\t/** @deprecated use ToNode. \n\t\tReturn the handle as a TiXmlNode. This may return null.\n\t*/\n\tTiXmlNode* Node() const\t\t\t{ return ToNode(); } \n\t/** @deprecated use ToElement. \n\t\tReturn the handle as a TiXmlElement. This may return null.\n\t*/\n\tTiXmlElement* Element() const\t{ return ToElement(); }\n\t/**\t@deprecated use ToText()\n\t\tReturn the handle as a TiXmlText. This may return null.\n\t*/\n\tTiXmlText* Text() const\t\t\t{ return ToText(); }\n\t/** @deprecated use ToUnknown()\n\t\tReturn the handle as a TiXmlUnknown. This may return null.\n\t*/\n\tTiXmlUnknown* Unknown() const\t{ return ToUnknown(); }\n\nprivate:\n\tTiXmlNode* node;\n};\n\n\n/** Print to memory functionality. The TiXmlPrinter is useful when you need to:\n\n\t-# Print to memory (especially in non-STL mode)\n\t-# Control formatting (line endings, etc.)\n\n\tWhen constructed, the TiXmlPrinter is in its default \"pretty printing\" mode.\n\tBefore calling Accept() you can call methods to control the printing\n\tof the XML document. After TiXmlNode::Accept() is called, the printed document can\n\tbe accessed via the CStr(), Str(), and Size() methods.\n\n\tTiXmlPrinter uses the Visitor API.\n\t@verbatim\n\tTiXmlPrinter printer;\n\tprinter.SetIndent( \"\\t\" );\n\n\tdoc.Accept( &printer );\n\tfprintf( stdout, \"%s\", printer.CStr() );\n\t@endverbatim\n*/\nclass TiXmlPrinter : public TiXmlVisitor\n{\npublic:\n\tTiXmlPrinter() : depth( 0 ), simpleTextPrint( false ),\n\t\t\t\t\t buffer(), indent( \"    \" ), lineBreak( \"\\n\" ) {}\n\n\tvirtual bool VisitEnter( const TiXmlDocument& doc );\n\tvirtual bool VisitExit( const TiXmlDocument& doc );\n\n\tvirtual bool VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute );\n\tvirtual bool VisitExit( const TiXmlElement& element );\n\n\tvirtual bool Visit( const TiXmlDeclaration& declaration );\n\tvirtual bool Visit( const TiXmlText& text );\n\tvirtual bool Visit( const TiXmlComment& comment );\n\tvirtual bool Visit( const TiXmlUnknown& unknown );\n\n\t/** Set the indent characters for printing. By default 4 spaces\n\t\tbut tab (\\t) is also useful, or null/empty string for no indentation.\n\t*/\n\tvoid SetIndent( const char* _indent )\t\t\t{ indent = _indent ? _indent : \"\" ; }\n\t/// Query the indention string.\n\tconst char* Indent()\t\t\t\t\t\t\t{ return indent.c_str(); }\n\t/** Set the line breaking string. By default set to newline (\\n). \n\t\tSome operating systems prefer other characters, or can be\n\t\tset to the null/empty string for no indenation.\n\t*/\n\tvoid SetLineBreak( const char* _lineBreak )\t\t{ lineBreak = _lineBreak ? _lineBreak : \"\"; }\n\t/// Query the current line breaking string.\n\tconst char* LineBreak()\t\t\t\t\t\t\t{ return lineBreak.c_str(); }\n\n\t/** Switch over to \"stream printing\" which is the most dense formatting without \n\t\tlinebreaks. Common when the XML is needed for network transmission.\n\t*/\n\tvoid SetStreamPrinting()\t\t\t\t\t\t{ indent = \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t  lineBreak = \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\t\n\t/// Return the result.\n\tconst char* CStr()\t\t\t\t\t\t\t\t{ return buffer.c_str(); }\n\t/// Return the length of the result string.\n\tsize_t Size()\t\t\t\t\t\t\t\t\t{ return buffer.size(); }\n\n\t#ifdef TIXML_USE_STL\n\t/// Return the result.\n\tconst wxString& Str()\t\t\t\t\t\t{ return buffer; }\n\t#endif\n\nprivate:\n\tvoid DoIndent()\t{\n\t\tfor( int i=0; i<depth; ++i )\n\t\t\tbuffer += indent;\n\t}\n\tvoid DoLineBreak() {\n\t\tbuffer += lineBreak;\n\t}\n\n\tint depth;\n\tbool simpleTextPrint;\n\tTIXML_STRING buffer;\n\tTIXML_STRING indent;\n\tTIXML_STRING lineBreak;\n};\n\n\n#ifdef _MSC_VER\n#pragma warning( pop )\n#endif\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muslayer.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_LAYER_H__\n#define __MUS_LAYER_H__\n\n#include <typeinfo>\n\n#include \"musclef.h\"\n#include \"musobject.h\"\n#include \"musscoredef.h\"\n\nclass MusDC;\nclass MusLayerElement;\nclass MusNote;\n\n//----------------------------------------------------------------------------\n// MusLayer\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a layer in a laid-out score (MusDoc).\n * A MusLayer is contained in a MusStaff.\n * It contains MusLayerElement objects.\n*/\nclass MusLayer: public MusDocObject, public MusObjectListInterface, public MusScoreOrStaffDefAttrInterface\n{\npublic:\n    // constructors and destructors\n    MusLayer( int n );\n    virtual ~MusLayer();\n    \n    virtual std::string MusClassName( ) { return \"MusLayer\"; };\n    \n    void Clear();\n\t\n\tvoid AddElement( MusLayerElement *element, int idx = -1 );\n    \t\n\tint GetElementCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Return the index position of the layer in its staff parent.\n     * The index position is 0-based.\n     */\n    int GetLayerIdx() const { return MusObject::GetIdx(); };\n    \n    \n    /**\n     * @name Set and get the layer number which is 1-based.\n     * This can be different from the index position in the parent staff.\n     */\n    ///@{\n    int GetLayerNo() const { return m_n; };\n    void SetLayerNo( int n ) { m_n = n; };\n    ///@}\n\n    // functors\n    /**\n     * Copy the elements to a MusLayer passed in parameters. \n     * Also take into account a start and end uuid for the page (if any)\n     */ \n    virtual int CopyToLayer( ArrayPtrVoid params );\n    void CopyElements( ArrayPtrVoid params ); // unused\n    void GetMaxXY( ArrayPtrVoid params ); // unused\n    virtual int Save( ArrayPtrVoid params );\n    void CheckAndResetSectionOrMeasure( ArrayPtrVoid params ); // unused\n    \n\tvoid CopyAttributes( MusLayer *layer ); // copy all attributes but none of the elements\n    \n\tMusLayerElement *GetFirst( );\n\tMusLayerElement *GetLast( );\n\tMusLayerElement *GetNext( MusLayerElement *element );\n\tMusLayerElement *GetPrevious( MusLayerElement *element );\n\tMusLayerElement *GetAtPos( int x );\n\tMusLayerElement *Insert( MusLayerElement *element, int x ); // return a pointer on the inserted element\n    \n    void Insert( MusLayerElement *element, MusLayerElement *before );\n    \n\tvoid Delete( MusLayerElement *element );\n\t\n    /**\n     * Looks for the first MusLayerElement of type elementType.\n     * Looks FORWARD of BACKWARD depending on the direction parameter.\n     * Returns the retrieved element if *succ == true or the original element if not.\n     */\n    MusLayerElement *GetFirst( MusLayerElement *element, unsigned int direction, const std::type_info *elementType, bool *succ );\n    \n    /** \n     * Get the current clef for the test element.\n     * Goes back on the layer until a clef is found.\n     * This is used when inserting a note by passing a y position because we need\n     * to know the clef in order to get the pitch.\n     */\n\tMusClef *GetClef ( MusLayerElement *test );\n    \n    /** \n     * Return the clef offset for the position x.\n     * The method uses MusLayer::GetClef first to find the clef before test.\n     */\n    int GetClefOffset( MusLayerElement *test  );\n    \n    /**\n     * Add an element to the drawing list.\n     * The drawing list is used to postponed the drawing of elements\n     * that need to be drawn in a particular order.\n     * For example, we need to draw beams before tuplets\n     */\n    void AddToDrawingList( MusLayerElement *element );\n\n    /**\n     * Return the darwing list.\n     * This is used when actually darwing the list (see MusRC::DrawLayerList)\n     */\n    ListOfMusObjects *GetDrawingList( );\n\n    /**\n     * Reset the darwing list.\n     * Clears the list - called when the layer starts to be drawn\n     */\n    void ResetDrawingList( );\n    \n    /**\n     * Basic method that remove intermediate clefs and custos.\n     * Used for building collations (See CmpFile::Collate).\n     */\n    void RemoveClefAndCustos( );\n    \n    /**\n     * Checks that the X position of the currentElement is not before the previous element or after the next one.\n     * This works for facsimile (transcription) encodings only because it looks at the m_xAbs position\n     */ \n    void CheckXPosition( MusLayerElement *currentElement );\n    \n    /**\n     * Set drawing clef, keysig and mensur if necessary and if available.\n     * Also set the current clef.\n     */\n    void SetDrawingValues( MusScoreDef *currentScoreDef, MusStaffDef *currentStaffDef );\n    \n\n    //Lyric related methods\n    /*\n\tint GetLyricPos( MusSymbol *lyric );\n\tMusSymbol *GetPreviousLyric( MusSymbol *lyric );\n\tMusSymbol *GetNextLyric( MusSymbol *lyric );\n\tMusSymbol *GetFirstLyric( );\n\tMusSymbol *GetLastLyric( );\n\tMusSymbol *GetLyricAtPos( int x );\n\tvoid DeleteLyric( MusSymbol *symbol );\n\tMusNote *GetNextNote( MusSymbol * lyric );\n\tMusNote *GetPreviousNote( MusSymbol * lyric );\n\tvoid SwitchLyricNoteAssociation( MusSymbol *lyric, MusNote *oldNote, MusNote* newNote, bool beginning );\n\tvoid AdjustLyricLineHeight( int delta );\n    */\n    \n    /**\n     * Align the content of a system.\n     */\n    \n    ///@{\n\n    virtual int Align( ArrayPtrVoid params );\n    \nprivate:\n    \npublic:\n\t/** voix de la portee*/\n\tunsigned short voix;\n    \nprotected:\n    // drawing variables\n    //MusLayerElement *beamListPremier; // we need to replace this with a proper beam class that handles a list of notes/rests\n    ListOfMusObjects m_drawingList;\n    \nprivate:\n    /** The layer number */\n    int m_n;\n\n    /**\n     * The current clef.\n     * This is used for getting the clef when interacting, for example by clicking in order to get the pitch from a position\n     */\n    MusClef m_currentClef;\n    \n};\n\n\n#endif\n","//\n//  musmultirest.h\n//  aruspix\n//\n//  Created by Rodolfo Zitellini on 02/12/13.\n//  Copyright (c) 2013 com.aruspix.www. All rights reserved.\n//\n\n#ifndef __MUS_MULTIREST_H__\n#define __MUS_MULTIREST_H__\n\n#include \"musdef.h\"\n#include \"muslayerelement.h\"\n\n//----------------------------------------------------------------------------\n// MusClef\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <musmultirest> element. \n */\nclass MusMultiRest: public MusLayerElement\n{\npublic:\n    // constructors and destructors\n    MusMultiRest();\n    MusMultiRest(int number);\n    virtual ~MusMultiRest();\n    \n    /**\n     * Comparison operator. \n     * Check if the MusLayerElement if a MusClef and compare attributes\n     */\n    virtual bool operator==(MusObject& other);\n    \n    virtual std::string MusClassName( ) { return \"MusMultiRest\"; };\n    \n    /**\n     * Get the multi measure rest number\n     */\n    int GetNumber() {return m_number;};\n    \n    /**\n     * Set the multi measure rest number.\n     */\n\tvoid SetNumber( int number ) {m_number = number;};\n    \nprivate:\n    /** Indicates the shape and the line of the clef using clef ids  */\n    int m_number;\n    \npublic:\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musiomei.cpp\n// Author:      Laurent Pugin\n// Created:     2008\n// Copyright (c) Laurent Pugin. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musiomei.h\"\n\n//----------------------------------------------------------------------------\n\n#include <algorithm>\n#include <ctime>\n#include <sstream>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musapp.h\"\n#include \"musbarline.h\"\n#include \"musbeam.h\"\n#include \"musclef.h\"\n#include \"muskeysig.h\"\n#include \"muslayer.h\"\n#include \"muslayerelement.h\"\n#include \"musmeasure.h\"\n#include \"musmensur.h\"\n#include \"musmultirest.h\"\n#include \"musnote.h\"\n#include \"muspage.h\"\n#include \"musrest.h\"\n#include \"musscoredef.h\"\n#include \"musstaff.h\"\n#include \"mussymbol.h\"\n#include \"mussystem.h\"\n#include \"mustuplet.h\"\n\n//----------------------------------------------------------------------------\n// MusMeiOutput\n//----------------------------------------------------------------------------\n\nMusMeiOutput::MusMeiOutput( MusDoc *doc, std::string filename ) :\n\tMusFileOutputStream( doc )\n{\n    m_filename = filename;\n    m_mei = NULL;\n    m_pages = NULL;\n    m_page = NULL;\n    m_scoreDef = NULL;\n    m_system = NULL;\n    m_staffGrp = NULL;\n    m_staffDef = NULL;\n    m_measure = NULL;\n    m_staff = NULL;\n    m_layer = NULL;\n    m_rdgLayer = NULL;\n    m_beam = NULL;\n}\n\nMusMeiOutput::~MusMeiOutput()\n{\n}\n\nbool MusMeiOutput::ExportFile( )\n{\n    try {\n        TiXmlDocument *meiDoc = new TiXmlDocument();\n        \n        m_mei = new TiXmlElement(\"mei\");\n        m_mei->SetAttribute( \"xmlns\", \"http://www.music-encoding.org/ns/mei\" );\n        m_mei->SetAttribute( \"meiversion\", \"2013\" );\n\n        // element to place the pages\n        m_pages = new TiXmlElement(\"pages\");\n        m_pages->SetAttribute( \"type\",  DocTypeToStr( m_doc->GetType() ).c_str() );\n        \n        \n        // this starts the call of all the functors\n        m_doc->Save( this );\n        \n        // after the functor has run, we have the header in m_mei and the score in m_score\n        TiXmlElement *mdiv = new TiXmlElement(\"mdiv\");\n        mdiv->LinkEndChild( m_pages );\n        TiXmlElement *body = new TiXmlElement(\"body\");\n        body->LinkEndChild( mdiv );\n        TiXmlElement *music = new TiXmlElement(\"music\");\n        music->LinkEndChild( body );\n        m_mei->LinkEndChild( music );\n        \n        TiXmlUnknown *schema = new TiXmlUnknown();\n        schema->SetValue(\"?xml-model href=\\\"http://www.aruspix.net/mei-page-based-2013-08-29.rng\\\" type=\\\"application/xml\\\" schematypens=\\\"http://relaxng.org/ns/structure/1.0\\\"?\");\n        \n        meiDoc->LinkEndChild( new TiXmlDeclaration( \"1.0\", \"UTF-8\", \"\" ) );\n        meiDoc->LinkEndChild(schema);\n        meiDoc->LinkEndChild(m_mei);\n        meiDoc->SaveFile( m_filename.c_str() );\n    }\n    catch( char * str ) {\n        Mus::LogError(\"%s\", str );\n        return false;\n    }\n\treturn true;    \n}\n\nstd::string MusMeiOutput::UuidToMeiStr( MusObject *element )\n{\n    std::string out = element->GetUuid();\n    std::transform(out.begin(), out.end(), out.begin(), ::tolower);\n    Mus::LogDebug(\"uuid: %s\\n\", out.c_str());\n    return out;\n}\n\nbool MusMeiOutput::WriteDoc( MusDoc *doc )\n{\n    assert( m_mei );\n    \n    // ---- header ----\n    TiXmlElement *meiHead = new TiXmlElement(\"meiHead\");\n    \n    TiXmlElement *fileDesc = new TiXmlElement(\"fileDesc\");\n    TiXmlElement *titleStmt = new TiXmlElement(\"titleStmt\");\n    fileDesc->LinkEndChild(titleStmt);\n    TiXmlElement *title = new TiXmlElement(\"title\");\n    titleStmt->LinkEndChild(title);\n    TiXmlElement *pubStmt = new TiXmlElement(\"pubStmt\");\n    fileDesc->LinkEndChild(pubStmt);\n    TiXmlElement *date = new TiXmlElement(\"date\");\n    pubStmt->LinkEndChild(date);\n    \n    TiXmlElement *encodingDesc = new TiXmlElement(\"encodingDesc\");\n    TiXmlElement *projectDesc = new TiXmlElement(\"projectDesc\");\n    encodingDesc->LinkEndChild(projectDesc);\n    TiXmlElement *p1 = new TiXmlElement(\"p\");\n    projectDesc->LinkEndChild(p1);\n    \n    p1->LinkEndChild( new TiXmlText( Mus::StringFormat( \"Encoded with Aruspix version %s\",  Mus::GetAxVersion().c_str() ).c_str() ) );\n    \n    // date\n    time_t now = time(0);\n    date->LinkEndChild( new TiXmlText( ctime( &now ) ) );\n    \n    meiHead->LinkEndChild(fileDesc);\n    meiHead->LinkEndChild(encodingDesc);\n    m_mei->LinkEndChild( meiHead );\n    \n    return true;\n}\n\n\nbool MusMeiOutput::WritePage( MusPage *page )\n{\n    assert( m_pages );\n    m_page = new TiXmlElement(\"page\");\n    m_page->SetAttribute( \"xml:id\",  UuidToMeiStr( page ).c_str() );\n    // size and margins but only if any - we rely on page.height only to check this\n    if ( page->m_pageHeight != -1 ) {\n        m_page->SetAttribute( \"page.width\", Mus::StringFormat( \"%d\", page->m_pageWidth ).c_str() );\n        m_page->SetAttribute( \"page.height\", Mus::StringFormat( \"%d\", page->m_pageHeight ).c_str() );\n        m_page->SetAttribute( \"page.leftmar\", Mus::StringFormat( \"%d\", page->m_pageLeftMar ).c_str() );\n        m_page->SetAttribute( \"page.rightmar\", Mus::StringFormat( \"%d\", page->m_pageRightMar ).c_str() );\n        m_page->SetAttribute( \"page.rightmar\", Mus::StringFormat( \"%d\", page->m_pageRightMar ).c_str() );\n    }\n    if ( !page->m_surface.empty() ) {\n        m_page->SetAttribute( \"surface\", page->m_surface.c_str() );\n    }\n    //\n    TiXmlComment *comment = new TiXmlComment();\n    comment->SetValue( \"Coordinates in MEI axis direction\" );\n    m_pages->LinkEndChild( comment );\n    m_pages->LinkEndChild( m_page );\n    return true;\n}\n\nbool MusMeiOutput::WriteSystem( MusSystem *system )\n{\n    assert( m_page );\n    m_system = new TiXmlElement(\"system\");\n    m_system->SetAttribute( \"xml:id\",  UuidToMeiStr( system ).c_str() );\n    // margins\n    m_system->SetAttribute( \"system.leftmar\", Mus::StringFormat( \"%d\", system->m_systemLeftMar ).c_str() );\n    m_system->SetAttribute( \"system.rightmar\", Mus::StringFormat( \"%d\", system->m_systemRightMar ).c_str() );\n    // y positions\n    m_system->SetAttribute( \"uly\", Mus::StringFormat( \"%d\", system->m_yAbs ).c_str() );\n    m_page->LinkEndChild( m_system );\n    return true;\n}\n\nbool MusMeiOutput::WriteScoreDef( MusScoreDef *scoreDef )\n{\n    assert( m_system );\n    m_scoreDef = new TiXmlElement(\"scoreDef\");\n    m_scoreDef->SetAttribute( \"xml:id\",  UuidToMeiStr( scoreDef ).c_str() );\n    if (scoreDef->GetClefAttr()) {\n        m_scoreDef->SetAttribute( \"clef.line\", ClefLineToStr( scoreDef->GetClefAttr()->m_clefId ).c_str() );\n        m_scoreDef->SetAttribute( \"clef.shape\", ClefShapeToStr( scoreDef->GetClefAttr()->m_clefId ).c_str() );\n        // we should add 8va attr\n    }\n    if (scoreDef->GetKeySigAttr()) {\n        m_scoreDef->SetAttribute( \"key.sig\", KeySigToStr( scoreDef->GetKeySigAttr()->m_num_alter,\n                                                         scoreDef->GetKeySigAttr()->m_alteration ).c_str() );\n    }\n    // this needs to be fixed\n    m_page->LinkEndChild( m_system );\n    return true;\n    \n}\n\nbool MusMeiOutput::WriteStaffGrp( MusStaffGrp *staffGrp )\n{\n    // for now only as part of a system - this needs to be fixed\n    assert( m_system );\n    m_staffGrp = new TiXmlElement(\"staffGrp\");\n    m_staffGrp->SetAttribute( \"xml:id\",  UuidToMeiStr( staffGrp ).c_str() );\n    if ( staffGrp->GetSymbol() != STAFFGRP_NONE ) {\n        m_staffGrp->SetAttribute( \"symbol\", StaffGrpSymbolToStr( staffGrp->GetSymbol() ).c_str() );\n    }\n    if ( staffGrp->GetBarthru() ) {\n        m_staffGrp->SetAttribute( \"barthru\", BoolToStr( staffGrp->GetBarthru() ).c_str() );\n    }\n    \n    m_system->LinkEndChild( m_staffGrp );\n    return true;\n}\n\nbool MusMeiOutput::WriteStaffDef( MusStaffDef *staffDef )\n{\n    assert( m_staffGrp );\n    m_staffDef = new TiXmlElement(\"staffDef\");\n    m_staffDef->SetAttribute( \"xml:id\",  UuidToMeiStr( staffDef ).c_str() );\n    m_staffDef->SetAttribute( \"n\", Mus::StringFormat( \"%d\", staffDef->GetStaffNo() ).c_str() );\n    if (staffDef->GetClefAttr()) {\n        m_staffDef->SetAttribute( \"clef.line\", ClefLineToStr( staffDef->GetClefAttr()->m_clefId ).c_str() );\n        m_staffDef->SetAttribute( \"clef.shape\", ClefShapeToStr( staffDef->GetClefAttr()->m_clefId ).c_str() );\n        // we should add 8va attr\n    }\n    if (staffDef->GetKeySigAttr()) {\n        m_staffDef->SetAttribute( \"key.sig\", KeySigToStr( staffDef->GetKeySigAttr()->m_num_alter,\n                                                         staffDef->GetKeySigAttr()->m_alteration ).c_str() );\n    }\n\n    m_staffGrp->LinkEndChild( m_staffDef );\n    return true;\n}\n\nbool MusMeiOutput::WriteStaff( MusStaff *staff )\n{\n    assert( m_system );\n    m_staff = new TiXmlElement(\"staff\");\n    m_staff->SetAttribute( \"xml:id\",  UuidToMeiStr( staff ).c_str() );\n    // y position\n    if ( staff->notAnc ) {\n        m_staff->SetAttribute( \"label\", \"mensural\" );\n    }\n    m_staff->SetAttribute( \"uly\", Mus::StringFormat( \"%d\", staff->m_yAbs ).c_str() );\n    m_staff->SetAttribute( \"n\", Mus::StringFormat( \"%d\", staff->GetStaffNo() ).c_str() );\n\n    m_system->LinkEndChild( m_staff );\n    return true;\n}\n\nbool MusMeiOutput::WriteMeasure( MusMeasure *measure )\n{\n    assert( m_staff );\n    m_measure = new TiXmlElement(\"measure\");\n    m_measure->SetAttribute( \"xml:id\",  UuidToMeiStr( measure ).c_str() );\n    m_measure->SetAttribute( \"n\", Mus::StringFormat( \"%d\", measure->m_logMeasureNb ).c_str() );\n    m_staff->LinkEndChild( m_measure );\n    return true;\n}\n\nbool MusMeiOutput::WriteLayer( MusLayer *layer )\n{\n    assert( m_staff );\n    m_layer = new TiXmlElement(\"layer\");\n    m_layer->SetAttribute( \"xml:id\",  UuidToMeiStr( layer ).c_str() );\n    m_layer->SetAttribute( \"n\", Mus::StringFormat( \"%d\", layer->GetLayerNo() ).c_str() );\n    if ( m_measure ) {\n        m_measure->LinkEndChild( m_layer );\n    }\n    else {\n        m_staff->LinkEndChild( m_layer );\n    }\n    return true;\n}\n\nbool MusMeiOutput::WriteLayerElement( MusLayerElement *element )\n{\n    assert( m_layer );\n    \n    // Here we look at what is the parent.\n    // For example, if we are in a beam, we must attach it to the beam xml element (m_beam)\n    // By default, we attach it to m_layer\n    TiXmlElement *currentParent = m_layer;\n    if ( dynamic_cast<MusLayerRdg*>(element->m_parent) ) {\n        assert( m_rdgLayer );\n        currentParent = m_rdgLayer;\n    }\n    else if ( dynamic_cast<MusBeam*>(element->m_parent) ) {\n        assert( m_beam );\n        currentParent = m_beam;\n    }\n    else if ( dynamic_cast<MusTuplet*>(element->m_parent) ) {\n        assert( m_tuplet );\n        currentParent = m_tuplet;\n    }\n    // we should do the same for any MusLayerElement container (slur, tuplet, etc. )\n    \n    TiXmlElement *xmlElement = NULL;\n    if (dynamic_cast<MusBarline*>(element)) {\n        xmlElement = new TiXmlElement( \"barline\" );\n        WriteMeiBarline( xmlElement, dynamic_cast<MusBarline*>(element) );\n    }\n    else if (dynamic_cast<MusBeam*>(element)) {\n        xmlElement = new TiXmlElement(\"beam\");\n        m_beam = xmlElement;\n        WriteMeiBeam( xmlElement, dynamic_cast<MusBeam*>(element) );\n    }\n    else if (dynamic_cast<MusClef*>(element)) {\n        xmlElement = new TiXmlElement(\"clef\");\n        WriteMeiClef( xmlElement, dynamic_cast<MusClef*>(element) );\n    }\n    else if (dynamic_cast<MusMensur*>(element)) {\n        xmlElement = new TiXmlElement(\"mensur\");\n        WriteMeiMensur( xmlElement, dynamic_cast<MusMensur*>(element) );\n    }\n    else if (dynamic_cast<MusMultiRest*>(element)) {\n        xmlElement = new TiXmlElement(\"multiRest\");\n        WriteMeiMultiRest( xmlElement, dynamic_cast<MusMultiRest*>(element) );\n    }\n    else if (dynamic_cast<MusNote*>(element)) {\n        xmlElement = new TiXmlElement(\"note\");\n        WriteMeiNote( xmlElement, dynamic_cast<MusNote*>(element) );\n    }\n    else if (dynamic_cast<MusRest*>(element)) {\n        xmlElement = new TiXmlElement(\"rest\");\n        WriteMeiRest( xmlElement, dynamic_cast<MusRest*>(element) );\n    }\n    else if (dynamic_cast<MusTuplet*>(element)) {\n        xmlElement = new TiXmlElement(\"tuplet\");\n        m_tuplet = xmlElement;\n        WriteMeiTuplet( xmlElement, dynamic_cast<MusTuplet*>(element) );\n    }\n    else if (dynamic_cast<MusSymbol*>(element)) {        \n        xmlElement = WriteMeiSymbol( dynamic_cast<MusSymbol*>(element) );\n    }\n    \n    // we have it, set the uuid we read\n    if ( xmlElement ) {\n        this->WriteSameAsAttr( xmlElement, element );\n        xmlElement->SetAttribute( \"xml:id\",  UuidToMeiStr( element ).c_str() );\n        if ( element->m_xAbs != AX_UNSET) {\n            xmlElement->SetAttribute( \"ulx\", Mus::StringFormat( \"%d\", element->m_xAbs ).c_str() );\n        }\n        currentParent->LinkEndChild( xmlElement );\n        return true;\n    }\n    else {\n        Mus::LogWarning( \"Element class %s could not be saved\", element->MusClassName().c_str() );\n        return false;\n    }    \n}\n\nvoid MusMeiOutput::WriteMeiBarline( TiXmlElement *meiBarline, MusBarline *barline )\n{\n    return;\n}\n\n\nvoid MusMeiOutput::WriteMeiBeam( TiXmlElement *meiBeam, MusBeam *beam )\n{\n    return;\n}\n\n\nvoid MusMeiOutput::WriteMeiClef( TiXmlElement *meiClef, MusClef *clef )\n{\n    meiClef->SetAttribute( \"line\", ClefLineToStr( clef->m_clefId ).c_str() );\n    meiClef->SetAttribute( \"shape\", ClefShapeToStr( clef->m_clefId ).c_str() );\n    // we should add 8va attr\n    return;\n}\n\n\nvoid MusMeiOutput::WriteMeiMensur( TiXmlElement *meiMensur, MusMensur *mensur )\n{\n    if ( mensur->m_sign ) {\n        meiMensur->SetAttribute( \"sign\", MensurSignToStr( mensur->m_sign ).c_str() );\n    }\n    if ( mensur->m_dot ) {\n        meiMensur->SetAttribute( \"dot\", \"true\" );\n    }\n    if ( mensur->m_slash ) {\n        meiMensur->SetAttribute( \"slash\", \"1\" ); // only one slash for now\n    }\n    if ( mensur->m_reversed ) {\n        meiMensur->SetAttribute( \"orient\", \"reversed\" ); // only orientation\n    }\n    if ( mensur->m_num ) {\n        meiMensur->SetAttribute( \"num\", Mus::StringFormat(\"%d\", mensur->m_num ).c_str() );\n    }\n    if ( mensur->m_numBase ) {\n        meiMensur->SetAttribute( \"numbase\", Mus::StringFormat(\"%d\", mensur->m_numBase ).c_str() );\n    }\n    // missing m_meterSymb\n    \n    return;\n}\n\nvoid MusMeiOutput::WriteMeiMultiRest( TiXmlElement *meiMultiRest, MusMultiRest *multiRest )\n{\n    meiMultiRest->SetAttribute( \"num\", Mus::StringFormat(\"%d\", multiRest->GetNumber()).c_str() );\n\n    return;\n}\n\nvoid MusMeiOutput::WriteMeiNote( TiXmlElement *meiNote, MusNote *note )\n{\n    meiNote->SetAttribute( \"pname\", PitchToStr( note->m_pname ).c_str() );\n    meiNote->SetAttribute( \"oct\", OctToStr( note->m_oct ).c_str() );\n    meiNote->SetAttribute( \"dur\", DurToStr( note->m_dur ).c_str() );\n    if ( note->m_dots ) {\n        meiNote->SetAttribute( \"dots\", Mus::StringFormat(\"%d\", note->m_dots).c_str() );\n    }\n    if ( note->m_accid ) {\n        meiNote->SetAttribute( \"accid\", AccidToStr( note->m_accid ).c_str() );\n    }\n    if ( note->m_lig ) {\n        if ( note->m_ligObliqua ) {\n            meiNote->SetAttribute( \"lig\", \"obliqua\" );\n        }\n        else {\n            meiNote->SetAttribute( \"lig\", \"recta\" );\n        }\n    }\n    if ( note->m_stemDir ) {\n        // this is not really correct because MusNote::m_stemDir indicates that it is opposite the normal position\n        meiNote->SetAttribute( \"stem.dir\", \"up\" );\n    }\n    if ( note->m_colored ) {\n        meiNote->SetAttribute( \"colored\", \"true\" );\n    }\n    // missing m_artic, m_chord, m_headShape, m_slur, m_stemLen\n    return;\n}\n\nvoid MusMeiOutput::WriteMeiRest( TiXmlElement *meiRest, MusRest *rest )\n{    \n    meiRest->SetAttribute( \"dur\", DurToStr( rest->m_dur ).c_str() );\n    if ( rest->m_dots ) {\n        meiRest->SetAttribute( \"dots\", Mus::StringFormat(\"%d\", rest->m_dots).c_str() );\n    }\n    // missing position\n    meiRest->SetAttribute( \"ploc\", PitchToStr( rest->m_pname ).c_str() );\n    meiRest->SetAttribute( \"oloc\", OctToStr( rest->m_oct ).c_str() );\n    return;\n}\n\nTiXmlElement *MusMeiOutput::WriteMeiSymbol( MusSymbol *symbol )\n{\n    TiXmlElement *xmlElement = NULL;\n    if (symbol->m_type==SYMBOL_ACCID) {\n        TiXmlElement *accid = new TiXmlElement(\"accid\");\n        accid->SetAttribute( \"accid\", AccidToStr( symbol->m_accid ).c_str() );\n        // position\n        accid->SetAttribute( \"ploc\", PitchToStr( symbol->m_pname ).c_str() );\n        accid->SetAttribute( \"oloc\", OctToStr( symbol->m_oct ).c_str() );\n        xmlElement = accid;\n    }\n    else if (symbol->m_type==SYMBOL_CUSTOS) {\n        TiXmlElement *custos = new TiXmlElement(\"custos\");\n        custos->SetAttribute( \"pname\", PitchToStr( symbol->m_pname ).c_str() );\n        custos->SetAttribute( \"oct\", OctToStr( symbol->m_oct ).c_str() );\n        xmlElement = custos;\n    }\n    else if (symbol->m_type==SYMBOL_DOT) {\n        TiXmlElement *dot = new TiXmlElement(\"dot\");\n        // missing m_dots\n        // position\n        dot->SetAttribute( \"ploc\", PitchToStr( symbol->m_pname ).c_str() );\n        dot->SetAttribute( \"oloc\", OctToStr( symbol->m_oct ).c_str() );\n        xmlElement = dot;\n    }\n    return xmlElement;\n}\n\n\nvoid MusMeiOutput::WriteMeiTuplet( TiXmlElement *meiTuplet, MusTuplet *tuplet )\n{\n    return;\n}\n\nbool MusMeiOutput::WriteLayerApp( MusLayerApp *app )\n{    \n    assert( m_layer );\n    m_app = new TiXmlElement(\"app\");\n    m_layer->LinkEndChild( m_app ); \n    return true;\n}\n\nbool MusMeiOutput::WriteLayerRdg( MusLayerRdg *rdg )\n{   \n    assert( m_app );\n    m_rdgLayer = new TiXmlElement(\"rdg\");\n    m_rdgLayer->SetAttribute( \"source\", rdg->m_source.c_str() );\n    m_app->LinkEndChild( m_rdgLayer ); \n    return true;\n}\n\n\nvoid MusMeiOutput::WriteSameAsAttr( TiXmlElement *meiElement, MusObject *element )\n{\n    if ( !element->m_sameAs.empty() ) {\n        meiElement->SetAttribute( \"sameas\", element->m_sameAs.c_str() );\n    }\n}\n\nstd::string MusMeiOutput::BoolToStr(bool value)\n{\n    if (value) return \"true\";\n    return \"false\";\n}\n\nstd::string MusMeiOutput::OctToStr(int oct)\n{\n\tchar buf[3];\n\tsnprintf(buf, 2, \"%d\", oct);\n\treturn std::string(buf);\n\t\n\t// For some reason, #include <sstream> does not work with xcode 3.2\n\t//std::ostringstream oss;\n\t//oss << oct;\n\t//return oss.str();\n}\n\n\nstd::string MusMeiOutput::PitchToStr(int pitch)\n{\n    std::string value;\n    switch (pitch) {\n        case 7:\n        case 0: value = \"b\"; break;\n        case 1: value = \"c\"; break;\n        case 2: value = \"d\"; break;\n        case 3: value = \"e\"; break;\n        case 4: value = \"f\"; break;\n        case 5: value = \"g\"; break;\n        case 6: value = \"a\"; break;\n        default: \n            Mus::LogWarning(\"Unknown pitch '%d'\", pitch);\n            value = \"\";\n            break;\n    }\n\treturn value;\n}\n\nstd::string MusMeiOutput::AccidToStr(unsigned char accid)\n{\n    std::string value;\n    switch (accid) {\n        case ACCID_SHARP: value = \"s\"; break;\n        case ACCID_FLAT: value = \"f\"; break;\n        case ACCID_NATURAL: value = \"n\"; break;\n        case ACCID_DOUBLE_SHARP: value = \"x\"; break;\n        case ACCID_DOUBLE_FLAT: value = \"ff\"; break;\n        case ACCID_QUARTER_SHARP: value = \"ns\"; break;\n        case ACCID_QUARTER_FLAT: value = \"nf\"; break;\n        default: \n            Mus::LogWarning(\"Unknown accid '%d'\", accid);\n            value = \"\";\n            break;\n    }\n\treturn value;\n}\n\nstd::string MusMeiOutput::ClefLineToStr( ClefId clefId )\n{\t\n\tstd::string value; \n\tswitch(clefId)\n\t{\t\n        case SOL2 : value = \"2\"; break;\n\t\tcase SOL1 : value = \"1\"; break; \n\t\tcase SOLva : value = \"2\"; break;\n\t\tcase FA5 : value = \"5\"; break;\n\t\tcase FA4 : value = \"4\"; break;\n\t\tcase FA3 : value = \"3\"; break;\n\t\tcase UT1 : value = \"1\"; break;\n        case UT2 : value = \"2\"; break;\n\t\tcase UT3 : value = \"3\"; break;\n\t\tcase UT4 : value = \"4\"; break;\n\t\tcase UT5 : value = \"5\"; break;\n        default: \n            Mus::LogWarning(\"Unknown clef '%d'\", clefId);\n            value = \"\";\n            break;\n\t}\n\treturn value;\n}\n\nstd::string MusMeiOutput::ClefShapeToStr( ClefId clefId )\n{\t\n\tstd::string value; \n\tswitch(clefId)\n\t{\t\n        case SOL2 : \n\t\tcase SOL1 : \n\t\tcase SOLva : value = \"G\"; break;\n\t\tcase FA5 : \n\t\tcase FA4 :\n\t\tcase FA3 : value = \"F\"; break;\n        case UT1 :\n\t\tcase UT2 : \n\t\tcase UT3 : \n\t\tcase UT4 : \n\t\tcase UT5 : value = \"C\"; break;\t\t\n        default: \n            Mus::LogWarning(\"Unknown clef '%d'\", clefId);\n            value = \"\";\n            break;\n\t}\n\treturn value;\n}\n\nstd::string MusMeiOutput::MensurSignToStr(MensurSign sign)\n{\n \tstd::string value; \n\tswitch(sign)\n\t{\tcase MENSUR_SIGN_C : value = \"C\"; break;\n\t\tcase MENSUR_SIGN_O : value = \"O\"; break;\t\t\n        default: \n            Mus::LogWarning(\"Unknown mensur sign '%d'\", sign);\n            value = \"\";\n            break;\n\t}\n\treturn value;   \n}\n\n\nstd::string MusMeiOutput::DurToStr( int dur )\n{\n    std::string value;\n    if (dur == DUR_LG) value = \"longa\";\n    else if (dur == DUR_BR) value = \"brevis\";\n    else if (dur == DUR_1) value = \"semibrevis\";\n    else if (dur == DUR_2) value = \"minima\";\n    else if (dur == DUR_4) value = \"semiminima\";\n    else if (dur == DUR_8) value = \"fusa\";\n    else if (dur == DUR_16) value = \"semifusa\";\n    else if (dur == DUR_LG) value = \"long\";\n    else if (dur == DUR_BR) value = \"breve\";\n    else if (dur == DUR_1) value = \"1\";\n    else if (dur == DUR_2) value = \"2\";\n    else if (dur == DUR_4) value = \"4\";\n    else if (dur == DUR_8) value = \"8\";\n    else if (dur == DUR_16) value = \"16\";\n    else if (dur == DUR_32) value = \"32\";\n    else if (dur == DUR_64) value = \"64\";\n    else if (dur == DUR_128) value = \"128\";\n\telse {\n\t\tMus::LogWarning(\"Unknown duration '%d'\", dur);\n        value = \"4\";\n\t}\n    return value;\n}\n\nstd::string MusMeiOutput::DocTypeToStr(DocType type)\n{\n \tstd::string value; \n\tswitch(type)\n\t{\t\n        case Raw : value = \"raw\"; break;\n        case Rendering : value = \"rendering\"; break;\n\t\tcase Transcription : value = \"transcription\"; break;\t\t\n        default: \n            Mus::LogWarning(\"Unknown layout type '%d'\", type);\n            value = \"\";\n            break;\n\t}\n\treturn value;   \n}\n\n\nstd::string MusMeiOutput::KeySigToStr(int num, char alter_type )\n{\n \tstd::string value;\n    if (num == 0) {\n        return \"0\";\n    }\n\tswitch(alter_type)\n\t{\tcase ACCID_FLAT : value = Mus::StringFormat(\"%df\", num); break;\n\t\tcase ACCID_SHARP : value = Mus::StringFormat(\"%ds\", num); break;\n        default:\n            Mus::LogWarning(\"Unknown key signature values '%d' and '%d\", num, alter_type);\n            value = \"0\";\n            break;\n\t}\n\treturn value;\n}\n\n\nstd::string MusMeiOutput::StaffGrpSymbolToStr(StaffGrpSymbol symbol)\n{\n \tstd::string value;\n\tswitch(symbol)\n\t{\tcase STAFFGRP_LINE : value = \"line\"; break;\n\t\tcase STAFFGRP_BRACE : value = \"brace\"; break;\n        case STAFFGRP_BRACKET : value = \"bracket\"; break;\n        default:\n            Mus::LogWarning(\"Unknown staffGrp @symbol  '%d'\", symbol);\n            value = \"line\";\n            break;\n\t}\n\treturn value;\n}\n\n\n//----------------------------------------------------------------------------\n// MusMeiInput\n//----------------------------------------------------------------------------\n\nMusMeiInput::MusMeiInput( MusDoc *doc, std::string filename ) :\n\tMusFileInputStream( doc )\n{\n    m_filename = filename;\n    m_doc->m_fname = Mus::GetFilename( filename );\n    m_page = NULL;\n    m_scoreDef = NULL;\n    m_staffDef = NULL;\n    m_system = NULL;\n\tm_staff = NULL;\n    m_measure = NULL;\n\tm_layer = NULL;\n    m_layerApp = NULL;\n    m_layerRdg = NULL;\n    m_beam = NULL;\n    m_tuplet = NULL;\n    //\n    m_currentLayer = NULL;\n    //\n    m_hasScoreDef = false;\n}\n\nMusMeiInput::~MusMeiInput()\n{\n}\n\nbool MusMeiInput::ImportFile( )\n{\n    try {\n        m_doc->Reset( Raw );\n        TiXmlDocument doc( m_filename.c_str() );\n        bool loadOkay = doc.LoadFile();\n        if (!loadOkay)\n        {\n            return false;\n        }\n        TiXmlElement *root = doc.RootElement();\n        return ReadMei( root );\n        }\n    catch( char * str ) {\n        Mus::LogError(\"%s\", str );\n        return false;\n    }\n}\n\nbool MusMeiInput::ImportString( const std::string mei )\n{\n    try {\n        m_doc->Reset( Raw );\n        TiXmlDocument doc;\n        doc.Parse( mei.c_str() );\n        TiXmlElement *root = doc.RootElement();\n        return ReadMei( root );\n    }\n    catch( char * str ) {\n        Mus::LogError(\"%s\", str );\n        return false;\n    }\n}\n\n\n\nbool MusMeiInput::ReadMei( TiXmlElement *root )\n{\n    TiXmlElement *current;\n    \n    if ( root && (current = root->FirstChildElement( \"meiHead\" ) ) )\n    {\n        ReadMeiHeader( current );\n    }\n    // music\n    TiXmlElement *music = NULL;\n    TiXmlElement *body = NULL;\n    TiXmlElement *mdiv = NULL;\n    TiXmlElement *pages = NULL;\n    if ( root ) {\n        music = root->FirstChildElement(\"music\");\n    }\n    if ( music) {\n        body = music->FirstChildElement(\"body\");\n    }\n    if ( body ) {\n        mdiv = body->FirstChildElement(\"mdiv\");\n    }\n    if ( mdiv ) {\n        pages = mdiv->FirstChildElement(\"pages\");\n    }\n    if ( pages ) {\n        \n        // check if there is a type attribute for the score\n        DocType type;\n        if ( pages->Attribute( \"type\" ) ) {\n            type = StrToDocType( pages->Attribute( \"type\" ) );\n            m_doc->Reset( type );\n        }\n        \n        // this is a page-based MEI file, we just loop trough the pages\n        if ( pages->FirstChildElement( \"page\" ) ) {\n            // because we are in a page-based MEI\n            this->m_hasLayoutInformation = true;\n            for( current = pages->FirstChildElement( \"page\" ); current; current = current->NextSiblingElement( \"page\" ) ) {\n                m_page = new MusPage( );\n                SetMeiUuid( current, m_page );\n                if (ReadMeiPage( current )) {\n                    m_doc->AddPage( m_page );\n                }\n                else {\n                    delete m_page;\n                }\n                m_page = NULL;\n            }\n        }\n    }\n    else {\n        m_page = new MusPage( );\n        m_system = new MusSystem( );\n        m_page->AddSystem( m_system );\n        m_doc->AddPage( m_page );\n        TiXmlElement *current = NULL;\n        for( current = mdiv->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n            ReadUnsupported( current );\n        }\n    }\n    \n    if ( !m_openTies.empty()) {\n        std::vector<MusNote*>::iterator iter;\n        for (iter = m_openTies.begin(); iter != m_openTies.end(); ++iter)\n        {\n            Mus::LogWarning(\"Terminal tie for note '%s' could not be matched\", (*iter)->GetUuid().c_str() );\n        }\n    }\n    \n    return true;\n}\n\nbool MusMeiInput::ReadMeiHeader( TiXmlElement *meiHead )\n{\n    return true;\n}\n\n\nbool MusMeiInput::ReadMeiPage( TiXmlElement *page )\n{\n    assert( m_page );\n    \n    if ( page->Attribute( \"page.height\" ) ) {\n        m_page->m_pageHeight = atoi ( page->Attribute( \"page.height\" ) );\n    }\n    if ( page->Attribute( \"page.width\" ) ) {\n        m_page->m_pageWidth = atoi ( page->Attribute( \"page.width\" ) );\n    }\n    if ( page->Attribute( \"page.leftmar\" ) ) {\n        m_page->m_pageLeftMar = atoi ( page->Attribute( \"page.leftmar\" ) );\n    }\n    if ( page->Attribute( \"page.rightmar\" ) ) {\n        m_page->m_pageRightMar = atoi ( page->Attribute( \"page.rightmar\" ) );\n    }\n    if ( page->Attribute( \"page.topmar\" ) ) {\n        m_page->m_pageTopMar = atoi ( page->Attribute( \"page.topmar\" ) );\n    }\n    if ( page->Attribute( \"surface\" ) ) {\n        m_page->m_surface = page->Attribute( \"surface\" );\n    }\n    \n    TiXmlElement *current = NULL;\n    for( current = page->FirstChildElement( \"system\" ); current; current = current->NextSiblingElement( \"system\" ) ) {\n        m_system = new MusSystem( );\n        SetMeiUuid( current, m_system );\n        if (ReadMeiSystem( current )) {\n            m_page->AddSystem( m_system );\n        }\n        else {\n            delete m_system;\n        }\n        m_system = NULL;\n    }\n    // success only if at least one system was added to the page\n    return (m_page->GetSystemCount() > 0);\n}\n\nbool MusMeiInput::ReadMeiSystem( TiXmlElement *system )\n{\n    assert( m_system );\n    assert( !m_measure );\n    assert( !m_staff );\n    \n    if ( system->Attribute( \"system.leftmar\") ) {\n        m_system->m_systemLeftMar = atoi ( system->Attribute( \"system.leftmar\" ) );\n    }\n    if ( system->Attribute( \"system.rightmar\" ) ) {\n        m_system->m_systemRightMar = atoi ( system->Attribute( \"system.rightmar\" ) );\n    }\n    if ( system->Attribute( \"uly\" ) ) {\n        m_system->m_yAbs = atoi ( system->Attribute( \"uly\" ) );\n    }\n    \n    TiXmlElement *current = NULL;\n    // unmeasured music\n    if ( system->FirstChildElement( \"staff\" ) ) {\n        // this is the trick for un-measured music: we add one measure ( false )\n        if ( !m_measure ) {\n            m_measure = new MusMeasure( false );\n        }\n        for( current = system->FirstChildElement( \"staff\" ); current; current = current->NextSiblingElement( \"staff\" ) ) {\n            m_staff = new MusStaff( );\n            SetMeiUuid( current , m_staff );\n            if ( ReadMeiStaff( current )) {\n                m_measure->AddStaff( m_staff );\n            }\n            else {\n                delete m_staff;\n            }\n            m_staff = NULL;\n        }\n        if ( m_measure->GetStaffCount() > 0) {\n            m_system->AddMeasure( m_measure );\n        }\n        else {\n            delete m_measure;\n        }\n        m_measure = NULL;\n    }\n    else {\n        // measured\n        for( current = system->FirstChildElement( \"measure\" ); current; current = current->NextSiblingElement( \"measure\" ) ) {\n            m_measure = new MusMeasure( );\n            SetMeiUuid( current, m_measure );\n            if (ReadMeiMeasure( current )) {\n                m_system->AddMeasure( m_measure );\n            }\n            else {\n                delete m_measure;\n            }\n            m_measure = NULL;\n        }\n    }\n    \n    // success only if at least one measure was added to the system\n    return (m_system->GetMeasureCount() > 0);\n}\n\nbool MusMeiInput::ReadMeiScoreDef( TiXmlElement *scoreDef )\n{\n    assert( m_scoreDef );\n    assert( m_staffGrps.empty() );\n    \n    if ( scoreDef->Attribute( \"key.sig\" ) ) {\n        MusKeySig keysig(\n                StrToKeySigNum( scoreDef->Attribute( \"key.sig\" ) ),\n                StrToKeySigType( scoreDef->Attribute( \"key.sig\" ) ) );\n        m_scoreDef->ReplaceKeySig( &keysig );\n    }\n    if ( scoreDef->Attribute( \"clef.line\" ) && scoreDef->Attribute( \"clef.shape\" ) ) {\n        MusClef clef;\n        clef.m_clefId = StrToClef( scoreDef->Attribute( \"clef.shape\" ) , scoreDef->Attribute( \"clef.line\" ) );\n        m_scoreDef->ReplaceClef( &clef );\n        // add other attributes for SOLva\n    }\n    \n    TiXmlElement *current = NULL;\n    for( current = scoreDef->FirstChildElement( \"staffGrp\" ); current; current = current->NextSiblingElement( \"staffGrp\" ) ) {\n        MusStaffGrp *staffGrp = new MusStaffGrp( );\n        m_staffGrps.push_back( staffGrp );\n        SetMeiUuid( current , staffGrp );\n        if (ReadMeiStaffGrp( current )) {\n            m_scoreDef->AddStaffGrp( staffGrp );\n        }\n        else {\n            delete staffGrp;\n        }\n        m_staffGrps.pop_back();\n    }\n    \n    return true;\n}\n\nbool MusMeiInput::ReadMeiStaffGrp( TiXmlElement *staffGrp )\n{\n    assert( !m_staffGrps.empty() );\n    assert( !m_staffDef );\n    \n    MusStaffGrp *currentStaffGrp = m_staffGrps.back();\n    \n    if ( staffGrp->Attribute( \"symbol\" ) ) {\n        currentStaffGrp->SetSymbol( StrToStaffGrpSymbol( staffGrp->Attribute( \"symbol\" ) ) );\n    }\n    if ( staffGrp->Attribute( \"barthru\" ) ) {\n        currentStaffGrp->SetBarthru( StrToBool( staffGrp->Attribute( \"barthru\" ) ) );\n    }\n    \n    TiXmlElement *current = NULL;\n    for( current = staffGrp->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n        if ( std::string( current->Value() ) == \"staffGrp\" ) {\n            MusStaffGrp *staffGrp = new MusStaffGrp( );\n            m_staffGrps.push_back( staffGrp );\n            SetMeiUuid( current , staffGrp );\n            if (ReadMeiStaffGrp( current )) {\n                currentStaffGrp->AddStaffGrp( staffGrp );\n            }\n            else {\n                delete staffGrp;\n            }\n            m_staffGrps.pop_back();            \n        }\n        else if ( std::string( current->Value() ) == \"staffDef\" ) {\n            m_staffDef = new MusStaffDef( );\n            SetMeiUuid( current , m_staffDef );\n            if (ReadMeiStaffDef( current )) {\n                currentStaffGrp->AddStaffDef( m_staffDef );\n            }\n            else {\n                delete m_staffDef;\n            }\n            m_staffDef = NULL;\n        }        \n    }\n    \n    return true;\n}\n\nbool MusMeiInput::ReadMeiStaffDef( TiXmlElement *staffDef )\n{\n    assert( m_staffDef );\n    \n    if ( staffDef->Attribute( \"n\" ) ) {\n        m_staffDef->SetStaffNo( atoi ( staffDef->Attribute( \"n\" ) ) );\n    }\n    else {\n        Mus::LogWarning(\"No @n on staffDef\");\n    }\n    if ( staffDef->Attribute( \"key.sig\" ) ) {\n        MusKeySig keysig(\n                         StrToKeySigNum( staffDef->Attribute( \"key.sig\" ) ),\n                         StrToKeySigType( staffDef->Attribute( \"key.sig\" ) ) );\n        m_staffDef->ReplaceKeySig( &keysig );\n    }\n    if ( staffDef->Attribute( \"clef.line\" ) && staffDef->Attribute( \"clef.shape\" ) ) {\n        MusClef clef;\n        clef.m_clefId = StrToClef( staffDef->Attribute( \"clef.shape\" ) , staffDef->Attribute( \"clef.line\" ) );\n        // this is obviously a short cut - assuming @clef.dis being SOLva\n        if ( staffDef->Attribute( \"clef.dis\" ) ) {\n            clef.m_clefId = SOLva;\n        }\n        m_staffDef->ReplaceClef( &clef );\n    }\n    \n    return true;\n}\n\nbool MusMeiInput::ReadMeiMeasure( TiXmlElement *measure )\n{\n    assert( m_measure );\n    assert( !m_staff );\n    \n    if ( measure->Attribute( \"right\" ) ) {\n        m_measure->GetRightBarline()->m_barlineType = StrToBarlineType( measure->Attribute( \"right\" ) );\n    }\n    \n    TiXmlElement *current = NULL;\n    for( current = measure->FirstChildElement( \"staff\" ); current; current = current->NextSiblingElement( \"staff\" ) ) {\n        m_staff = new MusStaff( );\n        SetMeiUuid( current , m_staff );\n        if ( ReadMeiStaff( current )) {\n            m_measure->AddStaff( m_staff );\n        }\n        else {\n            delete m_staff;\n        }\n        m_staff = NULL;\n    }\n    // success only if at least one staff was added to the measure\n    return (m_measure->GetStaffCount() > 0);\n}\n\nbool MusMeiInput::ReadMeiStaff( TiXmlElement *staff )\n{\n    assert( m_staff );\n    assert( !m_layer );\n    \n    if ( staff->Attribute( \"n\" ) ) {\n        m_staff->SetStaffNo( atoi ( staff->Attribute( \"n\" ) ) );\n    }\n    else {\n        Mus::LogWarning(\"No @n on staff\");\n    }\n    if ( staff->Attribute( \"uly\" ) ) {\n        m_staff->m_yAbs = atoi ( staff->Attribute( \"uly\" ) );\n    }\n    if ( staff->Attribute( \"label\" ) ) {\n        // we use type only for typing mensural notation\n        m_staff->notAnc = true;\n    }\n    \n    TiXmlElement *current = NULL;\n    for( current = staff->FirstChildElement( \"layer\" ); current; current = current->NextSiblingElement( \"layer\" ) ) {\n        m_layer = new MusLayer( 1 );\n        m_currentLayer = m_layer;\n        SetMeiUuid( current , m_layer );\n        if (ReadMeiLayer( current )) {\n            m_staff->AddLayer( m_layer );\n        }\n        else {\n            delete m_layer;\n        }\n        m_layer = NULL;\n    }\n    \n    // success only if at least one measure was added to the staff\n    return (m_staff->GetLayerCount() > 0);\n}\n\nbool MusMeiInput::ReadMeiLayer( TiXmlElement *layer )\n{\n    assert( m_layer );\n    \n    if ( layer->Attribute( \"n\" ) ) {\n        m_layer->SetLayerNo( atoi ( layer->Attribute( \"n\" ) ) );\n    }\n    else {\n        Mus::LogWarning(\"No @n on layer\");\n    }\n    \n    TiXmlElement *current = NULL;\n    for( current = layer->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n        ReadMeiLayerElement( current );\n    }\n    // success in any case\n    return true;\n}\n\nbool MusMeiInput::ReadMeiLayerElement( TiXmlElement *xmlElement )\n{\n    MusLayerElement *musElement = NULL;\n    if ( std::string( xmlElement->Value() )  == \"barLine\" ) {\n        musElement = ReadMeiBarline( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"beam\" ) {\n        musElement = ReadMeiBeam( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"clef\" ) {\n        musElement = ReadMeiClef( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"mensur\" ) {\n        musElement = ReadMeiMensur( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"note\" ) {\n        musElement = ReadMeiNote( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"rest\" ) {\n        musElement = ReadMeiRest( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"multiRest\" ) {\n        musElement = ReadMeiMultiRest( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"tuplet\" ) {\n        musElement = ReadMeiTuplet( xmlElement );\n    }\n    // symbols\n    else if ( std::string( xmlElement->Value() ) == \"accid\" ) {\n        musElement = ReadMeiAccid( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"custos\" ) {\n        musElement = ReadMeiCustos( xmlElement );\n    }\n    else if ( std::string( xmlElement->Value() ) == \"dot\" ) {\n        musElement = ReadMeiDot( xmlElement );\n    }\n    // app\n    else if ( std::string( xmlElement->Value() ) == \"app\" ) {\n        musElement = ReadMeiApp( xmlElement );\n    }\n    // unkown            \n    else {\n        Mus::LogDebug(\"Element %s ignored\", xmlElement->Value() );\n    }\n    \n    if ( !musElement ) {\n        return false;\n    }\n    \n    if ( xmlElement->Attribute( \"ulx\" ) ) {\n        musElement->m_xAbs = atoi ( xmlElement->Attribute( \"ulx\" ) );\n    }\n    ReadSameAsAttr( xmlElement, musElement );\n    SetMeiUuid( xmlElement, musElement );\n    \n    AddLayerElement( musElement );\n    return true;\n}\n\nMusLayerElement *MusMeiInput::ReadMeiBarline( TiXmlElement *barline )\n{\n    MusBarline *musBarline = new MusBarline();\n    \n    return musBarline;    \n}\n\nMusLayerElement *MusMeiInput::ReadMeiBeam( TiXmlElement *beam )\n{\n    assert ( !m_beam );\n    \n    // m_beam will be used for adding elements to the beam\n    m_beam = new MusBeam();\n    \n    MusObject *previousLayer = m_currentLayer;\n    m_currentLayer = m_beam;\n    \n    TiXmlElement *current = NULL;\n    for( current = beam->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n        ReadMeiLayerElement( current );\n    }\n    \n    if ( m_beam->GetNoteCount() == 1 ) {\n        Mus::LogWarning(\"Beam element with only one note\");\n    }\n    // switch back to the previous one\n    m_currentLayer = previousLayer;\n    if ( m_beam->GetNoteCount() < 1 ) {\n        delete m_beam;\n        m_beam = NULL;\n        return NULL;\n    } \n    else {\n        // set the member to NULL but keep a pointer to be returned        \n        MusBeam *musBeam = m_beam;\n        m_beam = NULL;\n        return musBeam;\n    }\n}\n\nMusLayerElement *MusMeiInput::ReadMeiClef( TiXmlElement *clef )\n{ \n    MusClef *musClef = new MusClef(); \n    if ( clef->Attribute( \"shape\" ) && clef->Attribute( \"line\" ) ) {\n        musClef->m_clefId = StrToClef( clef->Attribute( \"shape\" ) , clef->Attribute( \"line\" ) );\n    }\n    \n    return musClef;\n}\n\n\nMusLayerElement *MusMeiInput::ReadMeiMensur( TiXmlElement *mensur )\n{\n    MusMensur *musMensur = new MusMensur();\n    \n    if ( mensur->Attribute( \"sign\" ) ) {\n        musMensur->m_sign = StrToMensurSign( mensur->Attribute( \"sign\" ) );\n    }\n    if ( mensur->Attribute( \"dot\" ) ) {\n        musMensur->m_dot = ( strcmp( mensur->Attribute( \"dot\" ), \"true\" ) == 0 );\n    }\n    if ( mensur->Attribute( \"slash\" ) ) {\n        musMensur->m_slash =  1; //atoi( mensur->Attribute( \"Slash\" ) );\n    }\n    if ( mensur->Attribute( \"orient\" ) ) {\n        musMensur->m_reversed = ( strcmp ( mensur->Attribute( \"orient\" ), \"reversed\" ) == 0 );\n    }\n    if ( mensur->Attribute( \"num\" ) ) {\n        musMensur->m_num = atoi ( mensur->Attribute( \"num\" ) );\n    }\n    if ( mensur->Attribute( \"numbase\" ) ) {\n        musMensur->m_numBase = atoi ( mensur->Attribute( \"numbase\" ) );\n    }\n    // missing m_meterSymb\n    \n    return musMensur;\n}\n\nMusLayerElement *MusMeiInput::ReadMeiMultiRest( TiXmlElement *multiRest )\n{\n\tMusMultiRest *musMultiRest = new MusMultiRest();\n    \n\t// pitch\n    if ( multiRest->Attribute( \"num\" ) ) {\n        musMultiRest->SetNumber( atoi ( multiRest->Attribute( \"num\" ) ) );\n    }\n\t\n\treturn musMultiRest;\n}\n\nMusLayerElement *MusMeiInput::ReadMeiNote( TiXmlElement *note )\n{\n\tMusNote *musNote = new MusNote();\n    \n\t// pitch\n\tif ( note->Attribute( \"pname\" ) ) {\n\t\tmusNote->m_pname = StrToPitch( note->Attribute( \"pname\" ) );\n\t}\n\t// oct\n\tif ( note->Attribute( \"oct\" ) ) {\n\t\tmusNote->m_oct = StrToOct( note->Attribute( \"oct\" ) );\n\t}\n\t// duration\n\tif ( note->Attribute( \"dur\" ) ) {\n\t\tmusNote->m_dur = StrToDur( note->Attribute( \"dur\" ) );\n\t}\n    // dots\n    if ( note->Attribute( \"dots\" ) ) {\n\t\tmusNote->m_dots = atoi( note->Attribute( \"dots\" ) );\n\t}\n    // accid\n    if ( note->Attribute( \"accid\" ) ) {\n\t\tmusNote->m_accid = StrToAccid( note->Attribute( \"accid\" ) );\n\t}\n    // ligature\n    if ( note->Attribute( \"lig\" ) ) {\n        musNote->m_lig = true; // this has to be double checked\n        if ( strcmp( note->Attribute( \"lig\" ), \"obliqua\" ) == 0 ) {\n            musNote->m_ligObliqua = true;\n        }\n    }\n    // stem direction\n    if ( note->Attribute( \"stem.dir\" ) ) {\n        // we use it to indicate opposite direction\n        musNote->m_stemDir = 1;\n    }\n    // coloration\n    if ( note->Attribute( \"colored\" ) ) {\n        musNote->m_colored = ( strcmp ( note->Attribute( \"colored\" ), \"true\" ) == 0 );\n    }\n    // coloration\n    if ( note->Attribute( \"tie\" ) ) {\n        if ( (strcmp ( note->Attribute( \"tie\" ), \"i\" ) == 0) || (strcmp ( note->Attribute( \"tie\" ), \"m\" ) == 0) ) {\n            musNote->SetTieAttrInitial();\n            m_openTies.push_back( musNote );\n        }\n        if ( (strcmp ( note->Attribute( \"tie\" ), \"t\" ) == 0) || (strcmp ( note->Attribute( \"tie\" ), \"m\" ) == 0) ) {\n            if (!FindOpenTie( musNote ) ) {\n                Mus::LogWarning(\"Initial tie could not be found\" );\n            }\n        }\n    }\n\t\n\treturn musNote;\n}\n\n\nMusLayerElement *MusMeiInput::ReadMeiRest( TiXmlElement *rest )\n{\n    MusRest *musRest = new MusRest();\n    \n\t// duration\n\tif ( rest->Attribute( \"dur\" ) ) {\n\t\tmusRest->m_dur = StrToDur( rest->Attribute( \"dur\" ) );\n\t}\n    if ( rest->Attribute( \"dots\" ) ) {\n\t\tmusRest->m_dots = atoi( rest->Attribute( \"dots\" ) );\n\t}\n    // position\n\tif ( rest->Attribute( \"ploc\" ) ) {\n\t\tmusRest->m_pname = StrToPitch( rest->Attribute( \"ploc\" ) );\n\t}\n\t// oct\n\tif ( rest->Attribute( \"oloc\" ) ) {\n\t\tmusRest->m_oct = StrToOct( rest->Attribute( \"oloc\" ) );\n\t}\n\t\n    return musRest;\n}\n\n\nMusLayerElement *MusMeiInput::ReadMeiTuplet( TiXmlElement *tuplet )\n{\n    assert ( !m_tuplet );\n    \n    // m_tuplet will be used for adding elements to the beam\n    m_tuplet = new MusTuplet();\n    \n    MusObject *previousLayer = m_currentLayer;\n    m_currentLayer = m_tuplet;\n    \n    // Read in the numerator and denominator properties\n    if ( tuplet->Attribute( \"num\" ) ) {\n\t\tm_tuplet->m_num = atoi( tuplet->Attribute( \"num\" ) );\n\t}\n    if ( tuplet->Attribute( \"numbase\" ) ) {\n\t\tm_tuplet->m_numbase = atoi( tuplet->Attribute( \"numbase\" ) );\n\t}\n    \n    TiXmlElement *current = NULL;\n    for( current = tuplet->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n        ReadMeiLayerElement( current );\n    }\n    \n    if ( m_tuplet->GetNoteCount() == 1 ) {\n        Mus::LogWarning(\"Tuplet element with only one note\");\n    }\n    // switch back to the previous one\n    m_currentLayer = previousLayer;\n    if ( m_tuplet->GetNoteCount() < 1 ) {\n        delete m_tuplet;\n        return NULL;\n    }\n    else {\n        // set the member to NULL but keep a pointer to be returned\n        MusTuplet *musTuplet = m_tuplet;\n        m_tuplet = NULL;\n        return musTuplet;\n    }\n}\n\n\nMusLayerElement *MusMeiInput::ReadMeiAccid( TiXmlElement *accid )\n{\n    MusSymbol *musAccid = new MusSymbol( SYMBOL_ACCID );\n    \n    if ( accid->Attribute( \"accid\" ) ) {\n        musAccid->m_accid = StrToAccid( accid->Attribute( \"accid\" ) );\n    }\n    // position\n\tif ( accid->Attribute( \"ploc\" ) ) {\n\t\tmusAccid->m_pname = StrToPitch( accid->Attribute( \"ploc\" ) );\n\t}\n\t// oct\n\tif ( accid->Attribute( \"oloc\" ) ) {\n\t\tmusAccid->m_oct = StrToOct( accid->Attribute( \"oloc\" ) );\n\t}\n\t\n\treturn musAccid;\n}\n\nMusLayerElement *MusMeiInput::ReadMeiCustos( TiXmlElement *custos )\n{\n    MusSymbol *musCustos = new MusSymbol( SYMBOL_CUSTOS );\n    \n\t// position (pitch)\n\tif ( custos->Attribute( \"pname\" ) ) {\n\t\tmusCustos->m_pname = StrToPitch( custos->Attribute( \"pname\" ) );\n\t}\n\t// oct\n\tif ( custos->Attribute( \"oct\" ) ) {\n\t\tmusCustos->m_oct = StrToOct( custos->Attribute( \"oct\" ) );\n\t}\n\t\n\treturn musCustos;    \n}\n\nMusLayerElement *MusMeiInput::ReadMeiDot( TiXmlElement *dot )\n{\n    MusSymbol *musDot = new MusSymbol( SYMBOL_DOT );\n    \n    musDot->m_dot = 0;\n    // missing m_dots\n    // position\n\tif ( dot->Attribute( \"ploc\" ) ) {\n\t\tmusDot->m_pname = StrToPitch( dot->Attribute( \"ploc\" ) );\n\t}\n\t// oct\n\tif ( dot->Attribute( \"oloc\" ) ) {\n\t\tmusDot->m_oct = StrToOct( dot->Attribute( \"oloc\" ) );\n\t}\n\t\n\treturn musDot;\n}\n\nMusLayerElement *MusMeiInput::ReadMeiApp( TiXmlElement *app )\n{\n    m_layerApp = new MusLayerApp( );\n   \n    TiXmlElement *current = NULL;\n    for( current = app->FirstChildElement( \"rdg\" ); current; current = current->NextSiblingElement( \"rdg\" ) ) {\n        ReadMeiRdg( current );\n\t}\n\t\n    // set the member to NULL but keep a pointer to be returned\n    MusLayerApp *layerApp = m_layerApp;\n    m_layerApp = NULL;\n    \n    return layerApp;\n}\n\nbool MusMeiInput::ReadMeiRdg( TiXmlElement *rdg )\n{\n    assert ( !m_layerRdg );\n    assert( m_layerApp );\n    \n    m_layerRdg = new MusLayerRdg( );\n    \n    if ( rdg->Attribute( \"source\" ) ) {\n        m_layerRdg->m_source = rdg->Attribute( \"source\" );\n    }\n    \n    // switch to the rdg\n    MusObject *previousLayer = m_currentLayer;\n    m_currentLayer = m_layerRdg;\n \n    TiXmlElement *current = NULL;\n    for( current = rdg->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n        ReadMeiLayerElement( current );\n    }\n    \n    // switch back to the previous one\n    m_currentLayer = previousLayer;\n\n    // set the member to NULL but keep a pointer to be returned\n    MusLayerRdg *layerRdg = m_layerRdg;\n    m_layerRdg = NULL;\n    \n    return layerRdg;\n}\n\n\nvoid MusMeiInput::ReadSameAsAttr( TiXmlElement *element, MusObject *object )\n{\n    if ( !element->Attribute( \"sameas\" ) ) {\n        return;\n    }\n    \n    object->m_sameAs = element->Attribute( \"sameas\" );\n}\n\n\nvoid MusMeiInput::AddLayerElement( MusLayerElement *element )\n{\n    assert( m_currentLayer );\n    if ( dynamic_cast<MusLayer*>( m_currentLayer ) ) {\n        ((MusLayer*)m_currentLayer)->AddElement( element );\n    }\n    else if ( dynamic_cast<MusLayerRdg*>( m_currentLayer ) ) {\n        ((MusLayerRdg*)m_currentLayer)->AddElement( element );\n    }\n    else if ( dynamic_cast<MusBeam*>( m_currentLayer ) ) {\n        ((MusBeam*)m_currentLayer)->AddElement( element );\n    }\n    else if ( dynamic_cast<MusTuplet*>( m_currentLayer ) ) {\n        ((MusTuplet*)m_currentLayer)->AddElement( element );\n    }\n    \n}\n\n\nbool MusMeiInput::ReadUnsupported( TiXmlElement *element )\n{\n    if ( std::string( element->Value() ) == \"score\" ) {\n        TiXmlElement *current = NULL;\n        for( current = element->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n            ReadUnsupported( current );\n        }\n    }\n    if ( std::string( element->Value() ) == \"section\" ) {\n        TiXmlElement *current = NULL;\n        for( current = element->FirstChildElement( ); current; current = current->NextSiblingElement( ) ) {\n            ReadUnsupported( current );\n        }       \n    }\n    else if ( std::string( element->Value() ) == \"measure\" ) {\n        Mus::LogDebug( \"measure\" );\n        m_measure = new MusMeasure( );\n        SetMeiUuid( element, m_measure );\n        if (ReadMeiMeasure( element )) {\n            m_system->AddMeasure( m_measure );\n        }\n        else {\n            delete m_measure;\n        }\n        m_measure = NULL;\n    }\n    /*\n    else if ( std::string( element->Value() ) == \"staff\" ) {\n        Mus::LogDebug( \"staff\" );\n        int n = 1;\n        if ( element->Attribute( \"n\" ) ) {\n            element->Attribute( \"n\", &n );\n        }\n        MusStaff *staff = m_system->GetStaff( n - 1 );\n        if ( staff ) {\n            m_staff = staff;\n        }\n        else\n        {\n            m_staff = new MusStaff( n );\n            m_system->AddStaff( m_staff );\n        }\n        m_measure = new MusMeasure( *m_contentBasedMeasure );\n        ReadMeiStaff( element );\n    }\n    */\n    else if ( (std::string( element->Value() ) == \"pb\") && (m_system->GetMeasureCount() > 0 ) ) {\n        Mus::LogDebug( \"pb\" );\n        this->m_hasLayoutInformation = true;\n        m_page = new MusPage( );\n        m_system = new MusSystem( );\n        m_page->AddSystem( m_system );\n        m_doc->AddPage( m_page );\n        \n    }\n    else if ( (std::string( element->Value() ) == \"sb\") && (m_page->GetSystemCount() > 0 ) ) {\n        Mus::LogDebug( \"sb\" );\n        this->m_hasLayoutInformation = true;\n        m_system = new MusSystem( );\n        m_page->AddSystem( m_system );\n    }\n    else if ( (std::string( element->Value() ) == \"scoreDef\") && ( !m_hasScoreDef ) ) {\n        Mus::LogDebug( \"scoreDef\" );\n        m_scoreDef = &m_doc->m_scoreDef;\n        SetMeiUuid( element, m_scoreDef );\n        if (ReadMeiScoreDef( element )) {\n            m_hasScoreDef = true;\n        }\n        else {\n            m_hasScoreDef = false;\n        }\n    }\n    else {\n        Mus::LogWarning( \"Element %s ignored\", element->Value() );\n    }\n    return true;\n}\n\nbool MusMeiInput::FindOpenTie( MusNote *terminalNote )\n{\n    assert( m_staff );\n    assert( m_layer );\n    \n    std::vector<MusNote*>::iterator iter;\n    for (iter = m_openTies.begin(); iter != m_openTies.end(); ++iter)\n    {\n        // we need to get the parent layer for comparing their number\n        MusLayer *parentLayer = dynamic_cast<MusLayer*>( (*iter)->GetFirstParent( &typeid(MusLayer) ) );\n        if (!parentLayer) {\n            continue;\n        }\n        MusStaff *parentStaff = dynamic_cast<MusStaff*>( parentLayer->GetFirstParent( &typeid(MusStaff) ) );\n        // We assume the if the note has no parent staff it is because we are in the same layer and that\n        // the layer has not been added to its parent staff yet.\n        // If we have one, compare the number\n        if ( (parentStaff) && (m_staff->GetStaffNo() != parentStaff->GetStaffNo()) ) {\n            continue;\n        }\n        // same layer?\n        if ( m_layer->GetLayerNo() != parentLayer->GetLayerNo() ) {\n            continue;\n        }\n        // we only compare oct and pname because alteration is not relevant for ties\n        if ( (terminalNote->m_oct == (*iter)->m_oct) && (terminalNote->m_pname == (*iter)->m_pname) ) {\n            terminalNote->SetTieAttrTerminal( *iter );\n            m_openTies.erase(iter);\n            return true;\n        }\n        \n    }\n    return false;\n}\n\nvoid MusMeiInput::SetMeiUuid( TiXmlElement *element, MusObject *object )\n{\n    if ( !element->Attribute( \"xml:id\" ) ) {\n        return;\n    }\n    \n    object->SetUuid( element->Attribute( \"xml:id\" ) );\n}\n\nbool MusMeiInput::StrToBool(std::string value)\n{\n    if (value == \"false\") return false;\n\treturn true;\n}\n\nint MusMeiInput::StrToDur(std::string dur)\n{\n    int value;\n    if (dur == \"longa\") value = DUR_LG;\n    else if (dur == \"brevis\") value = DUR_BR;\n    else if (dur == \"semibrevis\") value = DUR_1;\n    else if (dur == \"minima\") value = DUR_2;\n    else if (dur == \"semiminima\") value = DUR_4;\n    else if (dur == \"fusa\") value = DUR_8;\n    else if (dur == \"semifusa\") value = DUR_16;\n    else if (dur == \"long\") value = DUR_LG;\n    else if (dur == \"breve\") value = DUR_BR;\n    else if (dur == \"1\") value = DUR_1;\n    else if (dur == \"2\") value = DUR_2;\n    else if (dur == \"4\") value = DUR_4;\n    else if (dur == \"8\") value = DUR_8;\n    else if (dur == \"16\") value = DUR_16;\n    else if (dur == \"32\") value = DUR_32;\n    else if (dur == \"64\") value = DUR_64;\n    else if (dur == \"128\") value = DUR_128;\n\telse {\n\t\t//Mus::LogWarning(\"Unknown duration '%s'\", dur.c_str());\n        value = DUR_4;\n\t}\n    return value;\n}\n\nint MusMeiInput::StrToOct(std::string oct)\n{\n\treturn atoi(oct.c_str());\n}\n\nint MusMeiInput::StrToPitch(std::string pitch)\n{\n    int value;\n    if (pitch == \"c\") value = PITCH_C;\n    else if (pitch == \"d\") value = PITCH_D;\n    else if (pitch == \"e\") value = PITCH_E;\n    else if (pitch == \"f\") value = PITCH_F;\n    else if (pitch == \"g\") value = PITCH_G;\n    else if (pitch == \"a\") value = PITCH_A;\n    else if (pitch == \"b\") value = PITCH_B;\n    else {\n\t\tMus::LogWarning(\"Unknow pname '%s'\", pitch.c_str());\n        value = PITCH_C;\n    }\n    return value;\n}\n\n\nunsigned char MusMeiInput::StrToAccid(std::string accid)\n{\n    unsigned char value;\n    if ( accid == \"s\" ) value = ACCID_SHARP;\n    else if ( accid == \"f\" ) value = ACCID_FLAT;\n    else if ( accid == \"n\" ) value = ACCID_NATURAL;\n    else if ( accid == \"x\" ) value = ACCID_DOUBLE_SHARP;\n    else if ( accid == \"ff\" ) value = ACCID_DOUBLE_FLAT;\n    else if ( accid == \"ns\" ) value = ACCID_QUARTER_SHARP;\n    else if ( accid == \"nf\" ) value = ACCID_QUARTER_FLAT;\n    else {\n        Mus::LogWarning(\"Unknown accid '%s'\", accid.c_str() );\n        value = ACCID_NATURAL;\n    }\n\treturn value;\n}\n\n\nClefId MusMeiInput::StrToClef( std::string shape, std::string line )\n{\n    ClefId clefId = SOL2;\n    std::string clef = shape + line;\n    if ( clef == \"G2\" ) clefId = SOL2;\n    else if ( clef == \"G1\" ) clefId = SOL1; \n    else if ( clef == \"F5\" ) clefId = FA5;\n    else if ( clef == \"F4\" ) clefId = FA4; \n    else if ( clef == \"F3\" ) clefId = FA3; \n    else if ( clef == \"C1\" ) clefId = UT1; \n    else if ( clef == \"C2\" ) clefId = UT2; \n    else if ( clef == \"C3\" ) clefId = UT3; \n    else if ( clef == \"C4\" ) clefId = UT4; \n    else if ( clef == \"C5\" ) clefId = UT5; \n    else \n    {\n        Mus::LogWarning(\"Unknown clef shape '%s' line '%s'\", shape.c_str(), line.c_str() );\n    }\n    return clefId;\n}\n\nMensurSign MusMeiInput::StrToMensurSign(std::string sign)\n{\n    if (sign == \"C\") return MENSUR_SIGN_C;\n    else if (sign == \"O\") return MENSUR_SIGN_O;\n    else {\n        Mus::LogWarning(\"Unknown mensur sign '%s'\", sign.c_str() );\n\t}\n    // default\n\treturn MENSUR_SIGN_C;\n}\n\nDocType MusMeiInput::StrToDocType(std::string type)\n{\n    if (type == \"raw\") return Raw;\n    else if (type == \"rendering\") return Rendering;\n    else if (type == \"transcription\") return Transcription;\n    else {\n        Mus::LogWarning(\"Unknown layout type '%s'\", type.c_str() );\n\t}\n    // default\n\treturn Raw;\n}\n\nunsigned char MusMeiInput::StrToKeySigType(std::string accid)\n{\n    if ( accid == \"0\" ) return  ACCID_NATURAL;\n    else if ( accid.at(1) == 'f' ) return ACCID_FLAT;\n    else if ( accid.at(1) == 's' ) return ACCID_SHARP;\n    else {\n        Mus::LogWarning(\"Unknown keysig '%s'\", accid.c_str() );\n        return ACCID_NATURAL;\n    }\n}\n\nint MusMeiInput::StrToKeySigNum(std::string accid)\n{\n    if ( accid == \"0\" ) return  0;\n    else {\n        // low level way, remove '0', which is 48\n        return accid.at(0) - '0';\n    }\n}\n\nBarlineType MusMeiInput::StrToBarlineType(std::string type)\n{\n    if (type == \"sigle\") return BARLINE_SINGLE;\n    else if (type == \"end\") return BARLINE_END;\n    else if (type == \"dbl\") return BARLINE_DBL;\n    else if (type == \"rptend\") return BARLINE_RPTEND;\n    else if (type == \"rptstart\") return BARLINE_RPTSTART;\n    else if (type == \"rptboth\") return BARLINE_RPTBOTH;\n    else {\n        Mus::LogWarning(\"Unknown barline type '%s'\", type.c_str() );\n\t}\n    // default\n\treturn BARLINE_SINGLE;\n}\n\nStaffGrpSymbol MusMeiInput::StrToStaffGrpSymbol(std::string symbol)\n{\n    if (symbol == \"line\") return STAFFGRP_LINE;\n    else if (symbol == \"brace\") return STAFFGRP_BRACE;\n    else if (symbol == \"bracket\") return STAFFGRP_BRACKET;\n    else {\n        Mus::LogWarning(\"Unknown staffGrp @symbol '%s'\", symbol.c_str() );\n\t}\n    // default\n\treturn STAFFGRP_LINE;\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muspage.h\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_PAGE_H__\n#define __MUS_PAGE_H__\n\n#include \"musobject.h\"\n#include \"musscoredef.h\"\n\nclass MusDC;\nclass MusStaff;\nclass MusSystem;\n\nenum {\n    PAGE_VALUES_VOICES = 0,\n    PAGE_VALUES_INDENT\n};\n\n//----------------------------------------------------------------------------\n// MusPage\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a page in a laid-out score (MusDoc).\n * A MusPage is contained in a MusDoc.\n * It contains MusSystem objects.\n*/\nclass MusPage: public MusDocObject\n{\npublic:\n    // constructors and destructors\n    MusPage();\n    virtual ~MusPage();\n    \n    virtual std::string MusClassName( ) { return \"MusPage\"; };\n    \n    void Clear();\n\t\n\tvoid AddSystem( MusSystem *system );\n    \n\tMusSystem *GetFirst( );\n\tMusSystem *GetLast( );\n\tMusSystem *GetNext( MusSystem *system );\n\tMusSystem *GetPrevious( MusSystem *system );\n\tMusSystem *GetAtPos( int y );\n\n    void SetValues( int type );\n\t\n\tint GetSystemCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Return the index position of the page in its document parent\n     */\n    int GetPageIdx() const { return MusObject::GetIdx(); };\n    \n    /**\n     * Return the position of the staff on the page, from top to bottom\n     */\n    int GetStaffPosOnPage( MusStaff *staff );\n    \n    /**\n     * Do the layout of the page\n     */\n    void Layout( );\n    \n    /**\n     * Do the horizontal layout of the page\n     */\n    void HorizontalLayout( );\n\n    /**\n     * Do the vertical layout of the page\n     */\n    void VerticalLayout( );\n\n    // functors\n    virtual int Save( ArrayPtrVoid params );\n    \n    \nprivate:\n    \npublic:\n    /** Page width (MEI scoredef@page.width). Saved if != -1 */\n    int m_pageWidth;\n    /** Page height (MEI scoredef@page.height). Saved if != -1 */\n    int m_pageHeight;\n    /** Page left margin (MEI scoredef@page.leftmar). Saved if != 0 */\n    short m_pageLeftMar;\n    /** Page right margin (MEI scoredef@page.rightmar). Saved if != 0 */\n    short m_pageRightMar;\n    /** Page top margin (MEI scoredef@page.topmar). Saved if != 0 */\n    short m_pageTopMar;\n    /** \n     * Surface (MEI @surface). Saved as facsimile for transciption layout.\n     * For now, the target of the <graphic> element within surface is loaded here.\n     */\n    std::string m_surface;\n    \n    \n    /** definition en mm des portees de la page */\n    unsigned char defin; // m_pageScale\n    /** longueur en mm de l'indentation des portees de la page */\n    //int indent; // ax2\n    /** longueur en mm de l'indentation droite des portees de la page */\n    //int indentDroite; // ax2\n    /** longueur en mm des lignes de la pages */\n    //int lrg_lign; // ax2\n    \n    /**\n     * Hold the top scoreDef of the page.\n     * The value must be initialized by going through the whole score for finding\n     * all the clef or key changes that might occur within the text.\n     * The value is initialized with by the MusObject::SetPageScoreDef functor.\n     */\n    MusScoreDef m_drawingScoreDef;\n\nprivate:\n    \n};\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mussystem.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_SYSTEM_H__\n#define __MUS_SYSTEM_H__\n\n#include \"musaligner.h\"\n#include \"musbarline.h\"\n#include \"musobject.h\"\n\n#define SYSTEM_OFFSET 190\n\nclass MusDC;\nclass MusMeasure;\n\n//----------------------------------------------------------------------------\n// MusSystem\n//----------------------------------------------------------------------------\n\n/**\n * This class represents a system in a laid-out score (MusDoc).\n * A MusSystem is contained in a MusPage.\n * It contains MusStaff objects.\n*/\nclass MusSystem: public MusDocObject\n{\npublic:\n    // constructors and destructors\n    MusSystem();\n\tMusSystem( const MusSystem& system ); // copy contructor\n    virtual ~MusSystem();\n        \n    virtual std::string MusClassName( ) { return \"MusSystem\"; };\n    \n    void Clear();\n\t\n\tvoid AddMeasure( MusMeasure *measure );\n\t\n\tMusMeasure *GetFirst( );\n\tMusMeasure *GetLast( );\n\tMusMeasure *GetNext( MusMeasure *measure );\n\tMusMeasure *GetPrevious( MusMeasure *measure );\n    //MusMeasure *GetMeasure( int MeasureNo );\n\tMusMeasure *GetAtPos( int x );\n    \n    /**\n     * Return the default horizontal spacing of system.\n     */\n    int GetVerticalSpacing();\n\n    void SetValues( int type );\n\t\n\tint GetMeasureCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Return the index position of the system in its page parent\n     */\n    int GetSystemIdx() const { return MusObject::GetIdx(); };\n    \n    // functors\n    virtual int Save( ArrayPtrVoid params );\n\n    /**\n     * Adjust the size of a system according to its content (to be verified)\n     */\n    virtual int TrimSystem( ArrayPtrVoid params );\n    \n    /**\n     * Align the content of a system.\n     */\n    virtual int Align( ArrayPtrVoid params );\n    \n    /**\n     * Set the position of the StaffAlignment.\n     * Redirect the functor to the MusSytemAligner\n     */\n    virtual int SetAligmentYPos( ArrayPtrVoid params );\n    \n    /**\n     * Correct the Y alignment once the the content of a system has been aligned and laid out.\n     * Special case that redirects the functor to the MusSystemAligner.\n     */\n    virtual int IntegrateBoundingBoxYShift( ArrayPtrVoid params );\n    \n    /**\n     * Align the system by adjusting the m_yRel position looking at the MusSystemAligner.\n     */\n    virtual int AlignSystems( ArrayPtrVoid params );\n    \n    /**\n     * Align the measures by adjusting the m_xRel position looking at the MusMeasureAligner.\n     * In MusSystem object resets the shift to 0;\n     */\n    virtual int AlignMeasures( ArrayPtrVoid params );\n    \n    /** \n     * Store the width of the system in the MusMeasureAligner for justification\n     */\n    virtual int AlignMeasuresEnd( ArrayPtrVoid params );\n    \n    /**\n     * Justify the X positions\n     * Special case that redirects the functor to the MusMeasureAligner.\n     */\n    virtual int JustifyX( ArrayPtrVoid params );\n    \nprivate:\n    MusSystemAligner m_systemAligner;\n    \npublic:\n    /** System left margin (MEI scoredef@system.leftmar). Saved if != 0 */\n    int m_systemLeftMar;\n    /** System right margin (MEI scoredef@system.rightmar). Saved if != 0 */\n    int m_systemRightMar;\n\t/** \n     * The Y absolute position of the staff for facsimile (transcription) encodings.\n     * This is the top left corner of the system.\n     */\n    int m_yAbs;\n    /**\n     * The Y relative position of the system.\n     * It is used internally when calculating the layout andd it is not stored in the file.\n     */\n    int m_yRel;\n\t/**\n     * The Y drawing position of the system.\n     * It is re-computed everytime the system is drawn and it is not stored in the file.\n     */\n    int m_yDrawing;\n\t/** \n     * The x absolute position of the  system for facsimile layouts.\n     * This is the top left corner of the system.\n     */\n    int m_xAbs;\n    /**\n     * The X relative position of the system.\n     * It is used internally when calculating the layout andd it is not stored in the file.\n     */\n    int m_xRel;\n\t/**\n     * The X drawing position of the system.\n     * It is re-computed everytime the system is drawn and it is not stored in the file.\n     */\n    int m_xDrawing;\n    /**\n     * The total width of the system.\n     * It is computed during the layout processed and used for calculating the justification ratio.\n     */\n    int m_totalDrawingWidth;\n\nprivate:\n    \n};\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mustuplet.h\n// Author:      Rodolfo Zitellini\n// Created:     26/06/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_TUPLET_H__\n#define __MUS_TUPLET_H__\n\n#include \"muslayer.h\"\n#include \"musnote.h\"\n#include \"musobject.h\"\n\n//----------------------------------------------------------------------------\n// MusBeam\n//----------------------------------------------------------------------------\n\nclass MusTuplet: public MusLayerElement, public MusObjectListInterface\n{\npublic:\n    // constructors and destructors\n    MusTuplet();\n    virtual ~MusTuplet();\n    \n    virtual std::string MusClassName( ) { return \"MusTuplet\"; };\n\n\tint GetNoteCount() const { return (int)m_children.size(); };\n    \n    /**\n     * Add an element (a note or a rest) to a tuplet.\n     * Only MusNote or MusRest elements will be actually added to the beam.\n     */\n    void AddElement(MusLayerElement *element);\n    \nprotected:\n    /**\n     * Filter the list for a specific class.\n     * For example, keep only notes in MusBeam\n     */\n    virtual void FilterList();\n    \nprivate:\n    \npublic:\n    int m_num;\n    int m_numbase;\n    \nprivate:\n\n};\n\n#endif\n","/*\nwww.sourceforge.net/projects/tinyxml\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n\n#ifndef TIXML_USE_STL\n\n#ifndef TIXML_STRING_INCLUDED\n#define TIXML_STRING_INCLUDED\n\n#include <assert.h>\n#include <string.h>\n\n/*\tThe support for explicit isn't that universal, and it isn't really\n\trequired - it is used to check that the TiXmlString class isn't incorrectly\n\tused. Be nice to old compilers and macro it here:\n*/\n#if defined(_MSC_VER) && (_MSC_VER >= 1200 )\n\t// Microsoft visual studio, version 6 and higher.\n\t#define TIXML_EXPLICIT explicit\n#elif defined(__GNUC__) && (__GNUC__ >= 3 )\n\t// GCC version 3 and higher.s\n\t#define TIXML_EXPLICIT explicit\n#else\n\t#define TIXML_EXPLICIT\n#endif\n\n\n/*\n   TiXmlString is an emulation of a subset of the wxString template.\n   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.\n   Only the member functions relevant to the TinyXML project have been implemented.\n   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase\n   a string and there's no more room, we allocate a buffer twice as big as we need.\n*/\nclass TiXmlString\n{\n  public :\n\t// The size type used\n  \ttypedef size_t size_type;\n\n\t// Error value for find primitive\n\tstatic const size_type npos; // = -1;\n\n\n\t// TiXmlString empty constructor\n\tTiXmlString () : rep_(&nullrep_)\n\t{\n\t}\n\n\t// TiXmlString copy constructor\n\tTiXmlString ( const TiXmlString & copy) : rep_(0)\n\t{\n\t\tinit(copy.length());\n\t\tmemcpy(start(), copy.data(), length());\n\t}\n\n\t// TiXmlString constructor, based on a string\n\tTIXML_EXPLICIT TiXmlString ( const char * copy) : rep_(0)\n\t{\n\t\tinit( static_cast<size_type>( strlen(copy) ));\n\t\tmemcpy(start(), copy, length());\n\t}\n\n\t// TiXmlString constructor, based on a string\n\tTIXML_EXPLICIT TiXmlString ( const char * str, size_type len) : rep_(0)\n\t{\n\t\tinit(len);\n\t\tmemcpy(start(), str, len);\n\t}\n\n\t// TiXmlString destructor\n\t~TiXmlString ()\n\t{\n\t\tquit();\n\t}\n\n\tTiXmlString& operator = (const char * copy)\n\t{\n\t\treturn assign( copy, (size_type)strlen(copy));\n\t}\n\n\tTiXmlString& operator = (const TiXmlString & copy)\n\t{\n\t\treturn assign(copy.start(), copy.length());\n\t}\n\n\n\t// += operator. Maps to append\n\tTiXmlString& operator += (const char * suffix)\n\t{\n\t\treturn append(suffix, static_cast<size_type>( strlen(suffix) ));\n\t}\n\n\t// += operator. Maps to append\n\tTiXmlString& operator += (char single)\n\t{\n\t\treturn append(&single, 1);\n\t}\n\n\t// += operator. Maps to append\n\tTiXmlString& operator += (const TiXmlString & suffix)\n\t{\n\t\treturn append(suffix.data(), suffix.length());\n\t}\n\n\n\t// Convert a TiXmlString into a null-terminated char *\n\tconst char * c_str () const { return rep_->str; }\n\n\t// Convert a TiXmlString into a char * (need not be null terminated).\n\tconst char * data () const { return rep_->str; }\n\n\t// Return the length of a TiXmlString\n\tsize_type length () const { return rep_->size; }\n\n\t// Alias for length()\n\tsize_type size () const { return rep_->size; }\n\n\t// Checks if a TiXmlString is empty\n\tbool empty () const { return rep_->size == 0; }\n\n\t// Return capacity of string\n\tsize_type capacity () const { return rep_->capacity; }\n\n\n\t// single char extraction\n\tconst char& at (size_type index) const\n\t{\n\t\tassert( index < length() );\n\t\treturn rep_->str[ index ];\n\t}\n\n\t// [] operator\n\tchar& operator [] (size_type index) const\n\t{\n\t\tassert( index < length() );\n\t\treturn rep_->str[ index ];\n\t}\n\n\t// find a char in a string. Return TiXmlString::npos if not found\n\tsize_type find (char lookup) const\n\t{\n\t\treturn find(lookup, 0);\n\t}\n\n\t// find a char in a string from an offset. Return TiXmlString::npos if not found\n\tsize_type find (char tofind, size_type offset) const\n\t{\n\t\tif (offset >= length()) return npos;\n\n\t\tfor (const char* p = c_str() + offset; *p != '\\0'; ++p)\n\t\t{\n\t\t   if (*p == tofind) return static_cast< size_type >( p - c_str() );\n\t\t}\n\t\treturn npos;\n\t}\n\n\tvoid clear ()\n\t{\n\t\t//Lee:\n\t\t//The original was just too strange, though correct:\n\t\t//\tTiXmlString().swap(*this);\n\t\t//Instead use the quit & re-init:\n\t\tquit();\n\t\tinit(0,0);\n\t}\n\n\t/*\tFunction to reserve a big amount of data when we know we'll need it. Be aware that this\n\t\tfunction DOES NOT clear the content of the TiXmlString if any exists.\n\t*/\n\tvoid reserve (size_type cap);\n\n\tTiXmlString& assign (const char* str, size_type len);\n\n\tTiXmlString& append (const char* str, size_type len);\n\n\tvoid swap (TiXmlString& other)\n\t{\n\t\tRep* r = rep_;\n\t\trep_ = other.rep_;\n\t\tother.rep_ = r;\n\t}\n\n  private:\n\n\tvoid init(size_type sz) { init(sz, sz); }\n\tvoid set_size(size_type sz) { rep_->str[ rep_->size = sz ] = '\\0'; }\n\tchar* start() const { return rep_->str; }\n\tchar* finish() const { return rep_->str + rep_->size; }\n\n\tstruct Rep\n\t{\n\t\tsize_type size, capacity;\n\t\tchar str[1];\n\t};\n\n\tvoid init(size_type sz, size_type cap)\n\t{\n\t\tif (cap)\n\t\t{\n\t\t\t// Lee: the original form:\n\t\t\t//\trep_ = static_cast<Rep*>(operator new(sizeof(Rep) + cap));\n\t\t\t// doesn't work in some cases of new being overloaded. Switching\n\t\t\t// to the normal allocation, although use an 'int' for systems\n\t\t\t// that are overly picky about structure alignment.\n\t\t\tconst size_type bytesNeeded = sizeof(Rep) + cap;\n\t\t\tconst size_type intsNeeded = ( bytesNeeded + sizeof(int) - 1 ) / sizeof( int ); \n\t\t\trep_ = reinterpret_cast<Rep*>( new int[ intsNeeded ] );\n\n\t\t\trep_->str[ rep_->size = sz ] = '\\0';\n\t\t\trep_->capacity = cap;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trep_ = &nullrep_;\n\t\t}\n\t}\n\n\tvoid quit()\n\t{\n\t\tif (rep_ != &nullrep_)\n\t\t{\n\t\t\t// The rep_ is really an array of ints. (see the allocator, above).\n\t\t\t// Cast it back before delete, so the compiler won't incorrectly call destructors.\n\t\t\tdelete [] ( reinterpret_cast<int*>( rep_ ) );\n\t\t}\n\t}\n\n\tRep * rep_;\n\tstatic Rep nullrep_;\n\n} ;\n\n\ninline bool operator == (const TiXmlString & a, const TiXmlString & b)\n{\n\treturn    ( a.length() == b.length() )\t\t\t\t// optimization on some platforms\n\t       && ( strcmp(a.c_str(), b.c_str()) == 0 );\t// actual compare\n}\ninline bool operator < (const TiXmlString & a, const TiXmlString & b)\n{\n\treturn strcmp(a.c_str(), b.c_str()) < 0;\n}\n\ninline bool operator != (const TiXmlString & a, const TiXmlString & b) { return !(a == b); }\ninline bool operator >  (const TiXmlString & a, const TiXmlString & b) { return b < a; }\ninline bool operator <= (const TiXmlString & a, const TiXmlString & b) { return !(b < a); }\ninline bool operator >= (const TiXmlString & a, const TiXmlString & b) { return !(a < b); }\n\ninline bool operator == (const TiXmlString & a, const char* b) { return strcmp(a.c_str(), b) == 0; }\ninline bool operator == (const char* a, const TiXmlString & b) { return b == a; }\ninline bool operator != (const TiXmlString & a, const char* b) { return !(a == b); }\ninline bool operator != (const char* a, const TiXmlString & b) { return !(b == a); }\n\nTiXmlString operator + (const TiXmlString & a, const TiXmlString & b);\nTiXmlString operator + (const TiXmlString & a, const char* b);\nTiXmlString operator + (const char* a, const TiXmlString & b);\n\n\n/*\n   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.\n   Only the operators that we need for TinyXML have been developped.\n*/\nclass TiXmlOutStream : public TiXmlString\n{\npublic :\n\n\t// TiXmlOutStream << operator.\n\tTiXmlOutStream & operator << (const TiXmlString & in)\n\t{\n\t\t*this += in;\n\t\treturn *this;\n\t}\n\n\t// TiXmlOutStream << operator.\n\tTiXmlOutStream & operator << (const char * in)\n\t{\n\t\t*this += in;\n\t\treturn *this;\n\t}\n\n} ;\n\n#endif\t// TIXML_STRING_INCLUDED\n#endif\t// TIXML_USE_STL\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musiomusxml.cpp\n// Author:      Rodolfo Zitellini\n// Created:     10/08/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musiomusxml.h\"\n\n//----------------------------------------------------------------------------\n\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n\n//----------------------------------------------------------------------------\n\n#include \"musbarline.h\"\n#include \"musbeam.h\"\n#include \"musclef.h\"\n#include \"muskeysig.h\"\n#include \"muslayerelement.h\"\n#include \"musmensur.h\"\n#include \"musmensur.h\"\n#include \"musnote.h\"\n#include \"musrest.h\"\n#include \"mussymbol.h\"\n#include \"mustie.h\"\n\n//----------------------------------------------------------------------------\n// MusXMLOutput\n//----------------------------------------------------------------------------\n\nMusXMLOutput::MusXMLOutput( MusDoc *doc, std::string filename ) :\n// This is pretty bad. We open a bad fileoutputstream as we don't use it\nMusFileOutputStream( doc )\n{\n    m_filename = filename;\n    m_measure_count = 0;\n    m_xml_attributes = NULL;\n    m_xml_current_clef = NULL;\n    m_xml_measure_style = NULL;\n    m_xml_last_note = NULL;\n    \n    m_current_time = NULL;\n    m_current_beam = NULL;\n    m_in_beam = false;\n    m_tied = false;\n    m_multimeasure_rests = 0;\n\n}\n\nMusXMLOutput::~MusXMLOutput()\n{\n}\n\nbool MusXMLOutput::ExportFile( )\n{\n\n    m_xml_doc = new TiXmlDocument;\n    TiXmlDeclaration * decl = new TiXmlDeclaration( \"1.0\", \"UTF-8\", \"no\" );\n    m_xml_doc->LinkEndChild( decl );\n\n    // do this or finale will barf, versione 3.0 for now\n    TiXmlUnknown *unk = new TiXmlUnknown;\n    //unk->SetValue(\"!DOCTYPE score-partwise PUBLIC \\\"-//Recordare//DTD MusicXML 3.0 Partwise//EN\\\" \\\"http://www.musicxml.org/dtds/partwise.dtd\\\"\");\n    unk->SetValue(\"!DOCTYPE score-timewise PUBLIC \\\"-//Recordare//DTD MusicXML 2.0 Timewise//EN\\\" \\\"http://www.musicxml.org/dtds/timewise.dtd\\\"\");\n    m_xml_doc->LinkEndChild(unk);\n    \n    // this starts the call of all the functors\n    m_doc->Save( this );\n        \n    m_xml_doc->SaveFile( m_filename.c_str() );\n    \n\treturn true;    \n}\n\nbool MusXMLOutput::WriteDoc( MusDoc *doc )\n{\n    Mus::LogDebug(\"Doc\");\n    \n    // Write the partwise declaration\n    // the MusicXML \"score-partwise\" does not map to our MusScore\n    \n    m_xml_score = new TiXmlElement(\"score-timewise\");\n    \n    // hardcode a voice for noew\n    TiXmlElement *plist =  new TiXmlElement(\"part-list\");\n    TiXmlElement *spart = new TiXmlElement(\"score-part\");\n    spart->SetAttribute(\"id\", \"P1\");\n    TiXmlElement *pname = new TiXmlElement(\"part-name\");\n    TiXmlText *pname_text = new TiXmlText(\"Example Music\");\n    pname->LinkEndChild(pname_text);\n    \n    spart->LinkEndChild(pname);\n    plist->LinkEndChild(spart);\n    \n    m_xml_score->LinkEndChild(plist);\n    m_xml_doc->LinkEndChild(m_xml_score);\n    \n    \n    return true;\n}\n\n\n/*\nbool MusXMLOutput::WriteMeasure( MusMeasure *measure )\n//bool MusXMLOutput::WriteMeiMeasure( Measure *meiMeasure, MusMeasure *measure )\n{\n    std::string num;\n\n    // Create multimeasure rests\n    if (m_multimeasure_rests > 0 )\n        CreateRestsForMultiMeasure();\n    \n    m_measure_count++;\n    num << m_measure_count;\n    Mus::LogDebug(\"Measure %i\", m_measure_count);\n    \n    // go on and create this measure\n    m_xml_measure = new TiXmlElement(\"measure\");\n    m_xml_measure->SetAttribute(\"number\", num);\n    m_xml_score->LinkEndChild(m_xml_measure);\n    \n        \n    // reset clef\n    m_xml_current_clef = NULL;\n    \n    //m_xml_part->LinkEndChild(m_xml_measure);\n    \n    return true;\n}\n*/ // ax2.3\n\nbool MusXMLOutput::WriteStaff( MusStaff *staff )\n//bool MusXMLOutput::WriteMeiStaff( Staff *meiStaff, MusStaff *staff )\n{\n    Mus::LogDebug(\"Staff\");\n    \n    m_xml_part = new TiXmlElement(\"part\");\n    m_xml_part->SetAttribute(\"id\", \"P1\");\n    \n    m_xml_measure->LinkEndChild(m_xml_part);\n    \n    // in first measure set the divisions value in <attributes>\n    if (m_measure_count == 1) {\n        m_xml_attributes = new TiXmlElement(\"attributes\");\n        TiXmlElement *divisions = new TiXmlElement(\"divisions\");\n        TiXmlText *divval = new TiXmlText(\"4\"); // no more than sixteenths for now\n        \n        divisions->LinkEndChild(divval);\n        m_xml_attributes->LinkEndChild(divisions);\n        m_xml_part->LinkEndChild(m_xml_attributes);\n    }\n    \n    return true;\n}\n\nbool MusXMLOutput::WriteLayer( MusLayer *layer )\n//bool MusXMLOutput::WriteMeiLayer( Layer *meiLayer, MusLayer *layer )\n{\n    Mus::LogDebug(\"Layer\");\n    return true;\n}\n\nbool MusXMLOutput::WriteLayerElement( MusLayerElement *element )\n{\n    Mus::LogDebug(\"Layer Elem\");\n        \n    if (dynamic_cast<MusClef*>(element)) {\n        WriteClef(element);\n    } else if (dynamic_cast<MusKeySig*>(element)) {\n        WriteKey(element);\n    } else if (dynamic_cast<MusMensur*>(element)) {\n        WriteTime(element);\n    } else if (dynamic_cast<MusNote*>(element) || dynamic_cast<MusRest*>(element)) {\n        WriteNoteOrRest(element);\n    } else if (dynamic_cast<MusBeam*>(element)) {\n        m_current_beam = dynamic_cast<MusBeam*>(element);\n    } else if (dynamic_cast<MusTie*>(element)) {\n        // add tie to last note\n        // continuation of ties is made with a <start> and <stop>\n        // in the same note\n        SetTie(m_xml_last_note, false);\n    }\n    \n //   Mus::LogDebug(\"---- %s\", element->MusClassName().c_str());\n    \n    return true;\n }\n\n\n\n\nbool MusXMLOutput::WriteLayout( MusDoc *layout )\n{\n    Mus::LogDebug(\"Layout\");\n    return true;\n}\n\nbool MusXMLOutput::WritePage( MusPage *page )\n{\n    Mus::LogDebug(\"Page\");\n    return true;\n}\n\nbool MusXMLOutput::WriteSystem( MusSystem *system )\n{\n    Mus::LogDebug(\"System\");\n    return true;\n}\n\nbool MusXMLOutput::WriteLaidOutStaff( MusStaff *laidOutStaff )\n{\n    Mus::LogDebug(\"Laid staff\");\n    return true;\n}\n\nbool MusXMLOutput::WriteLaidOutLayer( MusLayer *laidOutLayer )\n{    Mus::LogDebug(\"Laid layer\");\n    return true;\n\n}\n\nbool MusXMLOutput::WriteLaidOutLayerElement( MusLayerElement *laidOutLayerElement )\n{\n    Mus::LogDebug(\"Laid Layer Elem\");\n    return true;\n}\n\n\nvoid MusXMLOutput::WriteClef(MusLayerElement *element) {\n    std::string sign, line;\n    \n    // Create the attributes elem\n    // or use existing one, all the attribute changes\n    // go in the same <attributes>\n    CreateAttributes();\n    \n    MusClef *clef = dynamic_cast<MusClef*>(element);\n    \n    switch (clef->m_clefId) {\n        case SOL1: sign = \"G\"; line = \"1\"; break;\n        case SOL2: sign = \"G\"; line = \"2\"; break;\n        case UT1: sign = \"C\"; line = \"1\"; break;\n        case UT2: sign = \"C\"; line = \"2\"; break;\n        case UT3: sign = \"C\"; line = \"3\"; break;\n        case UT4: sign = \"C\"; line = \"4\"; break;\n        case UT5: sign = \"C\"; line = \"5\"; break;\n        case FA3: sign = \"F\"; line = \"3\"; break;\n        case FA4: sign = \"F\"; line = \"4\"; break;\n        case FA5: sign = \"F\"; line = \"5\"; break;\n        default: break;\n    }\n    \n    //Create the <clef> element\n    TiXmlElement *xclef = new TiXmlElement(\"clef\");\n    \n    // Create the <sign> element and link to it it's text\n    TiXmlElement *xsign = new TiXmlElement(\"sign\");\n    TiXmlText *xsignt = new TiXmlText(sign.c_str());\n    xsign->LinkEndChild(xsignt);\n    // Insert it into the <clef>\n    xclef->LinkEndChild(xsign);\n    \n    // Create the <line> element and link to it it's text\n    TiXmlElement *xline = new TiXmlElement(\"line\");\n    TiXmlText *xlinet = new TiXmlText(line.c_str());\n    xline->LinkEndChild(xlinet);\n    // Insert it into the <clef>\n    xclef->LinkEndChild(xline); \n    \n    // place clef into <attribute>\n    m_xml_attributes->LinkEndChild(xclef);\n    m_xml_current_clef = xclef;\n    \n}\n\nvoid MusXMLOutput::WriteKey(MusLayerElement *element) {\n    MusKeySig* key = dynamic_cast<MusKeySig*>(element);\n    \n    // Check for attrib element as above\n    // or use existing one, all the attribute changes\n    // go in the same <attributes>\n    CreateAttributes();\n    \n    // create tompost <key> elem\n    TiXmlElement *xkey = new TiXmlElement(\"key\");\n    \n    // Convert the number of alterations to string\n    std::stringstream n_alter;\n    if (key->m_alteration == ACCID_FLAT)\n        // flats are negative numbers\n        n_alter << -key->m_num_alter;\n    else\n        n_alter << key->m_num_alter;\n    \n    //create <fifths> node with the number of alterations\n    TiXmlElement *xfifths = new TiXmlElement(\"fifths\");\n    TiXmlText *xftxt = new TiXmlText(n_alter.str().c_str());\n    xfifths->LinkEndChild(xftxt);\n    // add it to the key elem\n    xkey->LinkEndChild(xfifths);\n    \n    //I dont know what musicxml does with the <mode> tag\n    //bmaybe it is just to annoy programmers using tinyxml\n    //finale sets this always to major\n    TiXmlElement *mode = new TiXmlElement(\"mode\");\n    TiXmlText *major = new TiXmlText(\"major\");\n    mode->LinkEndChild(major);\n    // add it to the key elem\n    xkey->LinkEndChild(mode);\n    \n    // Obviously the order in which <key> <clef> and <time>\n    // are fixed. If in music notation practice we have CLEF then KEY\n    // why should MusicXML follow? the genious architect decided to\n    // force the order of <attributes> REVERSED, <key> BEFORE <clef>\n    // wow.\n    if (!m_xml_current_clef) // no clef\n        m_xml_attributes->LinkEndChild(xkey);\n    else // insert before the clef\n        m_xml_attributes->InsertBeforeChild(m_xml_current_clef, *xkey);\n    \n}\n\nvoid MusXMLOutput::WriteTime(MusLayerElement *element) {\n    MusMensur *timesig = dynamic_cast<MusMensur*>(element);\n    std::stringstream number;\n    \n    CreateAttributes();\n    \n    TiXmlElement *xtime = new TiXmlElement(\"time\");\n    \n    // add symbol attribute if necessay\n    if (timesig->m_meterSymb == METER_SYMB_COMMON) {\n        xtime->SetAttribute(\"symbol\", \"common\");\n        // if the number of beats was not specified, approximate it\n        if (timesig->m_num == 0){\n            timesig->m_num = 4;\n            timesig->m_numBase = 4;\n        }\n    } else if (timesig->m_meterSymb == METER_SYMB_CUT) {\n        xtime->SetAttribute(\"symbol\", \"cut\");\n        if (timesig->m_num == 0){\n            timesig->m_num = 2;\n            timesig->m_numBase = 2;\n        }\n    }\n    \n    // Create beat and beat type attribsb\n    TiXmlElement *xbeats = new TiXmlElement(\"beats\");\n    TiXmlElement *xbtype = new TiXmlElement(\"beat-type\");\n    \n    // convert number to text for beats\n    number << timesig->m_num;\n    TiXmlText *beat_text = new TiXmlText(number.str().c_str());\n    xbeats->LinkEndChild(beat_text);\n    \n    // ditto as above\n    number.clear();\n    number << timesig->m_numBase;\n    TiXmlText *base_text = new TiXmlText(number.str().c_str());\n    xbtype->LinkEndChild(base_text);\n    \n    // push it to xtime\n    xtime->LinkEndChild(xbeats);\n    xtime->LinkEndChild(xbtype);\n    \n    if (!m_xml_current_clef) // no clef\n        m_xml_attributes->LinkEndChild(xtime);\n    else // insert before the clef\n        m_xml_attributes->InsertBeforeChild(m_xml_current_clef, *xtime);\n    \n    // save the current timesig in case we need to create mm rests\n    m_current_time = timesig;\n}\n\nvoid MusXMLOutput::WriteMultiMeasureRest(MusRest *r) {\n    std::stringstream num;\n    num << r->m_multimeasure_dur;\n    \n    TiXmlElement *xmrest = new TiXmlElement(\"multiple-rest\");\n    TiXmlText *mdur = new TiXmlText(num.str().c_str());\n    xmrest->LinkEndChild(mdur);\n    \n    \n    // chech that <attributes> exists\n    CreateAttributes();\n    \n    if (!m_xml_measure_style) {\n        m_xml_measure_style = new TiXmlElement(\"measure-style\");\n        // link it into the current attributes\n        m_xml_attributes->LinkEndChild(m_xml_measure_style);\n    }\n    \n    // put the multiple measure thing into the measure style\n    m_xml_measure_style->LinkEndChild(xmrest);\n    \n    // save the quantity of measures to create\n    m_multimeasure_rests = r->m_multimeasure_dur;\n    \n}\n\nvoid MusXMLOutput::CreateRestsForMultiMeasure() {\n    \n    // unbox all the measures we need\n    for (int i = 0; i < m_multimeasure_rests; i++) {\n        std::stringstream mstring;\n        \n        m_measure_count++;\n        \n        // create a fresh new rest\n        TiXmlElement *note = new TiXmlElement(\"note\");\n        TiXmlElement *rest = new TiXmlElement(\"rest\");\n        \n        note->LinkEndChild(rest);\n        \n        TiXmlElement *duration = new TiXmlElement(\"duration\");\n        TiXmlText *dur_name = new TiXmlText(\"4\");\n        duration->LinkEndChild(dur_name);\n        \n        note->LinkEndChild(duration);\n        \n        // add it to the current part\n        m_xml_part->LinkEndChild(note);\n        // first time is already linked\n        if (i > 0)\n            m_xml_measure->LinkEndChild(m_xml_part);\n        // and to the measure\n        m_xml_score->LinkEndChild(m_xml_measure);\n        \n        // create a new part\n        m_xml_part = new TiXmlElement(\"part\");\n        m_xml_part->SetAttribute(\"id\", \"P1\");\n        \n        m_xml_measure = new TiXmlElement(\"measure\");\n        mstring << m_measure_count;\n        m_xml_measure->SetAttribute(\"number\", mstring.str().c_str());\n        \n    }\n    Mus::LogDebug(\"Measures incremented to %i.\", m_measure_count);\n    m_multimeasure_rests = 0;\n    //m_measure_count--;\n    // we do not want to increment this two times\n    // a new measure is generated after the call to this function\n    m_measure_count--;\n}\n\nvoid MusXMLOutput::WriteNoteOrRest(MusLayerElement *element) {\n    char steps[] = {'C', 'D', 'E', 'F', 'G', 'A', 'B'};\n    std::stringstream number;\n    std::string t;\n    std::string dur;\n    std::string num_of_beams;\n    \n    MusDurationInterface *di = dynamic_cast<MusDurationInterface*>(element);\n    \n    // toplevel note element\n    TiXmlElement *note = new TiXmlElement(\"note\");\n    \n    // duration is common in notes and rests\n    TiXmlElement *duration = new TiXmlElement(\"duration\");\n    \n    switch (di->m_dur) {\n        case DUR_LG: dur = \"64\"; t = \"long\"; break;\n        case DUR_BR: dur = \"32\"; t = \"breve\"; break;\n        case DUR_1: dur = \"16\"; t = \"whole\"; break;\n        case DUR_2: dur = \"8\"; t = \"half\"; break;\n        case DUR_4: dur = \"4\"; t = \"quarter\"; break;\n        case DUR_8: dur = \"2\"; t = \"eighth\"; num_of_beams = \"1\"; break;\n        case DUR_16: dur = \"1\"; t = \"16th\"; num_of_beams = \"2\"; break;\n        case DUR_32: dur = \"1\"; t = \"32nd\"; num_of_beams = \"3\"; break;\n        case DUR_64: dur = \"1\"; t = \"64th\"; num_of_beams = \"4\"; break;\n        case DUR_128: dur = \"1\"; t = \"128th\"; num_of_beams = \"5\"; break;\n            \n        default:\n            break;\n    }\n    \n    // if note we need the <pitch> too\n    if (dynamic_cast<MusNote*>(element)) {\n        MusNote *n = dynamic_cast<MusNote*>(element);\n        // make pitch\n        TiXmlElement *pitch = new TiXmlElement(\"pitch\");\n        TiXmlElement *step = new TiXmlElement(\"step\");\n        TiXmlElement *octave = new TiXmlElement(\"octave\");\n        \n        number << steps[n->m_pname - 1];\n        TiXmlText *step_name = new TiXmlText(number.str().c_str());\n        step->LinkEndChild(step_name);\n        \n        number.clear();\n        number << (int)n->m_oct;\n        TiXmlText *octave_name = new TiXmlText(number.str().c_str());\n        octave->LinkEndChild(octave_name);\n        \n        // do we have an alteration?\n        if (n->m_accid != 0) {\n            number.clear();\n            number << 1;\n            TiXmlElement *xalter = new TiXmlElement(\"alter\");\n            TiXmlText *altnr = new TiXmlText(number.str().c_str());\n            xalter->LinkEndChild(altnr);\n            pitch->LinkEndChild(xalter);\n        }\n        \n        pitch->LinkEndChild(step);\n        pitch->LinkEndChild(octave);\n        note->LinkEndChild(pitch);\n        \n        \n    } else if (dynamic_cast<MusRest*>(element)) {\n        MusRest *r = dynamic_cast<MusRest*>(element);\n        // rests just link a <rest /> item\n        TiXmlElement *rest = new TiXmlElement(\"rest\");\n        \n        note->LinkEndChild(rest);\n        \n        // handle multi measure rest\n        // break from the generation of this element\n        if (r->m_dur == VALSilSpec) {\n            WriteMultiMeasureRest(r);\n            return;\n        }\n    }\n    \n    // put the duration\n    TiXmlText *dur_name = new TiXmlText(dur.c_str());\n    duration->LinkEndChild(dur_name);\n    //link it to <note>\n    note->LinkEndChild(duration);\n    \n    // was the prevous note the last one in a tie?\n    // always close it, ties do not <continue>\n    if (m_tied)\n        SetTie(note, true);\n    // ties go between <duration> and <beam>\n    \n    if (t != \"\") {\n        TiXmlElement *xtype = new TiXmlElement(\"type\");\n        TiXmlText *xtext = new TiXmlText(t.c_str());\n        xtype->LinkEndChild(xtext);\n        note->LinkEndChild(xtype);\n    }\n    \n    // add eventual dots to note/rest\n    // they go after <tie> and before <beam>\n    for (unsigned int i = 1; i == di->m_dots; i++) {\n        // a <dot /> for every dot\n        TiXmlElement *dot = new TiXmlElement(\"dot\");\n        note->LinkEndChild(dot);\n    }\n    \n    // Do beaming\n    if (m_current_beam) {\n        std::string btype;\n        \n        int position = m_current_beam->GetChildIndex( element );\n        \n        // if position == -1, the note is not into the current beam\n        if (position >= 0) {\n            \n            // this flas is set so we know if we are \"into\" a beam\n            if (!m_in_beam) {\n                // not set, note is begining\n                btype = \"begin\";\n                m_in_beam = true;\n            } else {\n                // if this note is the last in the beam, end the beaming\n                if (position == m_current_beam->GetNoteCount() - 1) {\n                    btype = \"end\";\n                    m_current_beam = NULL;\n                    m_in_beam = false;\n                } else {\n                    // note in the middle, do nothing special (continue)\n                    btype = \"continue\";\n                }\n            }\n            \n            // write the xml for the beam\n            TiXmlElement *xbeam = new TiXmlElement(\"beam\");\n            // set the number of beams attribute (!!! couldn't they do this automatically???)\n            // seems to work even if left as 1\n            // num_of_beams is set above when parsing durations\n            xbeam->SetAttribute(\"number\", num_of_beams.c_str());\n            \n            // write the arribute and attach it to beam\n            TiXmlText *xtype = new TiXmlText(btype.c_str());\n            xbeam->LinkEndChild(xtype);\n            \n            // attach the beam to the note\n            note->LinkEndChild(xbeam);\n        } else {\n            Mus::LogDebug(\"Beam with no notes\");\n        }\n    }\n    \n    // measure in partwise\n    // link to part\n    m_xml_part->LinkEndChild(note);\n    \n    // save to current note pointer\n    m_xml_last_note = note;\n}\n\nvoid MusXMLOutput::SetTie(TiXmlElement *xml_note, bool last) {\n    TiXmlElement *xtie = new TiXmlElement(\"tie\");\n    std::string tie_type;\n    \n    if (!last) {\n        tie_type = \"start\";\n        m_tied = true;\n\n    } else {\n        // end tie, reset tied flag\n        tie_type = \"stop\";\n        m_tied = false;\n    }\n    \n    // add text to tie\n    xtie->SetAttribute(\"type\", tie_type.c_str());\n    \n    // add to note\n    // it has to be immediately after <duration>\n    // so search for it\n    TiXmlNode *duration = xml_note->LastChild(\"duration\");\n    // if exists, add it before\n    if (duration)\n        xml_note->InsertAfterChild(duration, *xtie);\n    else\n        // else just at the end\n        xml_note->LinkEndChild(xtie);\n}\n               \nvoid MusXMLOutput::CreateAttributes() {\n    // Make new attributes as necessary\n    if (m_xml_attributes == NULL) {\n        m_xml_attributes = new TiXmlElement(\"attributes\");\n        // put it into the current part\n        m_xml_part->LinkEndChild(m_xml_attributes);\n    }\n}","/////////////////////////////////////////////////////////////////////////////\n// Name:        musiopae.cpp\n// Author:      Rodolfo Zitellini // this is the important stuff!\n// Created:     2012\n// Copyright (c) Laurent Pugin. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musiopae.h\"\n\n//----------------------------------------------------------------------------\n\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n\n#include \"musbarline.h\"\n#include \"musclef.h\"\n#include \"musdoc.h\"\n#include \"muskeysig.h\"\n#include \"musmeasure.h\"\n#include \"musmensur.h\"\n#include \"musmultirest.h\"\n#include \"musnote.h\"\n#include \"muspage.h\"\n#include \"musrest.h\"\n#include \"mussymbol.h\"\n#include \"mussystem.h\"\n#include \"musstaff.h\"\n#include \"mustie.h\"\n#include \"mustuplet.h\"\n\n//----------------------------------------------------------------------------\n\n\n#include <regex.h>\n\n/* Leave them here form now\n#include \"../../llvm_regexp/regex_impl.h\"\n#include \"../../llvm_regexp/regutils.h\"\n#include \"../../llvm_regexp/regex2.h\"\n\n#include \"../../llvm_regexp/regcclass.h\"\n#include \"../../llvm_regexp/regcname.h\"\n\n#define regex_t llvm_regex_t\n#define regmatch_t llvm_regmatch_t\n#define regcomp llvm_regcomp\n#define regerror llvm_regerror\n#define regexec llvm_regexec\n#define regfree llvm_regfree\n*/\n\n#define BEAM_INITIAL    0x01\n#define BEAM_MEDIAL     0x02\n#define BEAM_TERMINAL      0x04\n\n \n// User interface variables:\nint       debugQ = 0;                // used with --debug option\nint       stdoutQ = 0;\nchar      outdir[1024] = {0};        // used with -d option\nchar      extension[1024] = {0};     // used with -e option\nchar      hum2abc[1024] = {0};       // used with -a option\nint       quietQ  = 0;               // used with -q option\nint       quiet2Q = 0;               // used with -Q option\n\n// Global variables:\nchar data_line[10001] = {0};\n#define MAX_DATA_LEN 1024 // One line of the pae file whould not be this long!\nchar data_key[MAX_DATA_LEN]; \nchar data_value[MAX_DATA_LEN]; //ditto as above\n\n\n//////////////////////////////////////////////////////////////////////////\n\n//----------------------------------------------------------------------------\n// MusPaeInput\n//----------------------------------------------------------------------------\n\nMusPaeInput::MusPaeInput( MusDoc *doc, std::string filename ) :\n// This is pretty bad. We open a bad fileoinputstream as we don't use it\nMusFileInputStream( doc )\n{\n    m_filename = filename;\n\tm_staff = NULL;\n    m_measure = NULL;\n\tm_layer = NULL;\n    m_current_tie = NULL;\n}\n\nMusPaeInput::~MusPaeInput()\n{\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nbool MusPaeInput::ImportFile()\n{\n    \n    std::ifstream infile;\n    infile.open(m_filename.c_str());\n    \n    convertPlainAndEasyToKern(infile, std::cout);\n    \n    return true;\n}\n\nbool MusPaeInput::ImportString(std::string pae)\n{\n    \n    std::istringstream in_stream(pae);\n    \n    convertPlainAndEasyToKern(in_stream, std::cout);\n    \n    return true;\n}\n\n//////////////////////////////\n//\n// convertPlainAndEasyToKern --\n//\n\nvoid MusPaeInput::convertPlainAndEasyToKern(std::istream &infile, std::ostream &out) {\n    // buffers\n    char c_clef[1024] = {0};\n    char c_key[1024] = {0};\n    char c_keysig[1024] = {0};\n    char c_timesig[1024] = {0};\n    char c_alttimesig[1024] = {0};\n    char incipit[10001] = {0};\n    bool in_beam = false;\n    \n    std::string s_key;\n    MeasureObject current_measure;\n    NoteObject current_note;\n    \n    //Array<int> current_key; // not the measure one, which will be altered by temporary alterations\n    //current_key.setSize(7);\n    //current_key.setAll(0);\n    \n    std::vector<MeasureObject> staff;\n    \n    // read values\n    while (!infile.eof()) {\n        infile.getline(data_line, 10000);\n        if (infile.eof()) {\n            Mus::LogDebug(\"Truncated file or ending tag missing\");\n            //exit(1);\n        }\n        getAtRecordKeyValue(data_key, data_value, data_line);\n        if (strcmp(data_key,\"end\")==0) {   \n            break;\n        } else if (strcmp(data_key,\"clef\")==0) { \n            strcpy( c_clef, data_value );\n        } else if (strcmp(data_key,\"key\")==0) { \n            strcpy( c_key, data_value );\n        } else if (strcmp(data_key,\"keysig\")==0) { \n            strcpy( c_keysig, data_value );\n        } else if (strcmp(data_key,\"timesig\")==0) { \n            strcpy( c_timesig, data_value );\n        } else if (strcmp(data_key,\"alttimesig\")==0) { \n            strcpy( c_alttimesig, data_value );\n        } else if (strcmp(data_key,\"data\")==0) { \n            strcpy( incipit, data_value );\n        } else if (strncmp(data_line,\"!!\", 2) == 0) { \n            out << data_line << \"\\n\";\n        }\n    }\n    \n    if (strlen(c_clef)) {\n        MusClef *c = new MusClef;\n        getClefInfo(c_clef, c );    // do we need to put a default clef?\n        current_measure.clef = c;\n    }\n\n    if (strlen(c_keysig)) {\n        getKeyInfo( c_keysig, &current_measure);\n    }\n    if (strlen(c_timesig)) {\n        getTimeInfo( c_timesig, &current_measure);\n    }   \n    \n    // read the incipit string\n    int length = strlen(incipit);\n    int i = 0;\n\twhile(i < length) {\n        // eat the input...\n        \n\t\tif (incipit[i] == ' ') {\n            // just skip\n            i++;\n        }\n        \n        // octaves\n        if ((incipit[i] == '\\'') || (incipit[i] == ',')) {\n            i += getOctave( incipit, &current_note.octave, i );\n        }\n        \n        // rhythmic values\n        else if (isdigit(incipit[i]) != 0) {\n            i += getDurations( incipit, &current_measure, i );\n        }\n        \n        //accidentals (1 = n; 2 = x; 3 = xx; 4 = b; 5 = bb)    \n        else if (incipit[i] == 'n' || incipit[i] == 'x' || incipit[i] == 'b') {\n            i += getAccidental( incipit, &current_note.accidental, i );\n        }\n        \n        //\n        // beaming starts\n\t\telse if (incipit[i] == '{') {\n\t\t\t//current_note.beam = 1;\n            current_note.beam = BEAM_INITIAL;\n            in_beam = true;\n        }\n        \n        // beaming ends\n\t\telse if (incipit[i] == '}' && in_beam) {\n            current_measure.notes[current_measure.notes.size() - 1].beam = BEAM_TERMINAL;\n            current_note.beam = 0;\n            in_beam = false;\n\t\t}\n\t\t\n        // slurs are read when adding the note\n\t\telse if (incipit[i] == '+') {\n        }\n        \n\t\t// beginning tuplets & fermatas\n\t\telse if (incipit[i] == '(') {\n            i += getTupletFermata( incipit, &current_note, i );\n\t\t}\n        \n        // end of tuplets\n\t\telse if ((incipit[i] == ';') || (incipit[i] == ')')) {\n            i += getTupletFermataEnd( incipit, &current_note, i );\n\t\t}\n        \n\t\t// trills are read when adding the note\n\t\telse if (incipit[i] == 't') {\n        }\n        \n\t\t//grace notes\n\t\telse if ((incipit[i] == 'g') || (incipit[i] == 'q')) {\n\t\t\ti += getGraceNote( incipit, &current_note, i );\n\t\t}\n\t\t\n        \n        // end of appogiatura\n\t\telse if (incipit[i] == 'r') {\n\t\t\tcurrent_note.appoggiatura = 0; // should not have to be done, but just in case\n        }\n        \n        //note and rest\n        // getNote also creates a new note object\n        else if (((incipit[i]-'A'>=0) && (incipit[i]-'A'<7)) || (incipit[i]=='-')) {\n            i += getNote( incipit, &current_note, &current_measure, i );\n        }\n        \n  \t\t// whole rest\n\t\telse if (incipit[i] == '=') {\n            i += getWholeRest( incipit, &current_measure.wholerest, i );\t\t\n\t\t} \n        \n\t\t// abbreviation\n        else if (incipit[i] == '!') {\n            i += getAbbreviation( incipit, &current_measure, i );\n        }\n        \n        // measure repetition\n        else if ((incipit[i] == 'i') && staff.size() > 0) {\n            MeasureObject last_measure = staff[staff.size() - 1];\n            current_measure.notes = last_measure.notes;\n            // time was copied explicitally, but now not anymore\n            //current_measure.time = last_measure.time;\n            \n            // if old measure does not end with a tie\n            // force the first note of the newly copied measure to be without tie\n            // this is to prevent copying tie closes which are invalid\n            if (last_measure.notes[last_measure.notes.capacity() - 1].tie == 0)\n                current_measure.notes[0].tie = 0;\n        }\n        \n        //barline\n        else if ((incipit[i] == ':') || (incipit[i] == '/')) {\n            i += getBarline(incipit, &current_measure.barline, i);\n            current_measure.abbreviation_offset = 0; // just in case...\n            staff.push_back( current_measure );\n            current_measure.reset();\n        }\n        \n\t\t//clef change\n\t\telse if ((incipit[i] == '%') && (i+1 < length)) {\n            MusClef *c = new MusClef;\n            i += getClefInfo(incipit, c, i + 1);\n            current_note.clef = c;\n        }\n        \n\t\t//time signature change\n\t\telse if ((incipit[i] == '@') && (i+1 < length)) {\n            i += getTimeInfo( incipit, &current_measure, i + 1);\n        } \n        \n  \t\t//key signature change\n\t\telse if ((incipit[i] == '$') && (i+1 < length)) {\n            i += getKeyInfo( incipit, &current_measure, i + 1);\n\t\t} \n        \n        //\n        //if (in_beam && (current_note.beam & BEAM_INITIAL) == 0 && (current_note.beam & BEAM_TERMINAL) == 0) {\n        //    current_note.beam |= BEAM_MEDIAL;\n        //}\n        // // ax2.3 LP\n            \n        i++;\n    }\n    \n    // we need to add the last measure if it has no barline at the end\n    if (current_measure.notes.size() != 0) {\n        //current_measure.barline = \"=-\";\n        staff.push_back( current_measure );\n        current_measure.notes.clear();\n    }\n    \n    \n    m_doc->Reset( Raw );\n    MusPage *page = new MusPage();\n    MusSystem *system = new MusSystem();\n    \n    int measure_count = 1;\n    \n    std::vector<MeasureObject>::iterator it;\n    for ( it = staff.begin() ; it < staff.end(); it++ ) {\n        \n        \n        m_staff = new MusStaff( 1 );\n        m_measure = new MusMeasure( true, measure_count );\n        m_layer = new MusLayer( 1 );\n        \n        m_staff->AddLayer(m_layer);\n        m_measure->AddStaff( m_staff );\n        system->AddMeasure( m_measure );\n        \n        MeasureObject obj = *it;\n        printMeasure( out, &obj );\n        measure_count++;\n    }\n\n    // add miniaml scoreDef\n    MusStaffGrp *staffGrp = new MusStaffGrp();\n    MusStaffDef *staffDef = new MusStaffDef();\n    staffDef->SetStaffNo( 1 );\n    staffGrp->AddStaffDef( staffDef );\n    m_doc->m_scoreDef.AddStaffGrp( staffGrp );\n\n    page->AddSystem( system );\n    m_doc->AddPage( page );\n}\n\n\n\n//////////////////////////////\n//\n// getOctave --\n//\n#define BASE_OCT 4\nint MusPaeInput::getOctave (const char* incipit, unsigned char *octave, int index ) {\n    \n    int i = index;\n    int length = strlen(incipit);\n    if (incipit[i] == '\\'') {\n        *octave = BASE_OCT;\n        while ((i+1 < length) && (incipit[i+1] == '\\'')) {\n            (*octave)++;\n            i++;\n        }\n    } else if (incipit[i] == ',') {\n        //negative octave\n        *octave = BASE_OCT - 1;\n        while ((i+1 < length) && (incipit[i+1] == ',')) {\n            (*octave)--;\n            i++;\n        }\n    }\n    \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getDuration --\n//\n\nint MusPaeInput::getDuration(const char* incipit, int *duration, int *dot, int index ) {\n    \n    int i = index;\n    int length = strlen(incipit);\n    \n    switch (incipit[i]) {\n        case '0': *duration = DUR_LG; break;\n        case '1': *duration = DUR_1; break;\n        case '2': *duration = DUR_2; break;\n        case '3': *duration = DUR_32; break;\n        case '4': *duration = DUR_4; break;\n        case '5': *duration = DUR_64; break;\n        case '6': *duration = DUR_16; break;\n        case '7': *duration = DUR_128; break;\n        case '8': *duration = DUR_8; break;\n        case '9': *duration = DUR_BR; break;\n    }\n     \n    \n    *dot=0;\n    if ((i+1 < length) && (incipit[i+1] == '.')) {\n        // one dot\n        (*dot)++;\n        i++;\n    }\n    if ((i+1 < length) && (incipit[i+1] == '.')) {\n        // two dots\n        (*dot)++;\n        i++;\n    }\n    if ((*dot == 1) && (*duration == 7)) {\n        // neumatic notation\n        *duration = 1.0;\n        *dot = 0;\n        std::cout << \"Warning: found a note in neumatic notation (7.), using quarter note instead\" << std::endl;\t\t\t\t\n    }\n    \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getDurations --\n//\n\nint MusPaeInput::getDurations(const char* incipit, MeasureObject* measure, int index ) {\n    \n    int i = index;\n    int length = strlen(incipit);\n    \n    measure->durations_offset = 0;\n    measure->durations.clear();\n    measure->dots.clear();\n    \n    //int j = 0;\n    do {\n        int dur, dot;\n        //measure->dots.setSize(j+1);\n        i += getDuration(incipit, &dur, &dot, i );\n        measure->durations.push_back(dur);\n        measure->dots.push_back(dot);\n        //j++;\n        if ((i+1 < length) && isdigit(incipit[i+1])) {\n            i++;\n        } else {\n            break;\n        }\n    } while ( 1 );\n    \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getAccidental --\n//\n\nint MusPaeInput::getAccidental(const char* incipit, unsigned char *accident, int index ) {\n    \n    int i = index;\n    int length = strlen(incipit);\n    \n    if (incipit[i] == 'n') {\n        *accident = ACCID_NATURAL;\n    } else if (incipit[i] == 'x') {\n        *accident = ACCID_SHARP;\n        if ((i+1 < length) && (incipit[i+1] == 'x')) {\n            *accident = ACCID_DOUBLE_SHARP;\n            i++;\n        }\n    } else if (incipit[i] == 'b') {\n        *accident = ACCID_FLAT;\n        if ((i+1 < length) && (incipit[i+1] == 'b')) {\n            *accident = ACCID_DOUBLE_FLAT;\n            i++;\n        }\n    }\n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getTupletOrFermata --\n//\n\nint MusPaeInput::getTupletFermata(const char* incipit, NoteObject* note, int index ) {\n    \n    int i = index;\n    int length = strlen(incipit);\n    \n    // detect if it is a fermata or a tuplet\n    regex_t re;\n    regcomp(&re, \"^([^)]*[ABCDEFG-][^)]*[ABCDEFG-][^)]*)\", REG_EXTENDED);\n    int is_tuplet = regexec(&re, incipit + i, 0, NULL, 0);\n    regfree(&re);\n    \n    if (is_tuplet == 0) {\n        int t = i;\n        int t2 = 0;\n        int tuplet_val = 0;\n        char *buf;\n        \n        // Triplets are in the form (4ABC)\n        // index points to the '(', so we look back\n        // if the resut is a number or dot, it means we have the long format\n        // i.e. 4(6ABC;5) or 4.(6ABC;5)\n        if ((index != 0) && (isdigit(incipit[index - 1]) || incipit[index - 1] == '.')) {\n            \n            // create the buffer so we can convert the tuplet nr to int\n            buf = (char*)malloc(length + 1); // allocate it with space for 0x00\n            memset(buf, 0x00, length + 1); // wipe it up\n            \n            // move until we find the ;\n            while ((t < length) && (incipit[t] != ';')) {\n                \n                // we should not find the parens before the ';' !\n                // FIXME find a graceful way to exit signaling this to user\n                if (incipit[t] == ')') {\n                    Mus::LogDebug(\"You have a ) before the ; in a tuplet!\");\n                    return i - index;\n                }\n                \n                t++;\n            }\n            \n            //t + 1 should point to the number\n            t++; // move one char to the number\n            while (( (t + t2) < length) && (incipit[t + t2] != ')')) {\n                \n                // If we have extraneous chars, exit here\n                if (!isdigit(incipit[t + t2])) {\n                    Mus::LogDebug(\"You have a non-number in a tuplet number\");\n                    return i - index;\n                }\n                \n                // copy the number char-by-char\n                buf[t2] = incipit[t + t2];\n                t2++;\n            }\n            \n            tuplet_val = atoi(buf);\n            free(buf); // dispose of the buffer\n        \n        } else { // it is a triplet\n            // don't care to parse all the stuff\n            tuplet_val = 3;\n        }\n        \n        // this is the first note, the notal number of notes = tuplet_val\n        note->tuplet_notes = tuplet_val;\n        // but also the note counter\n        note->tuplet_note =  tuplet_val;\n        \n    } else {\n        if ( note->tuplet_notes > 0 ) {\n            std::cout << \"Warning: fermata within a tuplet. Won't be handled correctly\" << std::endl;\n        }\n        note->fermata = true;\n    }\n    \n    return i - index;\n    \n}\n\n\n\n//////////////////////////////\n//\n// getTupletFermataEnd --\n//\n// this can be deleted in the future?\nint MusPaeInput::getTupletFermataEnd(const char* incipit, NoteObject *note, int index ) {\n    \n    int i = index;\n    //int length = strlen(incipit);\n        \n    // TODO currently fermatas inside tuplets won't be handled correctly\n    note->fermata = false;\n        \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getGraceNote --\n//\n\nint MusPaeInput::getGraceNote(const char* incipit, NoteObject *note, int index ) {\n    \n    int i = index;\n    int length = strlen(incipit);\n    \n    //acciaccatura\n    if (incipit[i] == 'g') {\n        note->acciaccatura = true;\n    }\n    \n    // appoggiatura\n    else if (incipit[i] == 'q') {\n        note->appoggiatura = 1;\n        if ((i+1 < length) && (incipit[i+1] == 'q')) {\n            note->appoggiatura_multiple = true;\n            i++;\n            int r = i;\n            while ((r < length) && (incipit[r] != 'r')) {\n                if ((incipit[r]-'A'>=0) && (incipit[r]-'A'<7)) {\n                    note->appoggiatura++;\n                }\n                r++;\n            }\n        }\n    }\n    return i - index;\n}\n\n\n//////////////////////////////\n//\n// getPitch --\n//\n\nint MusPaeInput::getPitch( char c_note ) {\n    int pitch;\n    \n    switch (c_note) {\n        case 'A':\n            pitch = PITCH_A;\n            break;\n        case 'B': \n            pitch = PITCH_B;\n            break;\n        case 'C': \n            pitch = PITCH_C;\n            break;\n        case 'D': \n            pitch = PITCH_D;\n            break;\n        case 'E': \n            pitch = PITCH_E;\n            break;\n        case 'F': \n            pitch = PITCH_F;\n            break;\n        case 'G': \n            pitch = PITCH_G;\n            break;\n        case '-': pitch = 255; break;\n        default:\n            break;\n    }\n    return pitch;\n}\n\n\n//////////////////////////////\n//\n// getTimeInfo -- read the key signature.\n//\n\nint MusPaeInput::getTimeInfo( const char* incipit, MeasureObject *measure, int index) {\n    \n    int i = index;\n    int length = strlen(incipit);\n    MusMensur *meter = new MusMensur;\n    \n    if (!isdigit(incipit[i]) && (incipit[i] != 'c') && (incipit[i] != 'o'))\n        return 0;\n    \n    // find the end of time signature end\n    i++; // the time signature length is a least 1\n    while (i < length) {\n        if (!isdigit(incipit[i]) && (incipit[i] != '/') && (incipit[i] != '.')) {\n            break;\n        }\n        i++;\n    }\n        \n    // use a substring for the time signature \n    char timesig_str[1024];\n    memset( timesig_str, 0, 1024 );\n    // strncpy not always put the \\0 in the end!\n    strncpy( timesig_str, incipit + index, i - index); \n    \n    std::ostringstream sout;\n    regex_t re;\n    \n    // check if format X/X or one digit only\n    regcomp(&re, \"^[0-9]*/[0-9]*$\", REG_EXTENDED);\n    int is_standard = regexec(&re, timesig_str, 0, NULL, 0);\n    regfree(&re);\n    regcomp(&re, \"^[0-9]*$\", REG_EXTENDED);\n    int is_one_number = regexec(&re, timesig_str, 0, NULL, 0);\n    regfree(&re);\n    \n    if ( is_standard == 0) {\n        char buf_str[1024];\n        strcpy(buf_str, timesig_str);\n        int beats = atoi(strtok(buf_str, \"/\"));\n        int note_value = atoi(strtok(NULL, \"/\")); \n        //timeinfo[0] = (double)beats; timeinfo[1] = 4.0/(double)note_value;\n        //sout << \"*M\" << beats << \"/\" << note_value;\n        meter->m_num = beats;\n        meter->m_numBase = note_value;\n    } else if ( is_one_number == 0) {\n        int beats = atoi(timesig_str);\n        meter->m_num = beats;\n        meter->m_numBase = 1;\n        //timeinfo[0] = (double)beats; timeinfo[1] = 4.0/1.0;\n        //sout << \"*M\" << beats << \"/1\\n*met(\" << beats << \")\";\n        //std::cout << output << std::endl;\n    } else if (strcmp(timesig_str, \"c\") == 0) {\n        // C\n        ////imeinfo[0] = 4.0; timeinfo[1] = 4.0/4.0;\n        meter->m_meterSymb = METER_SYMB_COMMON;\n    } else if (strcmp(timesig_str, \"c/\") == 0) {\n        // C|\n        //timeinfo[0] = 2.0; timeinfo[1] = 4.0/2.0;\n        meter->m_meterSymb = METER_SYMB_CUT;\n    } else if (strcmp(timesig_str, \"c3\") == 0) {\n        // C3\n        //timeinfo[0] = 3.0; timeinfo[1] = 4.0/1.0;\n        meter->m_meterSymb = METER_SYMB_3;\n    } else if (strcmp(timesig_str, \"c3/2\") == 0) {\n        // C3/2\n        //timeinfo[0] = 3.0; timeinfo[1] = 4.0/2.0;\n        meter->m_meterSymb = METER_SYMB_3_CUT; // ??\n    } else {\n        //timeinfo[0] = 4.0; timeinfo[1] = 4.0/4.0;\n        //sout << \"*M4/4\\n!! unknown time signature\";\n        std::cout << \"Warning: unknown time signature: \" << timesig_str << std::endl;\n        \n    }\n\n    measure->time = meter;\n    \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getClefInfo -- read the key signature.\n//\n\nint MusPaeInput::getClefInfo( const char *incipit, MusClef *mclef, int index ) {\n    \n    // a clef is maximum 3 character length\n    // go through the 3 character and retrieve the letter (clef) and the line\n    // mensural clef (with + in between) currently ignored\n    // clef with octava correct?\n    int length = strlen(incipit);\n    int i = 0;\n    char clef = 'G';\n    char line = '2';\n    while ((index < length) && (i < 3)) {\n        if (i == 0) {\n            clef = incipit[index];\n        } else if (i == 2) {\n            line = incipit[index];\n        }\n        i++;\n        index++;\n    }\n\n    \n    if (clef == 'C') {\n        switch (line) {\n            case '1': mclef->m_clefId = UT1; break;\n            case '2': mclef->m_clefId = UT2; break;\n            case '3': mclef->m_clefId = UT3; break;\n            case '4': mclef->m_clefId = UT4; break;\n        }\n    } else if (clef == 'G') {\n        switch (line) {\n            case '1': mclef->m_clefId = SOL1; break;\n            case '2': mclef->m_clefId = SOL2; break;\n        }\n    } else if (clef == 'F') {\n        switch (line) {\n            case '3': mclef->m_clefId = FA3; break;\n            case '4': mclef->m_clefId = FA4; break;\n            case '5': mclef->m_clefId = FA5; break;\n        }\n    } else {\n        // what the...\n        Mus::LogDebug(\"Clef is ??\");\n    }\n    \n    //measure->clef = mclef;\n        \n    return i;\n}\n\n\n\n//////////////////////////////\n//\n// getWholeRest -- read the getWholeRest.\n//\n\nint MusPaeInput::getWholeRest( const char *incipit, int *wholerest, int index ) {\n    \n    int length = strlen(incipit);\n    int i = index;\n    \n    *wholerest = 1;\n    if ((i+1 < length) && isdigit(incipit[i+1])) {\n        sscanf(&(incipit[i+1]), \"%d\", wholerest);\n        char buf[10];\n        memset( buf, 0, 10 );\n        sprintf( buf, \"%d\", *wholerest );\n        i += strlen( buf );\n    }\n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getBarline -- read the barline.\n//\n\nint MusPaeInput::getBarline( const char *incipit, std::string *output, int index ) {\n    \n    regex_t re;\n    regcomp(&re, \"^://:\", REG_EXTENDED);\n    int is_rep_db_rep = regexec(&re, incipit + index, 0, NULL, 0);\n    regfree(&re);\n    regcomp(&re, \"^://\", REG_EXTENDED);\n    int is_rep_db = regexec(&re, incipit + index, 0, NULL, 0);\n    regfree(&re);\n    regcomp(&re, \"^//:\", REG_EXTENDED);\n    int is_db_rep = regexec(&re, incipit + index, 0, NULL, 0);\n    regfree(&re);\n    regcomp(&re, \"^//\", REG_EXTENDED);\n    int is_db = regexec(&re, incipit + index, 0, NULL, 0);\n    regfree(&re);\n    \n    int i = 0; // number of characters\n    if (is_rep_db_rep == 0) {\n        *output = \"=:||:\";\n        i = 3;\n    } else if (is_rep_db == 0) {\n        *output = \"=:|!\";\n        i = 2;\n    } else if (is_db_rep == 0) {\n        *output = \"=!|:\";\n        i = 2;\n    } else if (is_db == 0) {\n        *output = \"=||\";\n        i = 1;\n    } else {\n        *output = \"=\";\n        i = 0;\n    }\n    return i;\n}\n\n\n\n//////////////////////////////\n//\n// getAbbreviation -- read abbreviation\n//\n\nint MusPaeInput::getAbbreviation(const char* incipit, MeasureObject *measure, int index ) {\n    \n    int length = strlen(incipit);\n    int i = index;\n    int j;\n    \n    if (measure->abbreviation_offset == -1) { // start\n        measure->abbreviation_offset = measure->notes.size();\n    } else { //\n        int abbreviation_stop = measure->notes.size();\n        while ((i+1 < length) && (incipit[i+1]=='f')) {\n            i++;\n            for(j=measure->abbreviation_offset; j<abbreviation_stop; j++) {\n                measure->notes.push_back( measure->notes[j] );\n            }\n        }\n        measure->abbreviation_offset = -1;   \n    }\n    \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getKeyInfo -- read the key signature.\n//\n\nint MusPaeInput::getKeyInfo(const char *incipit, MeasureObject *measure, int index ) {\n            \n    // at the key information line, extract data\n    int length = strlen(incipit);\n    int i = index;\n    bool end_of_keysig = false;\n    while ((i < length) && (!end_of_keysig)) {\n        switch (incipit[i]) {\n            case 'b': measure->key_alteration = ACCID_FLAT; break;\n            case 'x': measure->key_alteration = ACCID_SHARP; break;\n            //case '[': paren =  1; break;\n            //case ']': paren =  1; break;\n            case 'F': measure->key.push_back(PITCH_F); break;\n            case 'C': measure->key.push_back(PITCH_C); break;\n            case 'G': measure->key.push_back(PITCH_G); break;\n            case 'D': measure->key.push_back(PITCH_D); break;\n            case 'A': measure->key.push_back(PITCH_A); break;\n            case 'E': measure->key.push_back(PITCH_E); break;\n            case 'B': measure->key.push_back(PITCH_B); break;\n            default:\n                end_of_keysig = true;\n                //if (debugQ) {\n                //  std::cout << \"Warning: unknown character: \" << keysig_str[i] << \" in key signature \" << keysig_str\n                //       << std::endl;\n                //exit(1);\n                //}\n                break;\n        }\n        if (!end_of_keysig)\n            i++;\n    }\n    \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// getNote --\n//\n\nint MusPaeInput::getNote( const char* incipit, NoteObject *note, MeasureObject *measure, int index ) {\n    \n    regex_t re;\n    int oct, tie;\n    int i = index;\n    bool acc;\n    int app;\n    int tuplet_num;\n    \n    if (note->acciaccatura) {\n        // acciaccaturas are always eights regardless\n        // and have no dots\n        note->duration = DUR_8;\n    } else {\n        note->duration = measure->durations[measure->durations_offset];\n        note->dots = measure->dots[measure->durations_offset];\n    }\n    note->pitch = getPitch( incipit[i] );\n    \n    // lookout, hack. If it is a rest (255 val) then create the rest object.\n    // it will be added instead of the note\n    if (note->pitch == 255)\n        note->rest = true;\n    \n    // beaming\n    // detect if it is a fermata or a tuplet\n    if (note->beam > 0) {\n        regcomp(&re, \"^[^}/]*[ABCDEFG-].*\", REG_EXTENDED);\n        int is_not_last_note = regexec(&re, incipit + i + 1, 0, NULL, 0);\n        regfree(&re);\n        //std::cout << \"regexp \" << is_not_last_note << std::endl;\n        if ( is_not_last_note != 0 ) {\n            //note->beam = -1; // close the beam\n\n            //note->beam = BEAM_TERMINAL;\n             // ax2.3\n        }\n    } \n    \n    // trills\n    regcomp(&re, \"^[^ABCDEFG]*t\", REG_EXTENDED);\n    int has_trill = regexec(&re, incipit + i + 1, 0, NULL, 0);\n    regfree(&re);\n    if ( has_trill == 0 ) {\n        note->trill = true;\n    }\n    \n    // tie\n    regcomp(&re, \"^[^ABCDEFG]*\\\\+\", REG_EXTENDED);\n    int has_tie = regexec(&re, incipit + i + 1, 0, NULL, 0);\n    regfree(&re);\n    //std::cout << \"regexp \" << has_tie << std::endl;\n    if ( has_tie == 0) {\n        if (note->tie == 0)\n            note->tie = 1; // reset 1 for the first note, >1 for next ones is incremented under\n    }\n    \n    tie = note->tie;\n    // last note in tie\n    if (has_tie != 0 && tie > 0)\n        tie = 0;\n    \n    oct = note->octave;\n    measure->notes.push_back( *note );\n    \n    acc = note->acciaccatura;\n    app = note->appoggiatura;\n    tuplet_num = note->tuplet_note;\n    \n    // Reset note to defaults\n    note->clear();\n    \n    // write back the values we need to save\n\n    note->octave = oct; // save octave\n    \n    // tuplets. Decrease the current number is we are in a tuplet\n    // i.e. tuplet_num > 0\n    // al the other values just need to be in the first note\n    if (tuplet_num > 0)\n        note->tuplet_note = --tuplet_num;\n    \n    // If prevous note has tie, increment tie count\n    if (tie > 0)\n        note->tie = ++tie;\n    \n    // grace notes\n    note->acciaccatura = false;\n    if (app > 0) {\n        //std::cout << note->appoggiatura << std::endl; \n        note->appoggiatura = --app;\n        note->appoggiatura_multiple = false;\n    }\n    // durations\n    if (measure->durations.size() > 0) {\n        measure->durations_offset++;\n        if (measure->durations_offset >= measure->durations.size()) {\n            measure->durations_offset = 0;\n        }\n    }\n    \n    note->fermata = false; // only one note per fermata;\n    note->trill = false;\n    \n    return i - index;\n}\n\n\n\n//////////////////////////////\n//\n// printMeasure --\n//\n\nvoid MusPaeInput::printMeasure(std::ostream& out, MeasureObject *measure ) {\n    \n    if ( measure->clef != NULL ) {\n        m_layer->AddElement(measure->clef);\n    }\n    \n    if ( measure->key.size() > 0 ) {\n        MusKeySig *key = new MusKeySig(measure->key.size(), measure->key_alteration);\n        m_layer->AddElement(key);\n    }\n    \n    if ( measure->time != NULL ) {\n        m_layer->AddElement(measure->time);\n    }\n    \n    if ( measure->wholerest > 0 ) { \n        MusMultiRest *mr = new MusMultiRest(measure->wholerest);\n        m_layer->AddElement(mr);\n    }\n    \n    m_nested_objects.clear();\n\n    for (unsigned int i=0; i<measure->notes.size(); i++) {\n        NoteObject note = measure->notes[i];\n        parseNote(note);\n    }\n    \n    // Set barline\n    // FIXME use flags for proper barline identification\n    if ( measure->barline.length() ) {\n        MusBarline *bline = m_measure->GetRightBarline();\n        if (measure->barline == \"=\")\n            bline->m_barlineType = BARLINE_SINGLE;\n        else \n            bline->m_barlineType = BARLINE_DBL;\n        \n        //m_layer->AddElement(bline);\n    }\n    \n    //m_staff->AddLayer(m_layer);\n}\n\nvoid MusPaeInput::parseNote(NoteObject note) {\n    \n    MusLayerElement *element;\n    \n    if (note.rest) {\n        MusRest *rest =  new MusRest();\n\n        rest->m_pname = REST_AUTO;\n        rest->m_dots = note.dots;\n        rest->m_dur = note.duration;\n\n        if (note.fermata)\n            rest->m_fermata = true;\n        \n        element = rest;\n    } else {\n        MusNote *mnote = new MusNote();\n        \n        mnote->m_pname = note.pitch;\n        mnote->m_oct = note.octave;\n        mnote->m_accid = note.accidental;\n        \n        mnote->m_dots = note.dots;\n        mnote->m_dur = note.duration;\n        \n        if (note.fermata)\n            mnote->m_fermata = true;\n        \n        if (note.trill == true)\n            mnote->m_embellishment = EMB_TRILL;\n        \n        element = mnote;\n    }\n    \n\n    // Acciaccaturas are similar but do not get beamed (do they)\n    // this case is simpler. NOTE a note can not be acciacctura AND appoggiatura\n    // Acciaccatura rests do not exist\n    if (note.acciaccatura && dynamic_cast<MusNote *>(element)) {\n        element->m_cueSize = true;\n        dynamic_cast<MusNote *>(element)->m_acciaccatura = true;\n    }\n    \n    \n    if (note.beam == BEAM_INITIAL)\n        PushContainer(new MusBeam());\n    \n    // we have a tuplet, the tuplet_note is > 0\n    // which means we are counting a tuplet\n    if (note.tuplet_note > 0 && note.tuplet_notes == note.tuplet_note) // first elem in tuplet\n        PushContainer(new MusTuplet());\n    \n    if (note.appoggiatura > 0) {\n        element->m_cueSize = true;\n        \n        if (note.appoggiatura_multiple && note.appoggiatura > 1)\n            PushContainer(new MusBeam());\n\n    }\n    \n    // Add the note to the current container\n    AddLayerElement(element);\n    \n    \n    // this is the last note in appoggiatura beam, set the beam to null\n    if (note.appoggiatura_multiple && note.appoggiatura == 2) // last one in a beam is 2\n        PopContainer();\n\n    // the last note counts always '1'\n    // insert the tuplet elem\n    // and reset the tuplet counter\n    if (note.tuplet_note == 1)\n        PopContainer();\n    \n    if (note.beam == BEAM_TERMINAL)\n        PopContainer();\n}\n\nvoid MusPaeInput::PushContainer(MusLayerElement *container) {\n    AddLayerElement(container);\n    m_nested_objects.push_back(container);\n}\n\nvoid MusPaeInput::PopContainer() {\n    assert(m_nested_objects.size() > 0);\n    m_nested_objects.pop_back();\n}\n\nvoid MusPaeInput::AddLayerElement(MusLayerElement *element) {\n    \n    if (m_nested_objects.size() > 0) {\n        MusLayerElement *bottom = m_nested_objects.back();\n        \n        if ( dynamic_cast<MusBeam*>( bottom ) ) {\n            ((MusBeam*)bottom)->AddElement( element );\n        }\n        else if ( dynamic_cast<MusTuplet*>( bottom ) ) {\n            ((MusTuplet*)bottom)->AddElement( element );\n        }\n        \n    } else {\n        m_layer->AddElement(element);\n    }\n}\n\n\n//////////////////////////////\n//\n// getAtRecordKeyValue --\n//   Formats: @key: value\n//            @key:value\n//            @key :value\n//            @ key :value\n//            @ key : value\n//   only one per line\n//\n\nvoid MusPaeInput::getAtRecordKeyValue(char *key, char* value,\n                                      const char* input) {\n    \n#define SKIPSPACE while((index<length)&&isspace(input[index])){index++;}\n    \n    char MARKER    = '@';\n    char SEPARATOR = ':';\n    char EMPTY     = '\\0';\n    \n    int length = strlen(input);\n    int count = 0;\n    \n    // zero out strings\n    memset(key, EMPTY, MAX_DATA_LEN);\n    memset(value, EMPTY, MAX_DATA_LEN);\n\n    \n    if (length == 0)\n        return;\n    \n    char ch;\n    int index = 0;\n    \n    // find starting @ symbol (ignoring any starting space)\n    SKIPSPACE\n    if (input[index] != MARKER) {\n        // invalid record format since it does not start with @\n        return;\n    }\n    index++;\n    SKIPSPACE\n    \n    // start storing the key value:\n    while ((index < length) && (input[index] != SEPARATOR)) {\n        if (isspace(input[index])) {\n            continue;\n            index++;\n        }\n        ch = input[index]; \n        \n        // Should never happen\n        if (count >= MAX_DATA_LEN)\n            return;\n        \n        key[count] = ch;\n        count++;\n        index++;\n    }\n    // check to see if valid format: (:) must be the current character\n    if (input[index] != SEPARATOR) {\n        key[0] = EMPTY;\n        return;\n    }\n    index++;\n    SKIPSPACE\n    \n    // Also should never happen\n    if (strlen(&input[index]) > MAX_DATA_LEN)\n        return;\n    strcpy(value, &input[index]);\n    \n    // Thruncate string to first space\n    for (int i = strlen(value) - 2; i > 0; i--) {\n        if (isspace(value[i])) {\n            value[i] = EMPTY;\n            continue;\n        }\n        break;\n    }\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musiopae.h\n// Author:      Rodolfo Zitellini\n// Created:     2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_IOPAE_H__\n#define __MUS_IOPAE_H__\n\n#include <string>\n#include <vector>\n\n#include \"musio.h\"\n\nclass MusBeam;\nclass MusClef;\nclass MusLayer;\nclass MusMeasure;\nclass MusMensur;\nclass MusStaff;\nclass MusTie;\nclass MusTuplet;\n\n\nclass NoteObject {\npublic:\n    NoteObject(const NoteObject &old) { // for STL vector\n        //mnote = old.mnote;\n        //mrest = old.mrest;         \n        tie = old.tie;\n        acciaccatura = old.acciaccatura;\n        appoggiatura = old.appoggiatura;\n        appoggiatura_multiple = old.appoggiatura_multiple;\n        fermata = old.fermata;\n        trill = old.trill;\n        \n        octave = old.octave;\n        beam = old.beam;\n        pitch = old.pitch;\n        duration = old.duration;\n        accidental = old.accidental;\n        dots = old.dots;\n        rest = old.rest;\n        \n        clef = old.clef;\n\n        tuplet_notes = old.tuplet_notes;\n        tuplet_note = old.tuplet_note;\n    }\n    NoteObject(void) { clear(); };\n    void   clear(void) {\n        appoggiatura = 0;\n        acciaccatura = appoggiatura_multiple = fermata = trill = false;\n        tie = 0;\n        \n        octave = 4;\n        beam = 0;\n        pitch = 0;\n        duration = 0;\n        accidental = 0;\n        dots = 0;\n        rest = false;\n        \n        tuplet_notes = 0;\n        tuplet_note = 0;\n        \n        clef = NULL;\n    };\n    \n    NoteObject& operator=(const NoteObject& d){ // for STL vector\n        //mnote = d.mnote;\n        //mrest = d.mrest;         \n        tie = d.tie;\n        acciaccatura = d.acciaccatura;\n        appoggiatura = d.appoggiatura;\n        appoggiatura_multiple = d.appoggiatura_multiple;\n        fermata = d.fermata;\n        trill = d.trill;\n        \n        octave = d.octave;\n        beam = d.beam;\n        pitch = d.pitch;\n        duration = d.duration;\n        accidental = d.accidental;\n        dots = d.dots;\n        rest = d.rest;\n        \n        clef = d.clef;\n        \n        tuplet_notes = d.tuplet_notes;\n        tuplet_note = d.tuplet_note;\n        \n        return *this;\n    }\n    \n    //MusNote *mnote;\n    //MusRest *mrest; // this is not too nice\n\n    // tuplet stuff\n    int tuplet_notes; // quantity of notes in the tuplet\n    int tuplet_note; // indicates this note is the nth in the tuplet\n    \n    int    tie;\n    bool   acciaccatura;\n    int    appoggiatura;\n    bool   appoggiatura_multiple;\n    bool   fermata;\n    bool   trill;\n    \n    unsigned char octave;\n    unsigned char beam;\n    unsigned char pitch;\n    unsigned char duration;\n    unsigned char accidental;\n    unsigned int dots;\n    bool rest;\n    \n    MusClef *clef;\n};\n\n\nclass MeasureObject {\npublic:\n    \n    MeasureObject(const MeasureObject& d){ // for STL vector\n        clef = d.clef;\n        time = d.time;\n        notes = d.notes;\n        \n        key = d.key;\n        key_alteration = d.key_alteration;\n        \n        durations = d.durations;\n        dots = d.dots; \n        durations_offset = d.durations_offset;\n        barline = d.barline;\n        abbreviation_offset = d.abbreviation_offset;  \n        wholerest = d.wholerest;\n    } \n    MeasureObject(void) { clear(); };\n    \n    MeasureObject& operator=(const MeasureObject& d){ // for STL vector\n        clef = d.clef;\n        time = d.time;\n        notes = d.notes;\n        \n        key = d.key;\n        key_alteration = d.key_alteration;\n        \n        durations = d.durations;\n        dots = d.dots; \n        durations_offset = d.durations_offset;\n        barline = d.barline;\n        abbreviation_offset = d.abbreviation_offset;  \n        wholerest = d.wholerest;   \n        return *this;\n    } \n     \n    void   clear(void) {\n        durations.clear();\n        dots.clear();\n        notes.clear();\n        durations_offset = 0;\n        reset();\n    };\n    void   reset(void) {\n        clef = NULL;\n        time = NULL;\n        key.clear();\n        notes.clear();\n        barline = \"\";\n        wholerest = 0; \n        abbreviation_offset = -1;\n    };\n    MusClef *clef;\n    MusMensur *time;\n    std::vector<NoteObject> notes;\n\n    std::vector<int> key;\n    char key_alteration;\n    \n    std::vector<int> durations;\n    std::vector<int> dots; // use the same offset as durations, they are used in parallel\n    unsigned int durations_offset;\n    std::string barline;\n    int    abbreviation_offset;  \n    int    wholerest;   // number of whole rests to process\n};\n\n\n//////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n//----------------------------------------------------------------------------\n// MusPaeInput\n//----------------------------------------------------------------------------\n\n\nclass MusPaeInput: public MusFileInputStream\n{\npublic:\n    // constructors and destructors\n    MusPaeInput( MusDoc *doc, std::string filename );\n    virtual ~MusPaeInput();\n    \n    virtual bool ImportFile( );\n    virtual bool ImportString(std::string pae);\n    \nprivate:\n    // function declarations:\n    \n     void      convertPlainAndEasyToKern( std::istream &infile, std::ostream &outfile);\n     \n     // parsing functions\n     int       getKeyInfo          (const char* incipit, MeasureObject *measure, int index = 0);\n     int       getTimeInfo         (const char* incipit, MeasureObject *measure, int index = 0);\n     int       getClefInfo         (const char* incipit, MusClef *mus_clef, int index = 0 );\n     int       getBarline          (const char* incipit, std::string *output, int index = 0 );\n     int       getAccidental       (const char* incipit, unsigned char *accident, int index = 0);\n     int       getOctave           (const char* incipit, unsigned char *octave, int index = 0 );\n     int       getDurations        (const char* incipit, MeasureObject *measure, int index = 0);\n     int       getDuration         (const char* incipit, int *duration, int *dot, int index );\n     int       getTupletFermata    (const char* incipit, NoteObject *note, int index = 0);\n     int       getTupletFermataEnd (const char* incipit, NoteObject *note, int index = 0);\n     int       getGraceNote        (const char* incipit, NoteObject *note, int index = 0);\n     int       getWholeRest        (const char* incipit, int *wholerest, int index );\n     int       getAbbreviation     (const char* incipit, MeasureObject *measure, int index = 0 ); \n     int       getNote             (const char* incipit, NoteObject *note, MeasureObject *measure, int index = 0 );\n     \n     int       getPitch            (char c_note );\n     \n     // output functions\n     void      AddLayerElement     (MusLayerElement *element);\n     void      parseNote           (NoteObject note);\n     void      PopContainer        ();\n     void      printMeasure        (std::ostream& out, MeasureObject *measure);\n     void      PushContainer       (MusLayerElement *container);\n\n\n     // input functions\n     void      getAtRecordKeyValue (char *key, char* value, const char* input);\n     \n    \npublic:\n    \nprivate:\n    std::string m_filename;\n\tMusStaff *m_staff;\n    MusMeasure *m_measure;\n\tMusLayer *m_layer;\n    MusTie *m_current_tie;\n\n    std::vector<MusLayerElement *> m_nested_objects;   \n    \n    //unsigned char m_rest_position;\n    //unsigned int m_rest_octave;\n};\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<std::pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, std::pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, std::pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, std::pair<T1, T2> >::type&\n    get(std::pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, std::pair<T1, T2> >::type&\n    get(const std::pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, std::pair<T1, T2> >::type&&\n    get(std::pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(std::pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(std::pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(std::pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct ___make_pair_return\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct ___make_pair_return<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename ___make_pair_return<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","\n/////////////////////////////////////////////////////////////////////////////\n// Name:        muskeysig.cpp\n// Author:      Rodolfo Zitellini\n// Created:     10/07/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"muskeysig.h\"\n\n//----------------------------------------------------------------------------\n// MusKeySig\n//----------------------------------------------------------------------------\n\nunsigned char MusKeySig::flats[] = {PITCH_B, PITCH_E, PITCH_A, PITCH_D, PITCH_G, PITCH_C, PITCH_F};\nunsigned char MusKeySig::sharps[] = {PITCH_F, PITCH_C, PITCH_G, PITCH_D, PITCH_A, PITCH_E, PITCH_B};\n\nint MusKeySig::octave_map[2][9][7] = {\n    {// flats\n       //C,  D,  E,  F,  G,  A,  B \n        {01, 01, 01, 00, 00, 00, 00}, // treble\n        {00, 00, 00, 00, 00, 00, 00}, // soprano\n        {00, 00, 00, 00, 00, -1, -1}, // mezzo\n        {00, 00, 00, -1, -1, -1, -1}, // alto\n        {00, 00, 00, -1, -1, -1, -1}, // tenor\n        {-1, -1, -1, -1, -1, -2, -2}, // ??\n        {-1, -1, -1, -2, -2, -2, -2}, // bass\n        {-1, -1, -1, -1, -1, -1, -1}, // bariton\n        {01, 01, 01, 00, 00, 00, 00}, // french g\n    },\n    {// sharps\n       //C,  D,  E,  F,  G,  A,  B \n        {01, 01, 01, 01, 01, 00, 00}, // treble\n        {00, 00, 00, 00, 00, 00, 00}, // soprano\n        {00, 00, 00, 00, 00, 00, 00}, // mezzo\n        {00, 00, 00, 00, 00, -1, -1}, // alto\n        {00, 00, 00, -1, -1, -1, -1}, // tenor\n        {-1, -1, -1, -1, -1, -2, -2}, // ??\n        {-1, -1, -1, -1, -1, -2, -2}, // bass\n        {-1, -1, -1, -1, -1, -1, -1}, // bariton\n        {01, 01, 01, 01, 01, 00, 00}, // freench g\n    },\n};\n\nMusKeySig::MusKeySig():\nMusLayerElement(), MusPositionInterface()\n{\n    MusKeySig(0, ACCID_NATURAL);\n}\n\nMusKeySig::MusKeySig(int num_alter, char alter):\n    MusLayerElement(\"ksig-\"), MusPositionInterface()\n{\n    m_num_alter = num_alter;\n    m_alteration = alter;\n}\n\nMusKeySig::~MusKeySig()\n{\n}\n\nunsigned char MusKeySig::GetAlterationAt(int pos) {\n    unsigned char *alteration_set;\n    \n    if (pos > 6)\n        return 0;\n    \n    if (m_alteration == ACCID_FLAT)\n        alteration_set = flats;\n    else\n        alteration_set = sharps;\n    \n    return alteration_set[pos];\n}\n\nint MusKeySig::GetOctave(unsigned char pitch, char clef) {\n    int alter_set = 0; // flats\n    int key_set = 0;\n    \n    if (m_alteration == ACCID_SHARP)\n        alter_set = 1;\n    \n    switch (clef) {\n        case SOL2: key_set = 0; break;\n        case UT1: key_set = 1; break;\n        case UT2: key_set = 2; break;\n        case UT3: key_set = 3; break;\n        case UT4: key_set = 4; break;\n        case FA5: key_set = 5; break;\n        case FA4: key_set = 6; break;\n        case FA3: key_set = 7; break;\n        case SOL1: key_set = 8; break;\n            \n        default: key_set = 0; break;\n    }\n    \n    return octave_map[alter_set][key_set][pitch - 1];\n}","\n/////////////////////////////////////////////////////////////////////////////\n// Name:        muskeysig.h\n// Author:      Rodolfo Zitellini\n// Created:     10/07/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_KEYSIG_H__\n#define __MUS_KEYSIG_H__\n\n#include \"musdef.h\"\n#include \"muslayerelement.h\"\n#include \"muspositioninterface.h\"\n\n\n//----------------------------------------------------------------------------\n// MusKeysig\n//----------------------------------------------------------------------------\n\nclass MusKeySig: public MusLayerElement, public MusPositionInterface\n{\npublic:\n    // constructors and destructors\n    MusKeySig();\n    MusKeySig(int num_alter, char alter);\n    virtual ~MusKeySig();\n    \n    virtual std::string MusClassName( ) { return \"MusKeySig\"; };\n    \n    /**\n     * Return the default horizontal spacing after a keysig.\n     */\n    virtual int GetHorizontalSpacing( ) { return 20; };\n    \n    unsigned char GetAlterationAt(int pos);\n    int GetOctave(unsigned char pitch, char clef);\n    \nprivate:\n    \npublic:\n    int m_num_alter;\n    unsigned char m_alteration;\n    \nprivate:\n    static unsigned char flats[];\n    static unsigned char sharps[];\n    static int octave_map[2][9][7];\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muslayer.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"muslayer.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"musclef.h\"\n#include \"musdef.h\"\n#include \"musdoc.h\"\n#include \"muskeysig.h\"\n#include \"musio.h\"\n#include \"muslayerelement.h\"\n#include \"musnote.h\"\n#include \"mussymbol.h\"\n\n//----------------------------------------------------------------------------\n// MusLayer\n//----------------------------------------------------------------------------\n\nMusLayer::MusLayer( int n ):\n\tMusDocObject(\"layer-\"), MusObjectListInterface(), MusScoreOrStaffDefAttrInterface()\n{\n    assert( n > 0 );\n    m_n = n;\n    \n\tClear( );\n}\n\nMusLayer::~MusLayer()\n{\n    \n}\n\nvoid MusLayer::Clear()\n{\n    ClearChildren();\n\tvoix = 0;\n    m_drawingList.clear();\n}\n\n\nint MusLayer::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];       \n    if (!output->WriteLayer( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n\n}\n\n\nvoid MusLayer::AddElement( MusLayerElement *element, int idx )\n{\n\telement->SetParent( this );\n    if ( idx == -1 ) {\n        m_children.push_back( element );\n    }\n    else {\n        InsertChild( element, idx );\n    }\n    Modify();\n}\n\nvoid MusLayer::CopyAttributes( MusLayer *nlayer )\n{\n\tif ( !nlayer )\n\t\treturn;\n\n\tnlayer->Clear();\n\tnlayer->voix = voix;\n}\n\nMusLayerElement *MusLayer::GetFirst( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\treturn (MusLayerElement*)m_children[0];\n}\n\nMusLayerElement *MusLayer::GetLast( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\tint i = (int)m_children.size() - 1;\n\treturn (MusLayerElement*)m_children[i];\n}\n\nMusLayerElement *MusLayer::GetNext( MusLayerElement *element )\n{\t\n    this->ResetList( this );\n    \n    if ( !element || m_list.empty() )\n        return NULL;\n    \n    return (MusLayerElement*)GetListNext( element );\n}\n\nMusLayerElement *MusLayer::GetPrevious( MusLayerElement *element )\n{\n    this->ResetList( this );\n    \n    if ( !element || m_list.empty() )\n        return NULL;\n    \n    return (MusLayerElement*)GetListPrevious( element );\n}\n\nMusLayerElement *MusLayer::GetAtPos( int x )\n{\n\tMusLayerElement *element = this->GetFirst();\n\tif ( !element )\n\t\treturn NULL;\n\n    \n\tint dif = x - element->m_xDrawing;\n    MusLayerElement *next = NULL;\n\twhile ( (next = this->GetNext( element )) && (int)element->m_xDrawing < x ){\n\t\telement = next;\n\t\tif ( (int)element->m_xDrawing > x && dif < (int)element->m_xDrawing - x )\n\t\t\treturn this->GetPrevious( element );\n\t\tdif = x - element->m_xDrawing;\n\t}\n\t\n\treturn element;\n}\n\nvoid MusLayer::AddToDrawingList( MusLayerElement *element )\n{\n    m_drawingList.push_back( element );\n}\n\nListOfMusObjects *MusLayer::GetDrawingList( )\n{\n    return &m_drawingList;\n}\n\nvoid MusLayer::ResetDrawingList( )\n{\n    m_drawingList.clear();\n}\n\nMusLayerElement *MusLayer::Insert( MusLayerElement *element, int x )\n{\n\tif ( !element ) { \n        return NULL;\n    }\n    \n    // This is temporary and is OK because we have only one single layout for now.\n    // Inserting elements should be done from the logical tree and then update the layout\n    \n    MusLayerElement *insertElement = element->GetChildCopy();\n\n    // First we find the element after which we are inserting the element\n    // If not, it will be NULL\n    // We are also updating the section and measure ( TODO, not necessary for now )\n    int idx = 0;\n\tMusLayerElement *next = this->GetFirst();\n\twhile ( next && (next->m_xDrawing < x) )\n\t{\n        idx++;\n        // update section and measure if necessary (no section breaks and measure breaks for now)\n\t\tif ( this->GetNext( next ) )\n\t\t\tnext = this->GetNext( next );\n\t\telse\n\t\t\tbreak;\n\t}\n    \n    // Insert in the logical tree - this works only for facsimile (transcription) encoding\n    insertElement->m_xAbs = x;\n    AddElement( insertElement, idx );\n    \n\tRefresh();\n    //\n\treturn insertElement;\n}\n\n\nvoid MusLayer::Insert( MusLayerElement *layerElement, MusLayerElement *before )\n{\n    int idx = 0;\n    if ( before ) {\n        idx = this->GetChildIndex( before );\n    }\n    AddElement( layerElement , idx );\n}\n\nvoid MusLayer::SetDrawingValues( MusScoreDef *currentScoreDef, MusStaffDef *currentStaffDef )\n{\n    if (!currentStaffDef || !currentScoreDef) {\n        Mus::LogDebug(\"scoreDef and/or staffDef not found\");\n        return;\n    }\n    \n    if ( currentStaffDef->DrawClef() ) {\n        if ( currentStaffDef->GetClefAttr() ) {\n            this->ReplaceClef( currentStaffDef->GetClefAttr() );\n        }\n        else {\n            this->ReplaceClef( currentScoreDef->GetClefAttr() );\n        }\n        currentStaffDef->SetDrawClef( false );\n    }\n    if ( currentStaffDef->DrawKeySig() ) {\n        if ( currentStaffDef->GetKeySigAttr() ) {\n            this->ReplaceKeySig( currentStaffDef->GetKeySigAttr() );\n        }\n        else {\n            this->ReplaceKeySig( currentScoreDef->GetKeySigAttr() );\n        }\n        currentStaffDef->SetDrawKeySig( false );\n    }\n    if ( currentStaffDef->DrawMensur() ) {\n        if ( currentStaffDef->GetMensurAttr() ) {\n            this->ReplaceMensur( currentStaffDef->GetMensurAttr() );\n        }\n        else {\n            this->ReplaceMensur( currentScoreDef->GetMensurAttr() );\n        }\n        currentStaffDef->SetDrawMensur( false );\n    }\n    \n    // also put the current clef (if any if the staffDef or the scoreDef)\n    if ( currentStaffDef->GetClefAttr() ) {\n        this->m_currentClef = *currentStaffDef->GetClefAttr();\n    }\n    else if ( currentScoreDef->GetClefAttr() ) {\n        this->m_currentClef = *currentScoreDef->GetClefAttr();\n    }\n}\n\n\nvoid MusLayer::Delete( MusLayerElement *element )\n{\n\tif ( !element ) {\n        return;\n    }\n    \n    bool is_clef = false;\n        \n    if ( element->IsClef() ) {\n        is_clef = true;\n        //m_r->OnBeginEditionClef();\n    }\n\t\n    \n    int pos = GetChildIndex( element );\n    RemoveChildAt( pos );\n    Modify();\n\n\tif ( is_clef )\n\t{\n        //m_r->OnEndEditionClef();\n\t}\n    \n    Refresh();\n}\n\n// Dans la direction indiquee (direction), cavale sur tout element qui n'est pas un\n// symbol, de la nature indiquee (flg). Retourne le ptr si succes, ou \n// l'element de depart; le ptr succ est vrai si symb trouve.\n\nMusLayerElement *MusLayer::GetFirst( MusLayerElement *element, unsigned int direction, const std::type_info *elementType, bool *succ)\n{\t\n    MusLayerElement *original = element;\n\n\t*succ = false;\n\tif (element == NULL)\n\t\treturn (element);\n\n    ResetList(this);\n    \n\tint i = GetListIndex( element );\n\tif ( i == -1 )\n\t\treturn (element);\n\n    *succ = true; // we assume we will find it. Change to false if not\n    while ( typeid(*element) != *elementType )\n\t{\n\t\tif (direction==BACKWARD)\n\t\t{\t\n\t\t\tif (i < 1) {\n                *succ = false;\n                break;\n            }\n\t\t\ti--;\n            element = (MusLayerElement*)GetListPrevious(element);\n\t\t}\n\t\telse\n\t\t{\tif (i >= (int)GetList(this)->size() - 1 ) {\n                *succ = false;\n                break;\n            }\n\t\t\ti++;\n\t\t\telement = (MusLayerElement*)GetListNext(element);\n\t\t}\n\t}\t\n\n\treturn (*succ ? element : original);\n}\n\nvoid MusLayer::CheckXPosition( MusLayerElement *currentElement )\n{\n    if (!currentElement) {\n        return;\n    }\n    \n    MusLayerElement *previous = GetPrevious( currentElement );\n    MusLayerElement *next = GetNext( currentElement );\n    \n    if ( previous && previous->m_xAbs >= currentElement->m_xAbs ) {\n        currentElement->m_xAbs = previous->m_xAbs + 2;\n    }\n    if ( next && next->m_xAbs <= currentElement->m_xAbs ) {\n        currentElement->m_xAbs = next->m_xAbs - 2;\n    }\n}\n\nMusClef* MusLayer::GetClef( MusLayerElement *test )\n{\n\tbool succ=false;\n\n    if (!test) {\n        return NULL;\n    }\n\t\n    if ( !test->IsClef() )\n    {\t\n        test = GetFirst(test, BACKWARD, &typeid(MusClef), &succ);\n    }\n    if ( dynamic_cast<MusClef*>(test) ) {\n        return dynamic_cast<MusClef*>(test);\n    }\n\n    return &m_currentClef;\n}\n\nint MusLayer::GetClefOffset( MusLayerElement *test )\n{\n    MusClef *clef = GetClef(test);\n    if (!clef) {\n        return 0;\n    }\n    return clef->GetClefOffset();\n    \n}\n\nvoid MusLayer::RemoveClefAndCustos()\n{\n    MusClef *currentClef = NULL;\n    \n    int i;\n    int elementCount =  this->GetElementCount();\n    for (i = 0; i < elementCount; i++)\n    {\n        if ( ((MusLayerElement*)m_children[i])->IsClef() ) {\n            MusClef *clef = dynamic_cast<MusClef*>(m_children[i]);\n            // we remove the clef because it is the same as the previous one\n            if ( currentClef && ((*currentClef) == (*clef)) ) {\n                // check if it is a F clef with a Longa before\n                if ( (i > 0) && ((MusLayerElement*)m_children[i - 1])->IsNote() )\n                {\n                    MusNote *note = dynamic_cast<MusNote*>(m_children[i - 1]);\n                    if ( note && (note->m_dur == DUR_LG) )\n                    {\n                        bool removeLonga = false;\n                        // we check only for the pitch, not the octave, but should be enough\n                        if ( (clef->m_clefId == FA3) && ( note->m_pname == PITCH_G ) )\n                            removeLonga = true;\n                        else if ( (clef->m_clefId == FA4) && ( note->m_pname == PITCH_B ) )\n                            removeLonga = true;\n                        else if ( (clef->m_clefId == FA5) && ( note->m_pname == PITCH_D ) )\n                            removeLonga = true;\n                        if ( removeLonga ) {\n                            this->Delete( note );\n                            elementCount--;\n                            i--;\n                        }\n                    }\n                }\n                this->Delete( clef );\n                elementCount--;\n                // now remove alterations (keys)\n                for (; i < elementCount; i++) {\n                    MusSymbol *accid = dynamic_cast<MusSymbol*>(m_children[i]);\n                    if ( accid && accid->IsSymbol( SYMBOL_ACCID ) ) {\n                        this->Delete( accid );\n                        elementCount--;\n                        i--;                        \n                    }\n                    else\n                        break;\n                }\n                i--;\n                \n            }\n            else {\n                currentClef = clef;\n            }\n        }\n        else if ( ((MusLayerElement*)m_children[i])->IsSymbol( SYMBOL_CUSTOS ) ) {\n            MusSymbol *symbol = dynamic_cast<MusSymbol*>(m_children[i]);\n            this->Delete( symbol );\n            elementCount--;\n            i--;\n        }\n    }\n}\n\n/*\n// Gets the y coordinate of the previous lyric. If lyric is NULL, it will return the y coordinate of the first lyric \n// in the stave. If there are no lyrics in the Stave -1 is returned.\nint MusLayer::GetLyricPos( MusSymbol1 *lyric )\n{\n\tMusSymbol1 *tmp;\n\tif ( !lyric ){\n\t\tif ( !( tmp = GetFirstLyric() ) )\n\t\t\treturn -1;\n\t\treturn tmp->dec_y;\n\t}\n\t\n\tif ( !( tmp = GetPreviousLyric( lyric ) ) )\n\t\treturn -1;\n\treturn tmp->dec_y;\n}\n\nMusSymbol1 *MusLayer::GetPreviousLyric( MusSymbol1 *lyric )\n{\n\tif ( !lyric || m_children.IsEmpty() || !lyric->m_note_ptr || lyric->m_note_ptr->no < 0 )\n\t\treturn NULL;\n\t\n\t// If there are other lyrics attached to the note that lyric is attached to...\n\tif ( (int)lyric->m_note_ptr->m_lyrics.GetCount() > 1 ){\n\t\tbool check = false; // Keeps track if we have past the pointer to this element in m_lyrics\n\t\tfor ( int i = (int)lyric->m_note_ptr->m_lyrics.GetCount() - 1; i >= 0; i-- ){\n\t\t\tMusSymbol1 *previousLyric = &lyric->m_note_ptr->m_lyrics[i];\n\t\t\tif ( check ) return previousLyric;\n\t\t\tif ( previousLyric == lyric ) check = true;\n\t\t}\n\t}\n\t// Check previous note in staff for lyric\n\tint no = lyric->m_note_ptr->no - 1;\n\twhile ( no >= 0 ){\n\t\tif ( m_children[ no ].IsNote() ){\n\t\t\tfor ( int i = (int) ((MusNote1*)m_children[ no ])->m_lyrics.GetCount() - 1; i >= 0 ; i-- ){\n\t\t\t\tMusSymbol1 *previousLyric = ((MusNote1*)m_children[ no ])->m_lyrics[i];\n\t\t\t\tif ( previousLyric ) return previousLyric;\n\t\t\t}\n\t\t}\n\t\tno--;\n\t}\n\treturn NULL;\n}\n\nMusSymbol1 *MusLayer::GetNextLyric( MusSymbol1 *lyric )\n{\t\n\tif ( !lyric || m_children.IsEmpty() || !lyric->m_note_ptr || lyric->m_note_ptr->no > (int)m_children.GetCount() - 1 )\n\t\treturn NULL;\n\t\n\t// If there are other lyrics attached to the note that lyric is attached to...\n\tif ( (int)lyric->m_note_ptr->m_lyrics.GetCount() > 1 ){\n\t\tbool check = false; // Keeps track if we have past the pointer to this element in m_lyrics\n\t\tfor ( int i = 0; i < (int)lyric->m_note_ptr->m_lyrics.GetCount(); i++ ){\n\t\t\tMusSymbol1 *nextLyric = &lyric->m_note_ptr->m_lyrics[i];\n\t\t\tif ( check ) \n\t\t\t\treturn nextLyric;\n\t\t\tif ( nextLyric == lyric ) \n\t\t\t\tcheck = true;\n\t\t}\n\t}\n\t// Check next note in staff for lyric\n\tint no = lyric->m_note_ptr->no + 1;\n\twhile ( no < (int)m_children.GetCount() ){\n\t\tif ( m_children[ no ].IsNote() ){\n\t\t\tfor ( int i = 0; i < (int) ((MusNote1*)m_children[ no ])->m_lyrics.GetCount(); i++ ){\n\t\t\t\tMusSymbol1 *nextLyric = ((MusNote1*)m_children[ no ])->m_lyrics[i];\n\t\t\t\tif ( nextLyric )\n\t\t\t\t\treturn nextLyric;\n\t\t\t}\n\t\t}\n\t\tno++;\n\t}\n\treturn NULL;\n}\n\nMusSymbol1 *MusLayer::GetFirstLyric( )\n{\n\tif ( m_children.IsEmpty() )\n\t\treturn NULL;\n\tint no = 0;\n\twhile ( no < (int)m_children.GetCount() ){\n\t\tif ( m_children[ no ].IsNote() ){\n\t\t\tfor ( int i = 0; i < (int) ((MusNote1*)m_children[ no ])->m_lyrics.GetCount(); i++ ){\n\t\t\t\tMusSymbol1 *lyric = ((MusNote1*)m_children[ no ])->m_lyrics[i];\n\t\t\t\tif ( lyric )\n\t\t\t\t\treturn lyric;\n\t\t\t}\n\t\t}\n\t\tno++;\n\t}\n\treturn NULL;\t\n}\n\nMusSymbol1 *MusLayer::GetLastLyric( )\n{\n\tif ( m_children.IsEmpty() )\n\t\treturn NULL;\n\tint no = (int)m_children.GetCount() - 1;\n\twhile ( no >= 0 ){\n\t\tif ( m_children[ no ].IsNote() ) {\n\t\t\tfor ( int i = (int) ((MusNote1*)m_children[ no ])->m_lyrics.GetCount() - 1; i >= 0 ; i-- ){\n\t\t\t\tMusSymbol1 *lyric = ((MusNote1*)m_children[ no ])->m_lyrics[i];\n\t\t\t\tif ( lyric )\n\t\t\t\t\treturn lyric;\n\t\t\t}\n\t\t}\n\t\tno--;\n\t}\n\treturn NULL;\n}\n\nMusSymbol1 *MusLayer::GetLyricAtPos( int x )\n{\n\tMusSymbol1 *lyric = this->GetFirstLyric();\n\tif ( !lyric )\n\t\treturn NULL;\n\t\n\t//int xx = 0;\n\tint dif = x - lyric->m_xAbs;\n\twhile ( this->GetNextLyric( lyric ) && (int)lyric->m_xAbs < x ){\n\t\tlyric = this->GetNextLyric( lyric );\n\t\tif ( (int)lyric->m_xAbs > x && dif < (int)lyric->m_xAbs - x )\n\t\t\treturn this->GetPreviousLyric( lyric );\n\t\tdif = x - lyric->m_xAbs;\n\t}\n\t\t\n\treturn lyric;\n}\n\nvoid MusLayer::DeleteLyric( MusSymbol1 *symbol )\n{\n\tif ( !symbol ) return;\n\t\n\tMusNote1 *note = symbol->m_note_ptr;\n\tfor ( int i = 0; i < (int)note->m_lyrics.GetCount(); i++ ){\n\t\tMusSymbol1 *lyric = &note->m_lyrics[i];\n\t\tif ( symbol == lyric )\n\t\t\tnote->m_lyrics.Detach(i);\n\t}\n\t\n\tthis->Delete( symbol );\n}\n\nMusNote1 *MusLayer::GetNextNote( MusSymbol1 * lyric )\n{\n\tif ( !lyric || m_children.IsEmpty() || !lyric->m_note_ptr || lyric->m_note_ptr->no >= (int)m_children.GetCount() - 1 )\n\t\treturn NULL;\n\t\n\tint no = lyric->m_note_ptr->no + 1;\n\tfor ( int i = no; i < (int)m_children.GetCount(); i++ ){\n\t\tMusLayerElement *element = m_children[i];\n\t\tif ( element->IsNote() && ((MusNote1*)element)->sil == _NOT )\n\t\t\treturn (MusNote1*)element; \n\t}\n\treturn NULL;\n}\n\nMusNote1 *MusLayer::GetPreviousNote( MusSymbol1 * lyric )\n{\n\tif ( !lyric || m_children.IsEmpty() || !lyric->m_note_ptr || lyric->m_note_ptr->no <= 0 )\n\t\treturn NULL;\n\t\n\tint no = lyric->m_note_ptr->no - 1;\n\tfor ( int i = no; i >= 0; i-- ){\n\t\tMusLayerElement *element = m_children[i];\n\t\tif ( element->IsNote() && ((MusNote1*)element)->sil == _NOT )\n\t\t\treturn (MusNote1*)element; \n\t}\n\treturn NULL;\n}\n\n//Switches the note association of lyric from oldNote to newNote and modifies the two notes accordingly\n//bool beginning: indicates if we want to add the lyric to beginning or end of the lyric array in newNote \n//\t\ttrue = beginning of array\n//\t\tfalse = end of array\nvoid MusLayer::SwitchLyricNoteAssociation( MusSymbol1 *lyric, MusNote1 *oldNote, MusNote1* newNote, bool beginning )\n{\n\tif ( !lyric || !oldNote || !newNote )\n\t\treturn;\n\t\n\tlyric->m_note_ptr = newNote;\n\tif ( beginning )\n\t\tnewNote->m_lyrics.Insert( lyric, 0 );\n\telse\n\t\tnewNote->m_lyrics.Insert( lyric, newNote->m_lyrics.GetCount() );\n\t\n\tfor ( int i = 0; i < (int)oldNote->m_lyrics.GetCount(); i++ ){\n\t\tMusSymbol1 *element = &oldNote->m_lyrics[i];\n\t\tif ( element == lyric ){\n\t\t\toldNote->m_lyrics.Detach(i);\n\t\t\tbreak;\n\t\t}\t\t\t\n\t}\n}\n\nvoid MusLayer::AdjustLyricLineHeight( int delta ) \n{\n\tfor ( int i = 0; i < (int)m_children.GetCount(); i++ ){\n\t\tMusLayerElement *element = m_children[i];\n\t\tif ( element->IsNote() ){\n\t\t\tfor ( int j = 0; j < (int)((MusNote1*)element)->m_lyrics.GetCount(); j++ ){\n\t\t\t\tMusSymbol1 *lyric = &((MusNote1*)element)->m_lyrics[j];\n\t\t\t\tlyric->dec_y += delta;\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n\n//----------------------------------------------------------------------------\n// MusLayer functor methods\n//----------------------------------------------------------------------------\n\nint MusLayer::CopyToLayer( ArrayPtrVoid params )\n{  \n    // Things we might want to add: \n    // - checking that the parent is a staff to avoid copying MusApp\n    // - adding a parent nbLogStaff and a nbLogLayer parameter for copying a specific staff / layer\n    \n    \n    // param 0: the MusLayer we need to copy to\n\tMusLayer *destinationLayer = (MusLayer*)params[0]; \n    // param 1: the uuid of the start element (if any)\n    std::string *start = (std::string*)params[1];\n    // param 2: the uuid of the end element (if any)\n    std::string *end = (std::string*)params[2];\n    // param 3: we have a start element and have started\n    bool *has_started = (bool*)params[3];\n    // param 4: we have an end element and have ended\n    bool *has_ended = (bool*)params[4];\n    // param 5: we want a new uuid for the copied elements\n    bool *new_uuid = (bool*)params[5];\n    \n    if ( (*has_ended) ) {\n        return FUNCTOR_STOP;\n    }\n    \n    int i;\n    for ( i = 0; i < this->GetElementCount(); i++ ) \n    {\n        // check if we have a start uuid or if we already passed it\n        if ( !start->empty() && !(*has_started) ) {\n            if ( *start == m_children[i]->GetUuid() ) {\n                (*has_started) = true;\n            } \n            else {\n                continue;\n            }\n        }\n        \n        // copy and add it\n        MusLayerElement *copy = ((MusLayerElement*)m_children[i])->GetChildCopy( (*new_uuid) );\n        destinationLayer->AddElement( copy );\n        \n        // check if we have a end uuid and if we have reached it. \n        if ( !end->empty() ) {\n            if ( *end == m_children[i]->GetUuid() ) {\n                (*has_ended) = true;\n                return FUNCTOR_STOP;\n            }\n        }\n\n        \n    }\n    return FUNCTOR_CONTINUE;\n}\n\nint MusLayer::Align( ArrayPtrVoid params )\n{\n    // param 0: the measureAligner (unused)\n    // param 1: the time\n    // param 2: the systemAligner (unused)\n    // param 3: the staffNb (unused)\n    double *time = (double*)params[1];\n\n    // we are starting a new layer, reset the time;\n    (*time) = 0.0;\n    \n    if ( m_clef ) {\n        m_clef->Align( params );\n    }\n    if ( m_keySig ) {\n        m_keySig->Align( params );\n    }\n\n    return FUNCTOR_CONTINUE;\n}\n\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n    const char* __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n        : __type_name(__n) {}\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT {return __type_name;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n        {return __type_name < __arg.__type_name;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n        {return __type_name == __arg.__type_name;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muslayerelement.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"muslayerelement.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musaligner.h\"\n#include \"musapp.h\"\n#include \"musbarline.h\"\n#include \"musbeam.h\"\n#include \"musclef.h\"\n#include \"musdef.h\"\n#include \"musdoc.h\"\n#include \"muskeysig.h\"\n#include \"musio.h\"\n#include \"musmensur.h\"\n#include \"musmultirest.h\"\n#include \"musnote.h\"\n#include \"musrest.h\"\n#include \"mussymbol.h\"\n#include \"mustuplet.h\"\n\n/**\n * Define the maximum levels between a tuplet and its notes\n */\n#define MAX_TUPLET_DEPTH 3\n\n\n//----------------------------------------------------------------------------\n// MusLayerElement\n//----------------------------------------------------------------------------\n\nMusLayerElement::MusLayerElement():\n    MusDocObject(\"le-\")\n{\n    Init();\n}\n\nMusLayerElement::MusLayerElement(std::string classid):\n\tMusDocObject(classid)\n{\n    Init();\n}\n\n\nMusLayerElement::~MusLayerElement()\n{\n    \n}\n\nMusLayerElement& MusLayerElement::operator=( const MusLayerElement& element )\n{\n\tif ( this != &element ) // not self assignement\n\t{\n        // is this necessary?\n        m_cueSize = element.m_cueSize;\n        m_hOffset = element.m_hOffset;\n        m_staffShift = element.m_staffShift;\n        m_visible = element.m_visible;\n        // pointers have to be NULL\n        m_parent = NULL;\n        m_alignment = NULL;\n\t}\n\treturn *this;\n}\n\n\nMusLayerElement *MusLayerElement::GetChildCopy( bool newUuid ) \n{\n    \n    // Is there another way to do this in C++ ?\n    // Yes, change this to the MusObject::Clone method - however, newUuid will not be possible in this way\n    MusLayerElement *element = NULL;\n\n    if ( this->IsBarline() )\n        element = new MusBarline( *(MusBarline*)this );\n    else if (this->IsClef() )\n        element = new MusClef( *(MusClef*)this );\n    else if (this->IsMensur() )\n        element = new MusMensur( *(MusMensur*)this );\n    else if (this->IsNote() )\n        element = new MusNote( *(MusNote*)this );\n    else if (this->IsRest() )\n        element = new MusRest( *(MusRest*)this );\n    else if (this->IsSymbol() )\n        element = new MusSymbol( *(MusSymbol*)this );\n    else {\n        Mus::LogDebug( \"Missing %s\", this->MusClassName().c_str() );\n        assert( false ); // Copy of this type unimplemented\n        return NULL;\n    }\n        \n    element->m_parent = NULL;\n    \n    if ( !newUuid ) {\n        element->SetUuid( this->GetUuid() );\n    }\n    else {\n        element->ResetUuid( );\n    }\n    \n    return element;\n}\n\n\n\nint MusLayerElement::GetElementNo() const\n{\n    assert( m_parent ); // Layer cannot be NULL\n    \n    return m_parent->GetChildIndex( this );\n}\n\n\nint MusLayerElement::GetHorizontalSpacing()\n{\n    return 10; // arbitrary generic value\n}\n\nvoid MusLayerElement::SetPitchOrPosition(int pname, int oct) \n{\n    if ( this->HasPitchInterface() ){\n        MusPitchInterface *pitch = dynamic_cast<MusPitchInterface*>(this);\n        pitch->SetPitch( pname, oct );\n    }\n    else if ( this->HasPositionInterface() ) {\n        MusPositionInterface *position = dynamic_cast<MusPositionInterface*>(this);\n        position->SetPosition( pname, oct );\n    }\n}\n\nbool MusLayerElement::GetPitchOrPosition(int *pname, int *oct) \n{\n    if ( this->HasPitchInterface() ){\n        MusPitchInterface *pitch = dynamic_cast<MusPitchInterface*>(this);\n        return pitch->GetPitch( pname, oct );\n    }\n    else if ( this->HasPositionInterface() ) {\n        MusPositionInterface *position = dynamic_cast<MusPositionInterface*>(this);\n        return position->GetPosition( pname, oct );\n    }\n    return false;\n}\n\nvoid MusLayerElement::SetValue( int value, int flag )\n{\n    if ( this->HasDurationInterface() ){\n        MusDurationInterface *duration = dynamic_cast<MusDurationInterface*>(this);\n        duration->SetDuration( value );\n    }\n}\n\nvoid MusLayerElement::Init()\n{\n    m_cueSize = false;\n    m_hOffset = 0;\n    m_staffShift = 0;\n    m_visible = true;\n    \n    m_xAbs = AX_UNSET;\n    m_xDrawing = 0;\n    m_yDrawing = 0;\n    m_in_layer_app = false;\n    \n    m_alignment = NULL;\n}\n\n\nbool MusLayerElement::IsBarline() \n{  \n    return (dynamic_cast<MusBarline*>(this));\n}\n\nbool MusLayerElement::IsBeam() \n{  \n    return (dynamic_cast<MusBeam*>(this));\n}\n\nbool MusLayerElement::IsClef() \n{  \n    return (dynamic_cast<MusClef*>(this));\n}\n\n\nbool MusLayerElement::HasDurationInterface() \n{  \n    return (dynamic_cast<MusDurationInterface*>(this));\n}\n\nbool MusLayerElement::IsSymbol( SymbolType type ) \n{  \n    MusSymbol *symbol = dynamic_cast<MusSymbol*>(this);\n    return (symbol && (symbol->m_type == type));\n}\n\nbool MusLayerElement::IsSymbol( ) \n{  \n    return (dynamic_cast<MusSymbol*>(this));\n}\n\n\nbool MusLayerElement::IsKeySig()\n{\n    return (dynamic_cast<MusKeySig*>(this));\n}\n\nbool MusLayerElement::IsMultiRest() \n{  \n    return (dynamic_cast<MusMultiRest*>(this));\n}\n\nbool MusLayerElement::IsMensur() \n{  \n    return (dynamic_cast<MusMensur*>(this));\n}\n\nbool MusLayerElement::IsNeume() \n{  \n    return false; //return (typeid(*m_layerElement) == typeid(MusNeume)); \n}\n\nbool MusLayerElement::IsNeumeSymbol() \n{  \n    return false; //return (typeid(*m_layerElement) == typeid(MusNeume)); \n}\n\nbool MusLayerElement::IsNote() \n{  \n    return (dynamic_cast<MusNote*>(this));\n}\n\nbool MusLayerElement::HasPitchInterface() \n{  \n    return (dynamic_cast<MusPitchInterface*>(this));\n}\n\nbool MusLayerElement::HasPositionInterface() \n{  \n    return (dynamic_cast<MusPositionInterface*>(this));\n}\n\nbool MusLayerElement::IsRest() \n{  \n    return (dynamic_cast<MusRest*>(this));\n}\n\n\nint MusLayerElement::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];         \n    if (!output->WriteLayerElement( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n\n}\n\nvoid MusLayerElement::AdjustPname( int *pname, int *oct )\n{\n\tif ((*pname) < PITCH_C)\n\t{\n\t\tif ((*oct) > 0)\n\t\t\t(*oct)-- ;\n        (*pname) = PITCH_B;\n        \n\t}\n\telse if ((*pname) > PITCH_B)\n\t{\n\t\tif ((*oct) < 7)\n\t\t\t(*oct)++;\n        (*pname) = PITCH_C;\n\t}\n}\n\ndouble MusLayerElement::GetAlignementDuration()\n{\n    if ( HasDurationInterface() ) {\n        MusTuplet *tuplet = dynamic_cast<MusTuplet*>( this->GetFirstParent( &typeid(MusTuplet), MAX_TUPLET_DEPTH ) );\n        int num = 1;\n        int numbase = 1;\n        if ( tuplet ) {\n            num = tuplet->m_num;\n            numbase = tuplet->m_numbase;\n        }\n        MusDurationInterface *duration = dynamic_cast<MusDurationInterface*>(this);\n        return duration->GetAlignementDuration( num, numbase );\n    }\n    else {\n        return 0.0;\n    }\n}\n\nint MusLayerElement::GetXRel()\n{\n    if (m_alignment) {\n        return m_alignment->GetXRel();\n    }\n    return 0;\n}\n\nint MusLayerElement::Align( ArrayPtrVoid params )\n{\n    // param 0: the measureAligner\n    // param 1: the time\n    // param 2: the systemAligner (unused)\n    // param 3: the staffNb (unused)\n    MusMeasureAligner **measureAligner = (MusMeasureAligner**)params[0];\n    double *time = (double*)params[1];\n    \n    MusAlignmentType type = ALIGNMENT_DEFAULT;\n    if ( this->IsBarline() ) {\n        type = ALIGNMENT_BARLINE;\n    }\n    else if ( this->IsClef() ) {\n        type = ALIGNMENT_CLEF;\n    }\n    else if ( this->IsKeySig() ) {\n        type = ALIGNMENT_KEYSIG;\n    }\n    else if ( this->IsMensur() ) {\n        type = ALIGNMENT_MENSUR;\n    }\n    else if ( this->IsMultiRest() ) {\n        type = ALIGNMENT_MULTIREST;\n    }\n    \n    // get the duration of the event\n    double duration = this->GetAlignementDuration();\n    \n    (*measureAligner)->SetMaxTime( (*time) + duration );\n    \n    m_alignment = (*measureAligner)->GetAlignmentAtTime( *time, type );\n    \n    // increase the time position\n    (*time) += duration;\n\n    //Mus::LogDebug(\"Time %f\", (*time) );\n    \n    return FUNCTOR_CONTINUE;\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musmensur.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_MENSUR_H__\n#define __MUS_MENSUR_H__\n\n#include \"musdef.h\"\n#include \"muslayerelement.h\"\n\n//----------------------------------------------------------------------------\n// MusMensur\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <mensur> element. \n */\nclass MusMensur: public MusLayerElement\n{\npublic:\n    // constructors and destructors\n    MusMensur();\n    virtual ~MusMensur();\n    \n    /**\n     * Comparison operator. \n     * Check if the MusLayerElement if a MusMensur and compare attributes\n     */\n    virtual bool operator==(MusObject& other);\n    \n    virtual std::string MusClassName( ) { return \"MusMensur\"; };\n    \n    /**\n     * Set the value for the mensur.\n     */\n\tvirtual void SetValue( int value, int flag = 0 );\n    \nprivate:\n    \npublic:\n    /** Indicates the number of dots with the sign (max 1 for now). */\n    unsigned char m_dot;\n    /** Indicates the use of a meter symbol (C or C-cut) instead of a signature.\n     * This is not available in the MEI <mensur> element (only in <staffdef>).\n     * It was kept here because available in Wolfgang\n     */\n    MeterSymb m_meterSymb;\n    /** Indicates the numerator of the duration ratio. */\n    int m_num;\n    /** Indicates the denominator of the duration ratio. */\n    int m_numBase;\n    /** Indicates if the sign is reversed. */\n    bool m_reversed;\n    /** Indicates the sign of the mensuration signature. */\n    MensurSign m_sign;    \n    /** Indicates the number of slashes with the sign (max 1 for now). */\n    unsigned char m_slash;\n    \n    /** \n     * Static member for setting a value from a controller.\n     * Used for example in SetValue\n     */\n    static int s_num;\n    /** \n     * Static member for setting a value from a controller.\n     * Used for examle in SetValue.\n     */\n    static int s_numBase;\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musnote.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n#ifndef __MUS_NOTE_H__\n#define __MUS_NOTE_H__\n\n#include \"musbeam.h\"\n#include \"musdurationinterface.h\"\n#include \"muslayerelement.h\"\n#include \"muspitchinterface.h\"\n\n#define SLUR_INITIAL  (1<<1)\n#define SLUR_MEDIAL  (1<<2) \n#define SLUR_TERMINAL  (1<<3) \n\n#define LIG_INITIAL  (1<<1)\n#define LIG_MEDIAL  (1<<2) \n#define LIG_TERMINAL  (1<<3) \n\n#define CHORD_INITIAL  (1<<1)\n#define CHORD_MEDIAL  (1<<2) \n#define CHORD_TERMINAL  (1<<3) \n\n#define NOTE_MAX_SLURS 6\n\nclass MusTie;\n\n//----------------------------------------------------------------------------\n// MusNote\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <note> element. \n */\n\n\n// embellishments\n// for the moment only the trill is implemented\n#define EMB_NONE 0\n#define EMB_TRILL 1\n#define EMB_MORDENT 2\n\nclass MusNote: public MusLayerElement, public MusDurationInterface, public MusPitchInterface\n{\npublic:\n    // constructors and destructors\n    MusNote();\n    virtual ~MusNote();\n    \n    virtual std::string MusClassName( ) { return \"MusNote\"; };\n    \n     /** \n      * Set the duration.\n      * Because we need to perform additonal check, this method override the MusLayerElement::SetValue method.\n      * The MusDurationInterface::SetDuration method has to be called explicitly.\n      */\n    virtual void SetValue( int value, int flag = 0 );\n    \n    /**\n     * Comparison operator. \n     * Check if the MusLayerElement if a MusNote and compare attributes\n     */\n    virtual bool operator==(MusObject& other);\n    \n    /**\n     * Change the coloration.\n     */ \n\tvirtual void ChangeColoration( );\n    \n    /**\n     * Change the stem direction.\n     */\n\tvirtual void ChangeStem( );\n    \n    /**\n     * Set the note into a ligature.\n     */\n    virtual void SetLigature( );\n    \n    /**\n     * Return the default horizontal spacing of notes.\n     */\n    virtual int GetHorizontalSpacing( );\n    \n    /**\n     *\n     */\n    void SetTieAttrInitial( );\n    void SetTieAttrTerminal( MusNote *previousNote );\n    MusTie *GetTieAttrInitial( ) { return m_tieAttrInitial; };\n    MusTie *GetTieAttrTerminal( ) { return m_tieAttrTerminal; };\n    void ResetTieAttrInitial();\n    void ResetTieAttrTerminal() { m_tieAttrTerminal = NULL; };\n    \nprivate:\n    \nprotected:\n    \n    /**\n     * @name Tie attributes are represented by pointers to MusTie objects.\n     * There is one pointer for the initial attribute and one pointer for the end attribute.\n     * The MusTie objects points back to the notes as it is the case is a MEI tie element.\n     * With attributes, the note with the initial attribute own the MusTie object and take care of deleting it\n     */\n    ///@{\n    MusTie *m_tieAttrInitial;\n    MusTie *m_tieAttrTerminal;\n    ///@}\n    \npublic:\n    /** Indicates the articulation (0 == none) */\n    unsigned char m_artic;\n    /** Indicates if initial, medial or terminal part of a chord */\n    unsigned char m_chord;\n    /** Indicates if colored (inversed) */\n    bool m_colored;\n    /** Indicates if intial, medial or terminal part of a ligature */\n    unsigned char m_lig;\n    /** Indicates the headshape of the note */\n    unsigned char m_headshape;\n    /** Indicates if the ligature is obliqua (recta otherwise) */\n    bool m_ligObliqua;\n    /** Indicates if intial, medial or terminal part of a slur for up to 6 nesting/overlaping slur */\n    unsigned char m_slur[NOTE_MAX_SLURS];\n    /** Indicates the stem direction (0 == auto, -1 down, 1 up) */\n    char m_stemDir;\n    /** Indicates the stem length (0 == auto) */\n    unsigned char m_stemLen;\n    /** indicates if the appoggiatura is slashed (i.e. it is an acciaccatura)\n     used with cueSize = true */\n    bool m_acciaccatura;\n    /** embellishment on this note **/\n    unsigned int m_embellishment;\n    \nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrest.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_REST_H__\n#define __MUS_REST_H__\n\n#include \"musdurationinterface.h\"\n#include \"muslayerelement.h\"\n#include \"muspositioninterface.h\"\n\n//----------------------------------------------------------------------------\n// MusRest\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <rest> element. \n */\nclass MusRest: public MusLayerElement, public MusDurationInterface, public MusPositionInterface\n{\npublic:\n    // constructors and destructors\n    MusRest();\n    virtual ~MusRest();\n    \n    /**\n     * Comparison operator. \n     * Check if the MusLayerElement if a MusRest and compare attributes\n     */\n    virtual bool operator==(MusObject& other);\n    \n    virtual std::string MusClassName( ) { return \"MusRest\"; };\n    \nprivate:\n    \npublic:\n    /* Indicates the value to print above multi-measure rests */\n    int m_multimeasure_dur;\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mussymbol.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_SYMBOL_H__\n#define __MUS_SYMBOL_H__\n\n#include \"musdef.h\"\n#include \"muslayerelement.h\"\n#include \"muspositioninterface.h\"\n\n//----------------------------------------------------------------------------\n// MusSymbol\n//----------------------------------------------------------------------------\n\n/** \n * This class models various MEI that do not have their own class yet.\n * The element name is given by the m_type member.\n * The DOT type models the MEI <dot> element.\n * The ACCID type models the MEI <accid> element.\n */\nclass MusSymbol: public MusLayerElement, public MusPositionInterface\n{\npublic:\n    // constructors and destructors\n    MusSymbol();\n    MusSymbol( SymbolType type );\n    virtual ~MusSymbol();\n    \n    /**\n     * Comparison operator. \n     * Check if the MusLayerElement if a Symbol and compare attributes\n     */\n    virtual bool operator==(MusObject& other);\n    \n    virtual std::string MusClassName( ) { return \"MusSymbol\"; };\n    \n    /**\n     * Set the value for the symbol.\n     */\n\tvirtual void SetValue( int value, int flag = 0 );\n    \n    /** Set the position */\n    //virtual void SetPitchOrPosition( int pname, int oct ) { MusPositionInterface::SetPosition( pname, oct ); };\n    \n    /** Get the position */\n    //virtual bool GetPitchOrPosition( int *pname, int *oct ) { return MusPositionInterface::GetPosition( pname, oct ); };\n\n    \n    void Init( SymbolType type );\n    \nprivate:\n    \npublic:\n    /** Indicates the type of the symbole */\n    SymbolType m_type;\n    \n    /** For DOT, indicates the number of dots */\n    unsigned char m_dot;\n    \n    /** For ACCID, indicates the accidental */\n    unsigned char m_accid;\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muspositioninterface.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_POSITION_INTERFACE_H__\n#define __MUS_POSITION_INTERFACE_H__\n\n//----------------------------------------------------------------------------\n// MusPositionInterface\n//----------------------------------------------------------------------------\n\n/** \n * This class is an interface for elements with a position on the staff, such as rests.\n * It is not an abstract class but should not be instanciate directly.\n * For now, the position is handled in a similar way that for MusPitchInterface, that is with a pitch and octave. \n */\nclass MusPositionInterface\n{\npublic:\n    // constructors and destructors\n    MusPositionInterface();\n    virtual ~MusPositionInterface();\n    \n    /** Set the position */\n    virtual void SetPosition( int pname, int oct );\n    \n    /** Get the position */\n    virtual bool GetPosition( int *pname, int *oct );\n    \n    /**\n     * Inteface comparison operator. \n     * Check if the MusLayerElement has a MusPositionInterface and compare attributes\n     */\n    bool HasIdenticalPositionInterface(MusPositionInterface  *otherPitchInterface);\n\n    \nprivate:\n    \npublic:\n    /** Indicates the octave information */\n    char m_oct;\n    /** Indicates the pitch name */\n    unsigned char m_pname;\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musdurationinterface.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_DURATION_INTERFACE_H__\n#define __MUS_DURATION_INTERFACE_H__\n\n#define TUPLET_INITIAL  (1<<1)\n#define TUPLET_MEDIAL  (1<<2) \n#define TUPLET_TERMINAL  (1<<3)\n\n#define DURATION_MAX_TUPLETS 6\n\nclass MusObject;\n\n//----------------------------------------------------------------------------\n// MusDurationInterface\n//----------------------------------------------------------------------------\n\n/** \n * This class is an interface for elements with duration, such as notes and rests.\n * It is not an abstract class but should not be instanciate directly.\n */\nclass MusDurationInterface\n{\npublic:\n    // constructors and destructors\n    MusDurationInterface();\n    virtual ~MusDurationInterface();\n    \n    virtual void SetDuration( int value );\n    \n    \n    virtual double GetAlignementDuration( int num, int numbase );\n    \n    /**\n     * Look if the note or rest is in a beam.\n     * Look for the fist beam parent and check is the note is in is content list.\n     * Looking in the content list is necessary for grace notes or imbricated beams.\n     */\n    bool IsInBeam( MusObject *noteOrRest );\n    \n    /**\n     * Return true if the note or rest is the first of a beam.\n     */\n    bool IsFirstInBeam( MusObject *noteOrRest );\n    \n    /**\n     * Return true if the note or rest is the last of a beam.\n     */\n    bool IsLastInBeam( MusObject *noteOrRest );\n    \n    \n    /**\n     * Inteface comparison operator. \n     * Check if the MusLayerElement has a MusDurationInterface and compare attributes\n     */\n    bool HasIdenticalDurationInterface(MusDurationInterface  *otherDurationInterface);\n    \nprivate:\n    \npublic:\n    /** Indicates a break in the beaming */\n    unsigned char m_breakSec;\n    /** Indicates the number of augmentation dots */\n    unsigned char m_dots;\n    /** Indicates the duration */\n    int m_dur;\n    /** Indicates the numerator of the duration ratio */\n    int m_num;\n    /** Indicates the denominator of the duration ratio */\n    int m_numBase;\n    /** Indicates if intial, medial or termial part of a tuplet for up to 6 nesting/overlaping tuplets */\n    unsigned char m_tuplet[DURATION_MAX_TUPLETS];\n    /** Indicates if a fermata should be drawn on this note/rest */\n    bool m_fermata;\n    \n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muspitchinterface.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_PITCH_INTERFACE_H__\n#define __MUS_PITCH_INTERFACE_H__\n\n//----------------------------------------------------------------------------\n// MusPitchInterface\n//----------------------------------------------------------------------------\n\n/** \n * This class is an interface for elements with pitch, such as notes and neumes.\n * It is not an abstract class but should not be instanciate directly.\n */\nclass MusPitchInterface\n{\npublic:\n    // constructors and destructors\n    MusPitchInterface();\n    virtual ~MusPitchInterface();\n \n    /** Set the pitch */\n    virtual void SetPitch( int pname, int oct );\n    \n    /** Get the pitch */\n    virtual bool GetPitch( int *pname, int *oct );\n    \n    /**\n     * Interface comparison operator. \n     * Check if the MusLayerElement has a MusPitchInterface and compare attributes\n     */\n    bool HasIdenticalPitchInterface(MusPitchInterface  *otherPitchInterface);\n\n    \nprivate:\n    \npublic:\n    /** Indicates the accidental */\n    unsigned char m_accid;\n    /** Provides the octave information */\n    char m_oct;\n    /** Indicates the pitch name */\n    unsigned char m_pname;\n\nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musleipzigbbox.cpp\n// Author:      Rodolfo Zitellini\n// Created:     30/07/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musleipzigbbox.h\"\n\n//----------------------------------------------------------------------------\n\n#include \"musdef.h\"\n\nbool MusLeipzigBBox::m_initialized =  false;\n/*\nMusLeipzigBBox::BoundingBox* MusLeipzigBBox::m_bBox = MusLeipzigBBox::InitializeStatic();\n*/\n\n\nMusLeipzigBBox::BoundingBox MusLeipzigBBox::m_bBox[LEIPZIG_GLYPHS];\n\n// Statically initialize the struct\nvoid MusLeipzigBBox::InitializeStatic() {\n        \n    /*\n     * This list is used for getting the bounding box of the Leipzig glyphs.\n     * The values were obtained with ./varia/svg/split.xsl and boundingbox.svg.\n     * It should not be modified by hand.\n     */\n    m_bBox[LEIPZIG_BBOX_ORN_MORDENT].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_ORN_MORDENT].m_y = -2.0;\n    m_bBox[LEIPZIG_BBOX_ORN_MORDENT].m_width = 605.0;\n    m_bBox[LEIPZIG_BBOX_ORN_MORDENT].m_height = 242.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_0].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_0].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_0].m_width = 427.7;\n    m_bBox[LEIPZIG_BBOX_FIGURE_0].m_height = 516.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_1].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_1].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_1].m_width = 296.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_1].m_height = 496.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_2].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_2].m_y = -15.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_2].m_width = 402.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_2].m_height = 513.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_3].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_3].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_3].m_width = 383.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_3].m_height = 515.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_4].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_4].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_4].m_width = 387.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_4].m_height = 494.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_5].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_5].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_5].m_width = 357.7;\n    m_bBox[LEIPZIG_BBOX_FIGURE_5].m_height = 494.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_6].m_x = -1.3;\n    m_bBox[LEIPZIG_BBOX_FIGURE_6].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_6].m_width = 395.3;\n    m_bBox[LEIPZIG_BBOX_FIGURE_6].m_height = 516.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_7].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_7].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_7].m_width = 404.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_7].m_height = 511.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_8].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_8].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_8].m_width = 386.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_8].m_height = 515.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_9].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_9].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_9].m_width = 397.0;\n    m_bBox[LEIPZIG_BBOX_FIGURE_9].m_height = 513.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_UP].m_x = -376.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_UP].m_y = -57.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_UP].m_width = 753.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_UP].m_height = 405.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_DOWN].m_x = -376.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_DOWN].m_y = -348.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_DOWN].m_width = 753.0;\n    m_bBox[LEIPZIG_BBOX_FERMATA_DOWN].m_height = 405.0;\n    m_bBox[LEIPZIG_BBOX_ORN_TRILL].m_x = -216.0;\n    m_bBox[LEIPZIG_BBOX_ORN_TRILL].m_y = -161.0;\n    m_bBox[LEIPZIG_BBOX_ORN_TRILL].m_width = 432.0;\n    m_bBox[LEIPZIG_BBOX_ORN_TRILL].m_height = 364.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_2_CUT].m_x = -2.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_2_CUT].m_y = -69.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_2_CUT].m_width = 360.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_2_CUT].m_height = 633.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_CUT].m_x = 1.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_CUT].m_y = -69.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_CUT].m_width = 425.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_CUT].m_height = 649.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE].m_y = -133.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE].m_width = 405.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE].m_height = 266.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILL].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILL].m_y = -133.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILL].m_width = 405.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILL].m_height = 266.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF].m_x = -15.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF].m_y = -135.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF].m_width = 314.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF].m_height = 270.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER].m_x = -15.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER].m_y = -135.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER].m_width = 314.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER].m_height = 270.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP].m_y = -597.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP].m_width = 276.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP].m_height = 577.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN].m_x = 164.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN].m_y = 20.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN].m_width = 276.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN].m_height = 577.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G].m_y = -655.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G].m_width = 679.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G].m_height = 1809.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_F].m_x = 4.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_F].m_y = -566.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_F].m_width = 694.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_F].m_height = 832.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C].m_y = -536.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C].m_width = 659.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C].m_height = 1082.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G8].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G8].m_y = -844.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G8].m_width = 679.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G8].m_height = 1998.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP].m_y = -364.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP].m_width = 197.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP].m_height = 746.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL].m_x = 20.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL].m_y = -377.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL].m_width = 157.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL].m_height = 754.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT].m_x = 22.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT].m_y = -184.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT].m_width = 198.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT].m_height = 678.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP].m_x = -20.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP].m_y = -114.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP].m_width = 271.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP].m_height = 228.0;\n    m_bBox[LEIPZIG_BBOX_REST_4].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_4].m_y = -146.0;\n    m_bBox[LEIPZIG_BBOX_REST_4].m_width = 324.0;\n    m_bBox[LEIPZIG_BBOX_REST_4].m_height = 808.0;\n    m_bBox[LEIPZIG_BBOX_REST_8].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_8].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_8].m_width = 290.0;\n    m_bBox[LEIPZIG_BBOX_REST_8].m_height = 455.0;\n    m_bBox[LEIPZIG_BBOX_REST_16].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_16].m_y = -249.0;\n    m_bBox[LEIPZIG_BBOX_REST_16].m_width = 341.0;\n    m_bBox[LEIPZIG_BBOX_REST_16].m_height = 702.0;\n    m_bBox[LEIPZIG_BBOX_REST_32].m_x = 1.0;\n    m_bBox[LEIPZIG_BBOX_REST_32].m_y = -248.0;\n    m_bBox[LEIPZIG_BBOX_REST_32].m_width = 419.0;\n    m_bBox[LEIPZIG_BBOX_REST_32].m_height = 946.0;\n    m_bBox[LEIPZIG_BBOX_REST_64].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_64].m_y = -248.0;\n    m_bBox[LEIPZIG_BBOX_REST_64].m_width = 503.0;\n    m_bBox[LEIPZIG_BBOX_REST_64].m_height = 1191.0;\n    m_bBox[LEIPZIG_BBOX_REST_128].m_x = -1.0;\n    m_bBox[LEIPZIG_BBOX_REST_128].m_y = -510.0;\n    m_bBox[LEIPZIG_BBOX_REST_128].m_width = 602.0;\n    m_bBox[LEIPZIG_BBOX_REST_128].m_height = 1485.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_DIAMOND].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_DIAMOND].m_y = -211.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_DIAMOND].m_width = 359.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_DIAMOND].m_height = 445.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILLDIAMOND].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILLDIAMOND].m_y = -211.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILLDIAMOND].m_width = 359.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_WHOLE_FILLDIAMOND].m_height = 445.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF_DIAMOND].m_x = -34.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF_DIAMOND].m_y = -211.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF_DIAMOND].m_width = 358.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_HALF_DIAMOND].m_height = 445.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER_FILLDIAMOND].m_x = -34.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER_FILLDIAMOND].m_y = -211.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER_FILLDIAMOND].m_width = 358.0;\n    m_bBox[LEIPZIG_BBOX_HEAD_QUARTER_FILLDIAMOND].m_height = 445.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP_MENSURAL].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP_MENSURAL].m_y = -237.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP_MENSURAL].m_width = 162.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_UP_MENSURAL].m_height = 237.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN_MENSURAL].m_x = 2.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN_MENSURAL].m_y = 6.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN_MENSURAL].m_width = 162.0;\n    m_bBox[LEIPZIG_BBOX_SLASH_DOWN_MENSURAL].m_height = 237.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_MENSURAL].m_x = 145.3;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_MENSURAL].m_y = -180.7;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_MENSURAL].m_width = 461.7;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_MENSURAL].m_height = 936.3;\n    m_bBox[LEIPZIG_BBOX_CLEF_F_MENSURAL].m_x = 109.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_F_MENSURAL].m_y = -753.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_F_MENSURAL].m_width = 286.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_F_MENSURAL].m_height = 1108.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C_MENSURAL].m_x = 154.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C_MENSURAL].m_y = -602.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C_MENSURAL].m_width = 349.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_C_MENSURAL].m_height = 1197.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_CHIAVETTE].m_x = 13.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_CHIAVETTE].m_y = -273.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_CHIAVETTE].m_width = 619.0;\n    m_bBox[LEIPZIG_BBOX_CLEF_G_CHIAVETTE].m_height = 1031.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP_MENSURAL].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP_MENSURAL].m_y = -130.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP_MENSURAL].m_width = 240.0;\n    m_bBox[LEIPZIG_BBOX_ALT_SHARP_MENSURAL].m_height = 260.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL_MENSURAL].m_x = 30.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL_MENSURAL].m_y = -334.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL_MENSURAL].m_width = 134.0;\n    m_bBox[LEIPZIG_BBOX_ALT_NATURAL_MENSURAL].m_height = 713.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT_MENSURAL].m_x = 30.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT_MENSURAL].m_y = -112.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT_MENSURAL].m_width = 177.0;\n    m_bBox[LEIPZIG_BBOX_ALT_FLAT_MENSURAL].m_height = 641.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP_MENSURAL].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP_MENSURAL].m_y = -114.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP_MENSURAL].m_width = 271.0;\n    m_bBox[LEIPZIG_BBOX_ALT_DOUBLE_SHARP_MENSURAL].m_height = 228.0;\n    m_bBox[LEIPZIG_BBOX_REST_4_MENSURAL].m_x = 80.0;\n    m_bBox[LEIPZIG_BBOX_REST_4_MENSURAL].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_4_MENSURAL].m_width = 170.0;\n    m_bBox[LEIPZIG_BBOX_REST_4_MENSURAL].m_height = 170.0;\n    m_bBox[LEIPZIG_BBOX_REST_8_MENSURAL].m_x = 80.0;\n    m_bBox[LEIPZIG_BBOX_REST_8_MENSURAL].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_8_MENSURAL].m_width = 170.0;\n    m_bBox[LEIPZIG_BBOX_REST_8_MENSURAL].m_height = 170.0;\n    m_bBox[LEIPZIG_BBOX_REST_16_MENSURAL].m_x = 80.0;\n    m_bBox[LEIPZIG_BBOX_REST_16_MENSURAL].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_16_MENSURAL].m_width = 162.0;\n    m_bBox[LEIPZIG_BBOX_REST_16_MENSURAL].m_height = 262.0;\n    m_bBox[LEIPZIG_BBOX_REST_32_MENSURAL].m_x = 80.0;\n    m_bBox[LEIPZIG_BBOX_REST_32_MENSURAL].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_32_MENSURAL].m_width = 162.0;\n    m_bBox[LEIPZIG_BBOX_REST_32_MENSURAL].m_height = 362.0;\n    m_bBox[LEIPZIG_BBOX_REST_64_MENSURAL].m_x = 80.0;\n    m_bBox[LEIPZIG_BBOX_REST_64_MENSURAL].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_64_MENSURAL].m_width = 162.0;\n    m_bBox[LEIPZIG_BBOX_REST_64_MENSURAL].m_height = 461.0;\n    m_bBox[LEIPZIG_BBOX_REST_128_MENSURAL].m_x = 80.0;\n    m_bBox[LEIPZIG_BBOX_REST_128_MENSURAL].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_REST_128_MENSURAL].m_width = 162.0;\n    m_bBox[LEIPZIG_BBOX_REST_128_MENSURAL].m_height = 558.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_3_CUT].m_x = 1.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_3_CUT].m_y = -61.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_3_CUT].m_width = 336.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_3_CUT].m_height = 634.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_COMMON].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_COMMON].m_y = 0.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_COMMON].m_width = 427.0;\n    m_bBox[LEIPZIG_BBOX_METER_SYMB_COMMON].m_height = 516.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_8].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_8].m_y = -171.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_8].m_width = 274.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_8].m_height = 326.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_1].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_1].m_y = -156.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_1].m_width = 207.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_1].m_height = 311.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_6].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_6].m_y = -171.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_6].m_width = 214.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_6].m_height = 326.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_0].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_0].m_y = -171.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_0].m_width = 243.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_0].m_height = 326.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_2].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_2].m_y = -171.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_2].m_width = 260.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_2].m_height = 326.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_4].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_4].m_y = -156.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_4].m_width = 259.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_4].m_height = 311.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_5].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_5].m_y = -171.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_5].m_width = 240.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_5].m_height = 326.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_3].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_3].m_y = -171.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_3].m_width = 255.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_3].m_height = 326.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_7].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_7].m_y = -156.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_7].m_width = 243.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_7].m_height = 311.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_9].m_x = 0.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_9].m_y = -172.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_9].m_width = 225.0;\n    m_bBox[LEIPZIG_BBOX_OBLIQUE_FIGURE_9].m_height = 327.0;\n    /* end of the generated data */\n    \n    m_initialized = true;\n    \n    return;\n};\n\nvoid MusLeipzigBBox::GetCharBounds(const unsigned char c, int *x, int *y, int *w, int *h)\n{\n    unsigned int glyph;\n    \n    if(!m_initialized)\n        InitializeStatic();\n    \n    switch (c) {\n            /* figures */\n        case 48: glyph = LEIPZIG_BBOX_FIGURE_0; break;\n        case 49: glyph = LEIPZIG_BBOX_FIGURE_1; break;\n        case 50: glyph = LEIPZIG_BBOX_FIGURE_2; break;\n        case 51: glyph = LEIPZIG_BBOX_FIGURE_3; break;\n        case 52: glyph = LEIPZIG_BBOX_FIGURE_4; break;\n        case 53: glyph = LEIPZIG_BBOX_FIGURE_5; break;\n        case 54: glyph = LEIPZIG_BBOX_FIGURE_6; break;\n        case 55: glyph = LEIPZIG_BBOX_FIGURE_7; break;\n        case 56: glyph = LEIPZIG_BBOX_FIGURE_8; break;\n        case 57: glyph = LEIPZIG_BBOX_FIGURE_9; break;\n            /* oblique figures */\n        case 0x82: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_0; break;\n        case 0x83: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_1; break;\n        case 0x84: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_2; break;\n        case 0x85: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_3; break;\n        case 0x86: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_4; break;\n        case 0x87: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_5; break;\n        case 0x88: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_6; break;\n        case 0x89: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_7; break;\n        case 0x8A: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_8; break;\n        case 0x8B: glyph = LEIPZIG_BBOX_OBLIQUE_FIGURE_9; break;\n            /* fermata */\n        case 0x3F: glyph = LEIPZIG_BBOX_FERMATA_UP; break;\n        case 0x40: glyph = LEIPZIG_BBOX_FERMATA_DOWN; break;        \n            /* clef */\n        case LEIPZIG_CLEF_G: glyph = LEIPZIG_BBOX_CLEF_G; break;\n        case LEIPZIG_CLEF_F: glyph = LEIPZIG_BBOX_CLEF_F; break;\n        case LEIPZIG_CLEF_C: glyph = LEIPZIG_BBOX_CLEF_C; break;\n        case LEIPZIG_CLEF_8va: glyph = LEIPZIG_BBOX_CLEF_G8; break;\n        case LEIPZIG_CLEF_G + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_CLEF_G_MENSURAL; break;\n        case LEIPZIG_CLEF_F + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_CLEF_F_MENSURAL; break;\n        case LEIPZIG_CLEF_C + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_CLEF_C_MENSURAL; break;\n        case LEIPZIG_CLEF_8va + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_CLEF_G_MENSURAL; break; // ??\n            /* meter */\n        case LEIPZIG_METER_SYMB_2_CUT: glyph = LEIPZIG_BBOX_METER_SYMB_2_CUT; break;\n        case LEIPZIG_METER_SYMB_3_CUT: glyph = LEIPZIG_BBOX_METER_SYMB_3_CUT; break;\n        case LEIPZIG_METER_SYMB_CUT: glyph = LEIPZIG_BBOX_METER_SYMB_CUT; break;\n        case LEIPZIG_METER_SYMB_COMMON: glyph = LEIPZIG_BBOX_METER_SYMB_COMMON; break;        \n            /* alterations */\n        case LEIPZIG_ACCID_SHARP: glyph = LEIPZIG_BBOX_ALT_SHARP; break;\n        case LEIPZIG_ACCID_NATURAL: glyph = LEIPZIG_BBOX_ALT_NATURAL; break;\n        case LEIPZIG_ACCID_FLAT: glyph = LEIPZIG_BBOX_ALT_FLAT; break;\n        case LEIPZIG_ACCID_DOUBLE_SHARP: glyph = LEIPZIG_BBOX_ALT_DOUBLE_SHARP; break;\n        case LEIPZIG_ACCID_SHARP + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_ALT_SHARP_MENSURAL; break;\n        case LEIPZIG_ACCID_NATURAL + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_ALT_NATURAL_MENSURAL; break;\n        case LEIPZIG_ACCID_FLAT + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_ALT_FLAT_MENSURAL; break;\n        case LEIPZIG_ACCID_DOUBLE_SHARP + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_ALT_DOUBLE_SHARP_MENSURAL; break;\n            /* rests */\n        case LEIPZIG_REST_QUARTER: glyph = LEIPZIG_BBOX_REST_4; break;\n        case LEIPZIG_REST_QUARTER + 1: glyph = LEIPZIG_BBOX_REST_8; break;\n        case LEIPZIG_REST_QUARTER + 2: glyph = LEIPZIG_BBOX_REST_16; break;\n        case LEIPZIG_REST_QUARTER + 3: glyph = LEIPZIG_BBOX_REST_32; break;\n        case LEIPZIG_REST_QUARTER + 4: glyph = LEIPZIG_BBOX_REST_64; break;\n        case LEIPZIG_REST_QUARTER + 5: glyph = LEIPZIG_BBOX_REST_128; break;\n        case LEIPZIG_REST_QUARTER + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_REST_4_MENSURAL; break;\n        case LEIPZIG_REST_QUARTER + 1 + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_REST_8_MENSURAL; break;\n        case LEIPZIG_REST_QUARTER + 2 + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_REST_16_MENSURAL; break;\n        case LEIPZIG_REST_QUARTER + 3 + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_REST_32_MENSURAL; break;\n        case LEIPZIG_REST_QUARTER + 4 + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_REST_64_MENSURAL; break;\n        case LEIPZIG_REST_QUARTER + 5 + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_REST_128_MENSURAL; break;\n            /* note heads */\n        case LEIPZIG_HEAD_WHOLE: glyph = LEIPZIG_BBOX_HEAD_WHOLE; break;\n        case LEIPZIG_HEAD_WHOLE_FILLED: glyph = LEIPZIG_BBOX_HEAD_WHOLE_FILL; break;\n        case LEIPZIG_HEAD_HALF: glyph = LEIPZIG_BBOX_HEAD_HALF; break;\n        case LEIPZIG_HEAD_QUARTER: glyph = LEIPZIG_BBOX_HEAD_QUARTER; break;\n        case LEIPZIG_HEAD_WHOLE + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_HEAD_WHOLE_DIAMOND; break;\n        case LEIPZIG_HEAD_WHOLE_FILLED + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_HEAD_WHOLE_FILLDIAMOND; break;\n        case LEIPZIG_HEAD_HALF + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_HEAD_HALF_DIAMOND; break;\n        case LEIPZIG_HEAD_QUARTER + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_HEAD_QUARTER_FILLDIAMOND; break;\n            /* slashes */\n        case LEIPZIG_STEM_FLAG_UP: glyph = LEIPZIG_BBOX_SLASH_UP; break;\n        case LEIPZIG_STEM_FLAG_DOWN: glyph = LEIPZIG_BBOX_SLASH_DOWN; break;\n        case LEIPZIG_STEM_FLAG_UP + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_SLASH_UP_MENSURAL; break;\n        case LEIPZIG_STEM_FLAG_DOWN + LEIPZIG_OFFSET_MENSURAL: glyph = LEIPZIG_BBOX_SLASH_DOWN_MENSURAL; break;\n            /* ornaments */\n        case 35: glyph = LEIPZIG_BBOX_ORN_MORDENT; break;\n        case LEIPZIG_EMB_TRILL: glyph = LEIPZIG_BBOX_ORN_TRILL; break;\n            /* todo */\n        default: glyph = LEIPZIG_BBOX_ALT_DOUBLE_SHARP; // ??\n    }\n    \n    *w = m_bBox[glyph].m_width;\n    *h = m_bBox[glyph].m_height;\n    *x = m_bBox[glyph].m_x;\n    *y = m_bBox[glyph].m_y;\n     \n    \n    //bBox = 0;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musmensur.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musmensur.h\"\n\nint MusMensur::s_num = 3;\nint MusMensur::s_numBase = 2;\n\n//----------------------------------------------------------------------------\n// MusMensur\n//----------------------------------------------------------------------------\n\nMusMensur::MusMensur():\n\tMusLayerElement(\"mensur-\")\n{\n    m_dot = 0;\n    m_meterSymb = METER_SYMB_NONE;\n    m_num = 0;\n    m_numBase = 0;\n    m_reversed = false;\n    m_sign = MENSUR_SIGN_NONE;\n    m_slash = 0;\n}\n\n\nMusMensur::~MusMensur()\n{\n}\n\nbool MusMensur::operator==( MusObject& other )\n{\n    MusMensur *otherMensur = dynamic_cast<MusMensur*>( &other );\n    if ( !otherMensur ) {\n        return false;\n    }\n    if ( this->m_dot != otherMensur->m_dot ) {\n        return false;\n    }\n    if ( this->m_meterSymb != otherMensur->m_meterSymb ) {\n        return false;\n    }\n    if ( this->m_num != otherMensur->m_num ) {\n        return false;\n    }\n    if ( this->m_numBase != otherMensur->m_numBase ) {\n        return false;\n    }\n    if ( this->m_reversed != otherMensur->m_reversed ) {\n        return false;\n    }\n    if ( this->m_sign != otherMensur->m_sign ) {\n        return false;\n    }\n    if ( this->m_slash != otherMensur->m_slash ) {\n        return false;\n    }\n    return true;\n}\n\nvoid MusMensur::SetValue( int value, int flag ) \n{\n    this->m_num = 0;\n    this->m_numBase = 0;\n    switch ( value ) {\n        // tempus perfectum\n        case ('Q'): \n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_O;\n            this->m_slash = 0;\n            this->m_dot = 1;\n            this->m_reversed = false;\n            break;\n        case ('W'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_O;\n            this->m_slash = 1;\n            this->m_dot = 1;\n            this->m_reversed = false;\n            break;\n        case ('E'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_O;\n            this->m_slash = 0;\n            this->m_dot = 0;\n            this->m_reversed = false;\n            break;\n        case ('R'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_O;\n            this->m_slash = 1;\n            this->m_dot = 0;\n            this->m_reversed = false;\n            break;\n        // tempus imperfectum\n        case ('A'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 0;\n            this->m_dot = 1;\n            this->m_reversed = false;\n            break;\n        case ('S'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 1;\n            this->m_dot = 1;\n            this->m_reversed = false;\n            break;\n        case ('D'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 0;\n            this->m_dot = 0;\n            this->m_reversed = false;\n            break;\n        case ('F'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 1;\n            this->m_dot = 0;\n            this->m_reversed = false;\n            break;\n        // tempus imperfectum diminutum\n        case ('Y'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 0;\n            this->m_dot = 1;\n            this->m_reversed = true;\n            break;\n        case ('X'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 1;\n            this->m_dot = 1;\n            this->m_reversed = true;\n            break;\n        case ('C'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 0;\n            this->m_dot = 0;\n            this->m_reversed = true;\n            break;\n        case ('V'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_C;\n            this->m_slash = 1;\n            this->m_dot = 0;\n            this->m_reversed = true;\n            break;;\n        case ('1'):\n            this->m_meterSymb = METER_SYMB_NONE;\n            this->m_sign = MENSUR_SIGN_NONE;\n            this->m_slash = 0;\n            this->m_dot = 0;\n            this->m_reversed = false;\n            this->m_num = MusMensur::s_num; \n            this->m_numBase = MusMensur::s_numBase; \n            break;\n            \n        //case ('2'): this->code = 64; this->calte = 2; break;\n        //case ('3'): this->code = 64; this->calte = 3; break;\n    }\n}\n","//\n//  musmultirest.cpp\n//  aruspix\n//\n//  Created by Rodolfo Zitellini on 02/12/13.\n//  Copyright (c) 2013 com.aruspix.www. All rights reserved.\n//\n\n\n#include \"musmultirest.h\"\n\n//----------------------------------------------------------------------------\n// MusClef\n//----------------------------------------------------------------------------\n\nMusMultiRest::MusMultiRest():\nMusLayerElement(\"multirest-\")\n{\n    m_number = 0;\n}\n\nMusMultiRest::MusMultiRest(int number):\n    MusLayerElement(\"multirest-\")\n{\n    m_number = number;\n}\n\n\nMusMultiRest::~MusMultiRest()\n{\n}\n\n\nbool MusMultiRest::operator==( MusObject& other )\n{\n    MusMultiRest *otherM = dynamic_cast<MusMultiRest*>( &other );\n    if ( !otherM ) {\n        return false;\n    }\n    if ( this->m_number != otherM->m_number ) {\n        return false;\n    }\n    return true;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musnote.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musnote.h\"\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"mustie.h\"\n\n//----------------------------------------------------------------------------\n// MusNote\n//----------------------------------------------------------------------------\n\nMusNote::MusNote():\n\tMusLayerElement(\"note-\"), MusDurationInterface(), MusPitchInterface()\n{\n    m_artic = 0;\n    m_chord = 0;\n    m_colored = false;\n    m_headshape = 0;\n    m_lig = 0;\n    m_ligObliqua = false;\n    memset(m_slur, 0, sizeof(unsigned char) * NOTE_MAX_SLURS);\n    m_stemDir = 0;\n    m_stemLen = 0;\n    m_acciaccatura = false;\n    m_embellishment = EMB_NONE;\n    // tie pointers\n    m_tieAttrInitial = NULL;\n    m_tieAttrTerminal = NULL;\n}\n\n\nMusNote::~MusNote()\n{\n    // This deletes the MusTie object if necessary\n    ResetTieAttrInitial();\n}\n\nbool MusNote::operator==( MusObject& other )\n{\n    MusNote *otherNote = dynamic_cast<MusNote*>( &other );\n    if ( !otherNote ) {\n        return false;\n    }\n    if ( this->m_artic != otherNote->m_artic ) {\n        return false;\n    }\n    if ( this->m_chord != otherNote->m_chord ) {\n        return false;\n    }\n    if ( this->m_colored != otherNote->m_colored ) {\n        return false;\n    }\n    if ( this->m_headshape != otherNote->m_headshape ) {\n        return false;\n    }\n    if ( this->m_lig != otherNote->m_lig ) {\n        return false;\n    }\n    if ( this->m_ligObliqua != otherNote->m_ligObliqua ) {\n        return false;\n    }\n    // slur need value by value comparison\n    //if ( this->m_slur != otherNote->m_slur ) {\n    //    return false;\n    //}\n    if ( this->m_stemDir != otherNote->m_stemDir ) {\n        return false;\n    }\n    if ( this->m_stemLen != otherNote->m_stemLen ) {\n        return false;\n    }\n    if ( this->m_acciaccatura != otherNote->m_acciaccatura ) {\n        return false;\n    }\n    if ( this->m_embellishment != otherNote->m_embellishment ) {\n        return false;\n    }\n    if ( !this->HasIdenticalPitchInterface( otherNote ) ) {\n        return false;\n    }\n    if ( !this->HasIdenticalDurationInterface( otherNote ) ) {\n        return false;\n    }\n    \n    return true;\n}\n\nvoid MusNote::SetValue( int value, int flag )\n{\n    MusDurationInterface::SetDuration( value ); \n    \n\t// remove ligature flag for  inadequate values\t\n\tif ( ( value < DUR_BR ) || ( value > DUR_1 ) ) {\n        this->m_lig = 0;\n    }\n\n\tthis->m_colored = false;\n\tthis->m_ligObliqua = false;\n    \n\t// remove qauto flag for silences and inadequate values\t\n\tif ( ( value > DUR_LG ) && ( value < DUR_2 ) ) {\n\t\tthis->m_stemDir = 0;\n        this->m_stemLen = 0;\n    }    \n}\n\nvoid MusNote::SetTieAttrInitial()\n{\n    if ( m_tieAttrInitial ) {\n        Mus::LogWarning(\"Initial tie attribute already set for note '%s\", this->GetUuid().c_str() );\n        return;\n    }\n    m_tieAttrInitial = new MusTie();\n    m_tieAttrInitial->SetFirstNote( this );\n}\n\nvoid MusNote::SetTieAttrTerminal( MusNote *previousNote )\n{\n    if ( m_tieAttrTerminal ) {\n        Mus::LogWarning(\"Terminal tie attribute already set for note '%s\", this->GetUuid().c_str() );\n        return;\n    }\n    if ( !previousNote || !previousNote->GetTieAttrInitial() ) {\n        Mus::LogWarning(\"No previous note or previous note without intial or median attribute for note '%s\", this->GetUuid().c_str() );\n        return;\n    }\n    m_tieAttrTerminal = previousNote->GetTieAttrInitial();\n    m_tieAttrTerminal->SetSecondNote( this );\n}\n\nvoid MusNote::ResetTieAttrInitial( )\n{\n    if ( m_tieAttrInitial ) {\n        // Deleting the MusTie object will also reset the m_tieAttrTerminal of the second note\n        delete m_tieAttrInitial;\n        m_tieAttrInitial = NULL;\n    }\n}\n\nvoid MusNote::ChangeColoration( )\n{\n    this->m_colored = !this->m_colored;\n}\n\n\nvoid MusNote::ChangeStem( )\n{\n\tif ( ( this->m_dur > DUR_LG ) && ( this->m_dur < DUR_2 ) )\n\t\treturn;\n    \n\tthis->m_stemDir = !this->m_stemDir;\n}\n\n\nvoid MusNote::SetLigature( )\n{\n\tif ( ( this->m_dur == DUR_LG ) || ( this->m_dur > DUR_1 ) ) {\n\t\treturn;\n    }\n\t\n\tthis->m_lig = true;\n}\n\nint MusNote::GetHorizontalSpacing()\n{\n    if (this->m_cueSize) {\n        return 3;\n    }\n    return 5; // arbitrary generic value\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musobject.cpp\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"musobject.h\"\n\n//----------------------------------------------------------------------------\n\n#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musaligner.h\"\n#include \"musbeam.h\"\n#include \"musclef.h\"\n#include \"musdoc.h\"\n#include \"muskeysig.h\"\n#include \"muslayer.h\"\n#include \"muslayerelement.h\"\n#include \"musmeasure.h\"\n#include \"muspage.h\"\n#include \"musrc.h\"\n#include \"musscoredef.h\"\n#include \"musstaff.h\"\n#include \"mussystem.h\"\n#include \"mustie.h\"\n#include \"mustuplet.h\"\n\n//----------------------------------------------------------------------------\n// MusObject\n//----------------------------------------------------------------------------\n\nMusObject::MusObject()\n{\n    Init(\"m-\");\n}\n\nMusObject::MusObject(std::string classid)\n{\n    Init(classid);\n}\n\nMusObject *MusObject::Clone( )\n{\n    // This should new happen because the method should be overwritten\n    assert( false );\n}\n\nMusObject::MusObject( const MusObject& object )\n{\n    ClearChildren();\n    m_parent = NULL;\n    m_classid = object.m_classid;\n    m_uuid = object.m_uuid; // for now copy the uuid - to be decided\n    m_isModified = true;\n    \n    int i;\n    for (i = 0; i < (int)object.m_children.size(); i++)\n    {\n        MusObject *current = object.m_children[i];\n        MusObject* copy = current->Clone();\n        copy->Modify();\n        copy->SetParent( this );\n        m_children.push_back( copy );\n    }\n}\n\nMusObject& MusObject::operator=( const MusObject& object )\n{\n\tif ( this != &object ) // not self assignement\n\t{\n        ClearChildren();\n        m_parent = NULL;\n        m_classid = object.m_classid;\n        m_uuid = object.m_uuid; // for now copy the uuid - to be decided\n        m_isModified = true;\n        \n        int i;\n        for (i = 0; i < (int)object.m_children.size(); i++)\n        {\n            MusObject *current = object.m_children[i];\n            MusObject* copy = current->Clone();\n            copy->Modify();\n            copy->SetParent( this );\n            m_children.push_back( copy );\n        }\n\t}\n\treturn *this;\n}\n\nMusObject::~MusObject()\n{\n    ClearChildren();\n}\n\nvoid MusObject::Init(std::string classid)\n{\n    m_parent = NULL;\n    m_isModified = true;\n    m_classid = classid;\n    this->GenerateUuid();\n}\n\nvoid MusObject::SetUuid( std::string uuid )\n{ \n    m_uuid = uuid;\n};\n\nvoid MusObject::ClearChildren()\n{\n    ArrayOfMusObjects::iterator iter;\n    for (iter = m_children.begin(); iter != m_children.end(); ++iter)\n    {\n        delete *iter;\n    }\n    m_children.clear();\n}\n\nint MusObject::GetIdx() const\n{\n    assert( m_parent );\n    \n    return m_parent->GetChildIndex( this );\n}\n\nvoid MusObject::InsertChild( MusObject *element, int idx )\n{\n    if ( idx >= (int)m_children.size() ) {\n        m_children.push_back( element );\n    }\n    ArrayOfMusObjects::iterator iter = m_children.begin();\n    m_children.insert( iter+(idx), element );\n}\n\nMusObject *MusObject::DetachChild( int idx )\n{\n    if ( idx >= (int)m_children.size() ) {\n        return NULL;\n    }\n    MusObject *child = m_children[idx];\n    child->m_parent = NULL;\n    ArrayOfMusObjects::iterator iter = m_children.begin();\n    m_children.erase( iter+(idx) );\n    return child;\n}\n\n\nMusObject* MusObject::GetChild( int idx )\n{\n    if ( (idx < 0) || (idx >= (int)m_children.size()) ) {\n        return NULL;\n    }\n    return m_children[idx];\n}\n\nvoid MusObject::RemoveChildAt( int idx )\n{\n    if ( idx >= (int)m_children.size() ) {\n        return;\n    }\n    delete m_children[idx];\n    ArrayOfMusObjects::iterator iter = m_children.begin();\n    m_children.erase( iter+(idx) );\n}\n\nvoid MusObject::GenerateUuid() {\n    int nr = std::rand();\n    char str[17];\n    // I do not want to use a stream to do this!\n    snprintf (str, 16, \"%016d\", nr);\n    \n    m_uuid = m_classid + std::string(str);\n}\n\nvoid MusObject::ResetUuid()\n{\n    GenerateUuid();\n}\n\nvoid MusObject::SetParent( MusObject *parent )\n{\n    assert( !m_parent );\n    m_parent = parent;\n}\n\n\nbool MusObject::operator==( MusObject& other )\n{\n    // This should never happen.\n    // The comparison is performed in the CmpFile::Align method.\n    // We expect to compare only MusNote, MusRest, etc object for which we have an overwritten method\n    Mus::LogError( \"Missing comparison operator for '%s'\", this->MusClassName().c_str() );\n    return false;\n}\n\nint MusObject::GetChildIndex( const MusObject *child )\n{\n    ArrayOfMusObjects::iterator iter;\n    int i;\n    for (iter = m_children.begin(), i = 0; iter != m_children.end(); ++iter, i++)\n    {\n        if ( child == *iter ) {\n            return i;\n        }\n\n    }\n    return -1;\n}\n\nvoid MusObject::Modify( bool modified )\n{    \n    // if we have a parent and a new modification, propagate it\n    if ( m_parent && !m_isModified && modified ) {\n        m_parent->Modify();\n    }\n    m_isModified = modified;\n}\n\nvoid MusObject::FillList( ListOfMusObjects *list )\n{\n    MusFunctor addToList( &MusObject::AddMusLayerElementToList );\n    ArrayPtrVoid params;\n    params.push_back ( &list );\n    this->Process( &addToList, params );\n\n    /* // For debuging\n    ListOfMusObjects::iterator iter;\n    for (iter = list->begin(); iter != list->end(); ++iter)\n    {\n        MusObject *current = *iter;\n        Mus::LogDebug(\"%s\", current->MusClassName().c_str() );\n    }\n    */\n}\n\nvoid MusObject::AddSameAs( std::string id, std::string filename )\n{\n    std::string sameAs = filename;\n    if ( !filename.empty() ) {\n        sameAs += \"#\";\n    }\n    sameAs += id;\n    \n    if ( !m_sameAs.empty() ) {\n        m_sameAs += \" \";\n    }\n    m_sameAs += sameAs;\n}\n\nMusObject *MusObject::GetFirstParent( const std::type_info *elementType, int maxSteps )\n{\n    if ( (maxSteps == 0) || !m_parent ) {\n        return NULL;\n    }\n    \n    if ( typeid(*m_parent) == *elementType ) {\n        return m_parent;\n    }\n    else {\n        return ( m_parent->GetFirstParent( elementType, maxSteps - 1 ) );\n    }\n}\n\n\nMusObject *MusObject::GetFirstChild( const std::type_info *elementType )\n{\n    ArrayOfMusObjects::iterator iter;\n    int i;\n    for (iter = m_children.begin(), i = 0; iter != m_children.end(); ++iter, i++)\n    {\n        if ( typeid(**iter) == *elementType )\n        {\n            return *iter;\n        }\n    }\n    return NULL;\n}\n\nMusObject *MusObject::GetNextSibling( const std::type_info *elementType )\n{\n    if (!m_parent) {\n        return NULL;\n    }\n    \n    ArrayOfMusObjects::iterator iter;\n    bool foundCurrent = false;\n    for (iter = this->m_parent->m_children.begin(); iter != this->m_parent->m_children.end(); ++iter)\n    {\n        // we have not found the current object\n        if ( this == *iter ) {\n            foundCurrent = true;\n            // continue to find the next sibling\n            continue;\n        }\n        else if (!foundCurrent) {\n            continue;\n        }\n        if ( !elementType ) {\n            return *iter;\n        }\n        if ( typeid(**iter) == *elementType )\n        {\n            return *iter;\n        }\n    }\n    return NULL;\n}\n\nMusObject *MusObject::GetPreviousSibling( const std::type_info *elementType )\n{\n    if (!m_parent) {\n        return NULL;\n    }\n    \n    ArrayOfMusObjects::reverse_iterator iter;\n    bool foundCurrent = false;\n    for (iter = this->m_parent->m_children.rbegin(); iter != this->m_parent->m_children.rend(); ++iter)\n    {\n        // we have not found the current object\n        if ( this == *iter ) {\n            foundCurrent = true;\n            // continue to find the next sibling\n            continue;\n        }\n        else if (!foundCurrent) {\n            continue;\n        }\n        if ( !elementType ) {\n            return *iter;\n        }\n        if ( typeid(**iter) == *elementType )\n        {\n            return *iter;\n        }\n    }\n    return NULL;\n}\n\n\nbool MusObject::GetSameAs( std::string *id, std::string *filename, int idx )\n{\n    int i = 0;\n    \n    std::istringstream iss( m_sameAs );\n    std::string token;\n    while( getline( iss, token, ' '))\n    {\n        if ( i == idx ) {\n            size_t pos = token.find( \"#\" );\n            if (pos != std::string::npos) {\n                (*filename) = token.substr( 0, pos );\n                (*id) = token.substr( pos + 1, std::string::npos );\n            }\n            else {\n                (*filename) = \"\";\n                (*id) = token;\n            }\n            return true;\n        }\n        i++;\n    }\n    return false;\n}\n\nvoid MusObject::Process(MusFunctor *functor, ArrayPtrVoid params, MusFunctor *endFunctor )\n{\n    if (functor->m_returnCode == FUNCTOR_STOP) {\n        return;\n    }\n    \n    functor->Call( this, params );\n    \n    // do not go any deeper in this case\n    if (functor->m_returnCode == FUNCTOR_SIBLINGS) {\n        functor->m_returnCode = FUNCTOR_CONTINUE;\n        return;\n    }\n\n    ArrayOfMusObjects::iterator iter;\n    for (iter = this->m_children.begin(); iter != m_children.end(); ++iter)\n    {\n        (*iter)->Process( functor, params, endFunctor );\n    }\n    \n    if ( endFunctor ) {\n        endFunctor->Call( this, params );\n    }\n}\n\n//----------------------------------------------------------------------------\n// MusDocObject\n//----------------------------------------------------------------------------\n\n\n// Note: since it is one line of code\n// I am not making a new function for the two\n// constructors.\nMusDocObject::MusDocObject():\n    MusObject(\"md-\")\n{\n\tResetBB();\n}\n\nMusDocObject::MusDocObject(std::string classid) :\n    MusObject(classid)\n{\n\t//m_doc = NULL;\n    ResetBB();\n}\n\nMusDocObject::~MusDocObject()\n{\n}\n\nvoid MusDocObject::Refresh() \n{\n    // if we have a parent MusDocObject, propagate it\n    if ( dynamic_cast<MusDocObject*>(m_parent) ) {\n        ((MusDocObject*)m_parent)->Refresh();\n    }\n}\n\n\nvoid MusDocObject::UpdateContentBB( int x1, int y1, int x2, int y2) \n{\n    //Mus::LogDebug(\"CB Was: %i %i %i %i\", m_contentBB_x1, m_contentBB_y1, m_contentBB_x2 ,m_contentBB_y2);\n    \n    int min_x = std::min( x1, x2 );\n    int max_x = std::max( x1, x2 );\n    int min_y = std::min( y1, y2 );\n    int max_y = std::max( y1, y2 );\n    \n    if (m_contentBB_x1 > min_x) m_contentBB_x1 = min_x;\n    if (m_contentBB_y1 > min_y) m_contentBB_y1 = min_y;\n    if (m_contentBB_x2 < max_x) m_contentBB_x2 = max_x;\n    if (m_contentBB_y2 < max_y) m_contentBB_y2 = max_y;\n    \n    m_updatedBB = true;\n    //Mus::LogDebug(\"CB Is:  %i %i %i %i\", m_contentBB_x1,m_contentBB_y1, m_contentBB_x2, m_contentBB_y2);\n}\n\nvoid MusDocObject::UpdateSelfBB( int x1, int y1, int x2, int y2 ) \n{\n    //Mus::LogDebug(\"SB Was: %i %i %i %i\", m_selfBB_x1,m_selfBB_y1, m_selfBB_x2 ,m_selfBB_y2);\n    \n    int min_x = std::min( x1, x2 );\n    int max_x = std::max( x1, x2 );\n    int min_y = std::min( y1, y2 );\n    int max_y = std::max( y1, y2 );\n    \n    if (m_selfBB_x1 > min_x) m_selfBB_x1 = min_x;\n    if (m_selfBB_y1 > min_y) m_selfBB_y1 = min_y;\n    if (m_selfBB_x2 < max_x) m_selfBB_x2 = max_x;\n    if (m_selfBB_y2 < max_y) m_selfBB_y2 = max_y;\n    \n    m_updatedBB = true;\n    \n    //Mus::LogDebug(\"SB Is:  %i %i %i %i\", m_selfBB_x1,m_selfBB_y1, m_selfBB_x2 ,m_selfBB_y2);\n    \n}\n\nvoid MusDocObject::ResetBB() \n{\n    m_contentBB_x1 = 0xFFFF;\n    m_contentBB_y1 = 0xFFFF;\n    m_contentBB_x2 = -0xFFFF;\n    m_contentBB_y2 = -0xFFFF;\n    m_selfBB_x1 = 0xFFFF;\n    m_selfBB_y1 = 0xFFFF; \n    m_selfBB_x2 = -0xFFFF;\n    m_selfBB_y2 = -0xFFFF;\n    \n    m_updatedBB = false;\n}\n\nbool MusDocObject::HasContentBB() \n{\n    return ( (m_contentBB_x1 != 0xFFFF) && (m_contentBB_y1 != 0xFFFF) && (m_contentBB_x2 != -0xFFFF) && (m_contentBB_y2 != -0xFFFF) );\n}\n\nbool MusDocObject::HasSelfBB() \n{\n    return ( (m_selfBB_x1 != 0xFFFF) && (m_selfBB_y1 != 0xFFFF) && (m_selfBB_x2 != -0xFFFF) && (m_selfBB_y2 != -0xFFFF) );\n}\n\n\n//----------------------------------------------------------------------------\n// MusObjectListInterface\n//----------------------------------------------------------------------------\n\n\nMusObjectListInterface::MusObjectListInterface( const MusObjectListInterface& interface )\n{\n    // actually nothing to do, we just don't want the list to be copied\n    m_list.clear();\n}\n\nMusObjectListInterface& MusObjectListInterface::operator=( const MusObjectListInterface& interface )\n{\n    // actually nothing to do, we just don't want the list to be copied\n    if ( this != &interface ) {\n        this->m_list.clear();\n    }\n\treturn *this;\n}\n\nvoid MusObjectListInterface::ResetList( MusObject *node )\n{\n    // nothing to do, the list if up to date\n    if ( !node->IsModified() ) {\n        return;\n    }\n    \n    m_list.clear();\n    node->FillList( &m_list );\n    this->FilterList();\n    node->Modify( false );\n}\n\nListOfMusObjects *MusObjectListInterface::GetList( MusObject *node )\n{   \n    ResetList( node );\n    return &m_list;\n}\n\n\nint MusObjectListInterface::GetListIndex( const MusObject *listElement )\n{\n    ListOfMusObjects::iterator iter;\n    int i;\n    for (iter = m_list.begin(), i = 0; iter != m_list.end(); ++iter, i++)\n    {\n        if ( listElement == *iter ) {\n            return i;\n        }\n        \n    }\n    return -1;\n}\n\nMusObject *MusObjectListInterface::GetListPrevious( const MusObject *listElement )\n{\n    ListOfMusObjects::iterator iter;\n    int i;\n    for (iter = m_list.begin(), i = 0; iter != m_list.end(); ++iter, i++)\n    {\n        if (listElement == *iter) {\n            if (i > 0) {\n                return *(--iter);\n            }\n            else {\n                return NULL;\n            }\n        }\n        \n    }\n    return NULL;\n}\n\nMusObject *MusObjectListInterface::GetListNext( const MusObject *listElement )\n{\n    ListOfMusObjects::reverse_iterator iter;\n    int i;\n    for (iter = m_list.rbegin(), i = 0; iter != m_list.rend(); ++iter, i++)\n    {\n        if ( listElement == *iter ) {\n            if (i > 0) {\n                return *(--iter);\n            }\n            else {\n                return NULL;\n            }\n        }\n        \n    }\n    return NULL;\n}\n\n//----------------------------------------------------------------------------\n// MusFunctor\n//----------------------------------------------------------------------------\n\nMusFunctor::MusFunctor( )\n{ \n    m_returnCode = FUNCTOR_CONTINUE;\n    m_reverse = false;\n    obj_fpt = NULL; \n}\n\nMusFunctor::MusFunctor( int(MusObject::*_obj_fpt)( ArrayPtrVoid ))\n{ \n    m_returnCode = FUNCTOR_CONTINUE;\n    m_reverse = false;\n    obj_fpt = _obj_fpt; \n}\n\nvoid MusFunctor::Call( MusObject *ptr, ArrayPtrVoid params )\n{\n    // we should have return codes (not just bool) for avoiding to go further down the tree in some cases\n    m_returnCode = (*ptr.*obj_fpt)( params );\n}\n\n//----------------------------------------------------------------------------\n// MusObject functor methods\n//----------------------------------------------------------------------------\n\nint MusObject::AddMusLayerElementToList( ArrayPtrVoid params )\n{\n    // param 0: the ListOfMusObjects\n    ListOfMusObjects **list = (ListOfMusObjects**)params[0];\n    //if ( dynamic_cast<MusLayerElement*>(this ) ) {\n        (*list)->push_back( this );\n    //}\n    return FUNCTOR_CONTINUE;\n}\n\nint MusObject::FindByUuid( ArrayPtrVoid params )\n{\n    // param 0: the uuid we are looking for\n    // param 1: the pointer to pointer to the MusObject\n    std::string *uuid = (std::string*)params[0];  \n    MusObject **element = (MusObject**)params[1];  \n    \n    if ( (*element) ) {\n        // this should not happen, but just in case\n        return FUNCTOR_STOP;\n    }\n    \n    if ( *uuid == this->GetUuid()) {\n        (*element) = this;\n        //Mus::LogDebug(\"Found it!\");\n        return FUNCTOR_STOP;\n    }\n    //Mus::LogDebug(\"Still looking for uuid...\");\n    return FUNCTOR_CONTINUE;\n}\n\n\nint MusObject::SetPageScoreDef( ArrayPtrVoid params )\n{\n\n    // param 0: the current scoreDef\n    MusScoreDef *currentScoreDef = (MusScoreDef*)params[0];\n    MusStaffDef **currentStaffDef = (MusStaffDef**)params[1];\n    \n\n    // starting a new page\n    MusPage *current_page = dynamic_cast<MusPage*>(this);\n    if ( current_page  ) {\n        currentScoreDef->SetRedraw( true, true, false );\n        current_page->m_drawingScoreDef = *currentScoreDef;\n        return FUNCTOR_CONTINUE;\n    }\n    \n   \n    // starting a new system\n    MusSystem *current_system = dynamic_cast<MusSystem*>(this);\n    if ( current_system  ) {\n        currentScoreDef->SetRedraw( true, true, false );\n        return FUNCTOR_CONTINUE;\n    }\n\n    // starting a new staff\n    MusStaff *current_staff = dynamic_cast<MusStaff*>(this);\n    if ( current_staff  ) {\n        (*currentStaffDef) = currentScoreDef->GetStaffDef( current_staff->GetStaffNo() );\n        return FUNCTOR_CONTINUE;\n    }\n\n    // starting a new layer\n    MusLayer *current_layer = dynamic_cast<MusLayer*>(this);\n    if ( current_layer  ) {\n        current_layer->SetDrawingValues( currentScoreDef, (*currentStaffDef) );\n        return FUNCTOR_CONTINUE;\n    }\n    \n    // starting a new clef\n    MusClef *current_clef = dynamic_cast<MusClef*>(this);\n    if ( current_clef  ) {\n        currentScoreDef->ReplaceClef( current_clef );\n        return FUNCTOR_CONTINUE;\n    }\n    \n    // starting a new keysig\n    MusKeySig *current_keysig = dynamic_cast<MusKeySig*>(this);\n    if ( current_keysig  ) {\n        currentScoreDef->ReplaceKeySig( current_keysig );\n        return FUNCTOR_CONTINUE;\n    }\n    \n    return FUNCTOR_CONTINUE;\n}\n\n\nint MusObject::SetBoundingBoxXShift( ArrayPtrVoid params )\n{\n    // param 0: the minimu position (i.e., the width of the previous element)\n    // param 1: the maximum width in the current measure\n    int *min_pos = (int*)params[0];\n    int *measure_width = (int*)params[1];\n\n    // starting a new measure\n    MusMeasure *current_measure = dynamic_cast<MusMeasure*>(this);\n    if ( current_measure  ) {\n        // we reset the measure width and the minimum position\n        (*measure_width) = 0;\n        (*min_pos) = 0;\n        if (current_measure->GetLeftBarlineType() != BARLINE_NONE) {\n            current_measure->GetLeftBarline()->SetBoundingBoxXShift( params );\n        }\n        return FUNCTOR_CONTINUE;\n    }\n    \n    // starting an new layer\n    MusLayer *current_layer = dynamic_cast<MusLayer*>(this);\n    if ( current_layer  ) {\n        // mininimum position is the with for the last (previous) layer\n        // we keep it if it is higher than what we had so far\n        // this will be used for shifting the right barline.\n        // This can probably also be done in a EndFunctor for the measure\n        (*measure_width) = std::max( (*measure_width), (*min_pos) );\n        // reset it as the minimum position to the step (if doc found)\n        (*min_pos) = 0;\n        MusDoc *doc = dynamic_cast<MusDoc*>( current_layer->GetFirstParent( &typeid(MusDoc) ) );\n        if (doc) (*min_pos) = doc->m_rendStep1;\n        // set scoreDef attr\n        if (current_layer->GetClefAttr()) {\n            current_layer->GetClefAttr()->SetBoundingBoxXShift( params );\n        }\n        if (current_layer->GetKeySigAttr()) {\n            current_layer->GetKeySigAttr()->SetBoundingBoxXShift( params );\n        }\n        return FUNCTOR_CONTINUE;\n    }\n\n    MusLayerElement *current = dynamic_cast<MusLayerElement*>(this);\n    if ( !current  ) {\n        return FUNCTOR_CONTINUE;\n    }\n    \n    // we should have processed aligned before\n    assert( current->GetAlignment() );\n\n    if ( !current->HasUpdatedBB() ) {\n        // this is all we need for empty elements\n        current->GetAlignment()->SetXRel(*min_pos);\n        return FUNCTOR_CONTINUE;\n    }\n    \n    if ( dynamic_cast<MusBeam*>(current) ) {\n        return FUNCTOR_CONTINUE;\n    }\n    \n    if ( dynamic_cast<MusTie*>(current) ) {\n        return FUNCTOR_CONTINUE;\n    }\n    \n    if ( dynamic_cast<MusTuplet*>(current) ) {\n        return FUNCTOR_CONTINUE;\n    }\n    \n    // the negative offset it the part of the bounding box that overflows on the left\n    // |____x_____|\n    //  ---- = negative offset\n    int negative_offset = current->GetAlignment()->GetXRel() - current->m_contentBB_x1;\n    \n    // this will probably never happen\n    if ( negative_offset < 0 ) {\n        negative_offset = 0;\n    }\n    \n    // check if the element overlaps with the preceeding one given by (*min_pos)\n    int overlap = 0;\n    if ( (current->GetAlignment()->GetXRel() - negative_offset) < (*min_pos) ) {\n        overlap = (*min_pos) - current->GetAlignment()->GetXRel() + negative_offset;\n        // shift the current element\n        current->GetAlignment()->SetXShift( overlap );\n    }\n    \n    //Mus::LogDebug(\"%s min_pos %d; negative offset %d;  x_rel %d; overlap %d\", current->MusClassName().c_str(), (*min_pos), negative_offset, current->GetAlignment()->GetXRel(), overlap );\n    \n    // the next minimal position if given by the right side of the bounding box + the spacing of the element\n    (*min_pos) = current->m_contentBB_x2 + current->GetHorizontalSpacing();\n    current->GetAlignment()->SetMaxWidth( current->m_contentBB_x2 - current->GetAlignment()->GetXRel() + current->GetHorizontalSpacing() );\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusObject::SetBoundingBoxXShiftEnd( ArrayPtrVoid params )\n{\n    // param 0: the minimu position (i.e., the width of the previous element)\n    // param 1: the maximum width in the current measure\n    int *min_pos = (int*)params[0];\n    int *measure_width = (int*)params[1];\n    \n    // ending a measure\n    MusMeasure *current_measure = dynamic_cast<MusMeasure*>(this);\n    if ( current_measure  ) {\n        // as minimum position of the barline use the measure width\n        (*min_pos) = (*measure_width);\n        if (current_measure->GetRightBarlineType() != BARLINE_NONE) {\n            current_measure->GetRightBarline()->SetBoundingBoxXShift( params );\n        }\n        return FUNCTOR_CONTINUE;\n    }\n    \n    // ending a layer\n    MusLayer *current_layer = dynamic_cast<MusLayer*>(this);\n    if ( current_layer  ) {\n        // mininimum position is the with the layer\n        // we keep it if is higher than what we had so far\n        // this will be used for shifting the right barline\n        (*measure_width) = std::max( (*measure_width), (*min_pos) );\n        return FUNCTOR_CONTINUE;\n    }\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusObject::SetBoundingBoxYShift( ArrayPtrVoid params )\n{\n    // param 0: the height of the previous staff\n    int *min_pos = (int*)params[0];\n    \n    // starting a new measure\n    MusMeasure *current_measure = dynamic_cast<MusMeasure*>(this);\n    if ( current_measure  ) {\n        (*min_pos) = 0;\n    }\n    \n    MusStaff *current = dynamic_cast<MusStaff*>(this);\n    if ( !current  ) {\n        return FUNCTOR_CONTINUE;\n    }\n    \n    // at this stage we assume we have instanciated the alignment pointer\n    assert( current->GetAlignment() );\n    \n    // This is the value that need to be removed to fit everything\n    int negative_offset = current->GetAlignment()->GetYRel() - current->m_contentBB_y2;\n    \n    // this will probably never happen\n    if ( negative_offset > 0 ) {\n        negative_offset = 0;\n    }\n    \n    // check if the staff overlaps with the preceeding one given by (*min_pos)\n    int overlap = 0;\n    if ( (current->GetAlignment()->GetYRel() - negative_offset) > (*min_pos) ) {\n        overlap = (*min_pos) - current->GetAlignment()->GetYRel() + negative_offset;\n        current->GetAlignment()->SetYShift( overlap );\n    }\n    \n    //Mus::LogDebug(\"%s min_pos %d; negative offset %d;  x_rel %d; overlap %d\", current->MusClassName().c_str(), (*min_pos), negative_offset, current->GetAlignment()->GetXRel(), overlap );\n    \n    // the next minimal position if given by the right side of the bounding box + the spacing of the element\n    (*min_pos) = current->m_contentBB_y1;\n    \n    // do not go further down the tree in this case\n    return FUNCTOR_SIBLINGS;\n}\n\n\n\n\n\n\n\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muspage.cpp\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"muspage.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n\n#include \"musaligner.h\"\n#include \"musbboxdc.h\"\n#include \"musdef.h\"\n#include \"musdoc.h\"\n#include \"musrc.h\"\n#include \"musstaff.h\"\n#include \"mussystem.h\"\n\n//----------------------------------------------------------------------------\n// MusPage\n//----------------------------------------------------------------------------\n\nMusPage::MusPage() :\n\tMusDocObject(\"page-\")\n{\n\tClear( );\n}\n\nMusPage::~MusPage()\n{\n}\n\nvoid MusPage::Clear( )\n{\n\tClearChildren( );\n    m_drawingScoreDef.Clear();\n\tdefin = 18;\n    // by default we have no values and use the document ones\n    m_pageHeight = -1;\n    m_pageWidth = -1;\n    m_pageLeftMar = 0;\n    m_pageRightMar = 0;\n    m_pageTopMar = 0;\n    this->ResetUuid();\n}\n\n\nint MusPage::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];       \n    if (!output->WritePage( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n}\n\n\nvoid MusPage::AddSystem( MusSystem *system )\n{\n\tsystem->SetParent( this );\n\tm_children.push_back( system );\n    Modify();\n}\n\nint MusPage::GetStaffPosOnPage( MusStaff *staff )\n{\n    /*\n    int position = -1;\n    bool success = false;\n    ArrayPtrVoid params;\n    params.Add( staff );\n    params.Add( &position );\n    params.Add( &success );\n    MusStaffFunctor getStaffPosOnPage( &MusStaff::GetPosOnPage );\n    Process( &getStaffPosOnPage, params );    \n    return position;\n    */ // ax2.3\n    return 0;\n}\n\n\nMusSystem *MusPage::GetFirst( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\treturn (MusSystem*)m_children[0];\n}\n\nMusSystem *MusPage::GetLast( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\tint i = GetSystemCount() - 1;\n\treturn (MusSystem*)m_children[i];\n}\n\nMusSystem *MusPage::GetNext( MusSystem *system )\n{\n    if ( !system || m_children.empty())\n        return NULL;\n        \n\tint i = this->GetChildIndex( system );\n\n\tif ((i == -1 ) || ( i >= GetSystemCount() - 1 ))\n\t\treturn NULL;\n\t\n\treturn (MusSystem*)m_children[i + 1];\n}\n\nMusSystem *MusPage::GetPrevious( MusSystem *system  )\n{\n    if ( !system || m_children.empty())\n        return NULL;\n        \n\tint i = GetChildIndex( system );\n\n\tif ((i == -1 ) || ( i <= 0 ))\n        return NULL;\n\t\n    return (MusSystem*)m_children[i - 1];\n}\n\n\nMusSystem *MusPage::GetAtPos( int y )\n{\n\n\ty -= ( SYSTEM_OFFSET / 2 );\n    MusSystem *system = this->GetFirst();\n\tif ( !system )\n\t\treturn NULL;\n\t\n    MusSystem *next = NULL;\n\twhile ( (next = this->GetNext(system)) )\n\t{\n\t\tif ( (int)next->m_yAbs < y )\n\t\t{\n\t\t\treturn system;\n\t\t}\n\t\tsystem = next;\n\t}\n\n\treturn system;\n}\n\nvoid MusPage::Layout( )\n{\n    if (!dynamic_cast<MusDoc*>(m_parent)) {\n        assert( false );\n        return;\n    }\n    MusDoc *doc = dynamic_cast<MusDoc*>(m_parent);\n    \n    doc->SetRendPage( this );\n    \n    ArrayPtrVoid params;\n    \n    // Align the content of the page using measure and system aligners\n    // After this:\n    // - each MusLayerElement object will have its MusAlignment pointer initialized\n    // - each MusStaff object will then have its MusStaffAlignment pointer initialized\n    MusMeasureAligner *measureAlignerPtr = NULL;\n    double time = 0.0;\n    MusSystemAligner *systemAlignerPtr = NULL;\n    int staffNb = 0;\n    params.push_back( &measureAlignerPtr );\n    params.push_back( &time );\n    params.push_back( &systemAlignerPtr );\n    params.push_back( &staffNb );\n    MusFunctor align( &MusObject::Align );\n    this->Process( &align, params );\n    \n    // Set the X position of each MusAlignment\n    // Does a duration-based non linear spacing looking at the duration space between two MusAlignment objects\n    params.clear();\n    double previousTime = 0.0;\n    int previousXRel = 0;\n    params.push_back( &previousTime );\n    params.push_back( &previousXRel );\n    MusFunctor setAlignmentX( &MusObject::SetAligmentXPos );\n    // Special case: because we redirect the functor, pass is a parameter to itself (!)\n    params.push_back( &setAlignmentX );\n    this->Process( &setAlignmentX, params );\n    \n    // Render it for filling the bounding boxing\n    MusRC rc;\n    MusBBoxDC bb_dc( &rc, 0, 0 );\n    rc.SetDoc(doc);\n    rc.DrawPage(  &bb_dc, this, false );\n    \n    // Adjust the X shift of the MusAlignment looking at the bounding boxes\n    // Look at each MusLayerElement and changes the m_xShift if the bouding box is overlapping\n    params.clear();\n    int min_pos = 0;\n    int measure_width = 0;\n    params.push_back( &min_pos );\n    params.push_back( &measure_width );\n    MusFunctor setBoundingBoxXShift( &MusObject::SetBoundingBoxXShift );\n    MusFunctor setBoundingBoxXShiftEnd( &MusObject::SetBoundingBoxXShiftEnd );\n    this->Process( &setBoundingBoxXShift, params, &setBoundingBoxXShiftEnd );\n    \n    // Integrate the X bounding box shift of the elements\n    // Once the m_xShift have been calculated, move all positions accordingly\n    params.clear();\n    int shift = 0;\n    params.push_back( &shift );\n    MusFunctor integrateBoundingBoxXShift( &MusObject::IntegrateBoundingBoxXShift );\n    // special case: because we redirect the functor, pass is a parameter to itself (!)\n    params.push_back( &integrateBoundingBoxXShift );\n    this->Process( &integrateBoundingBoxXShift, params );\n    \n    // Adjust measure X position\n    params.clear();\n    shift = 0;\n    params.push_back( &shift );\n    MusFunctor alignMeasures( &MusObject::AlignMeasures );\n    MusFunctor alignMeasuresEnd( &MusObject::AlignMeasuresEnd );\n    this->Process( &alignMeasures, params, &alignMeasuresEnd );\n    \n    // Adjust the Y shift of the MusStaffAlignment looking at the bounding boxes\n    // Look at each MusStaff and changes the m_yShift if the bounding box is overlapping \n    params.clear();\n    int previous_height = 0;\n    params.push_back( &previous_height );\n    MusFunctor setBoundingBoxYShift( &MusObject::SetBoundingBoxYShift );\n    this->Process( &setBoundingBoxYShift, params );\n    \n    // Set the Y position of each MusStaffAlignment\n    // Adjusts the Y shift for making sure there is a minimal space (staffMargin) between each staff\n    params.clear();\n    int previousStaffHeight = 0; // 0 for the first staff, reset for each system (see MusSystem::SetAlignmentYPos)\n    int staffMargin = doc->m_rendStaffSize[0]; // the minimal space we want to have between each staff\n    int* interlineSizes = doc->m_rendInterl; // the interline sizes to be used for calculating the (previous) staff height\n    params.push_back( &previousStaffHeight );\n    params.push_back( &staffMargin );\n    params.push_back( &interlineSizes );\n    MusFunctor setAlignmentY( &MusObject::SetAligmentYPos );\n    // special case: because we redirect the functor, pass is a parameter to itself (!)\n    params.push_back( &setAlignmentY );\n    this->Process( &setAlignmentY, params );\n    \n    // Integrate the Y shift of the staves\n    // Once the m_yShift have been calculated, move all positions accordingly\n    params.clear();\n    shift = 0;\n    params.push_back( &shift );\n    MusFunctor integrateBoundingBoxYShift( &MusObject::IntegrateBoundingBoxYShift );\n    // special case: because we redirect the functor, pass is a parameter to itself (!)\n    params.push_back( &integrateBoundingBoxYShift );\n    this->Process( &integrateBoundingBoxYShift, params );\n    \n    // Adjust system Y position\n    params.clear();\n    shift = doc->m_rendPageHeight - doc->m_rendPageTopMar;\n    int systemMargin = doc->m_rendStaffSize[0];\n    params.push_back( &shift );\n    params.push_back( &systemMargin );\n    MusFunctor alignSystems( &MusObject::AlignSystems );\n    this->Process( &alignSystems, params );\n    \n    // Justify X position\n    params.clear();\n    double ratio = 0.0;\n    int systemFullWidth = doc->m_rendPageWidth - doc->m_rendPageLeftMar - doc->m_rendPageRightMar;\n    params.push_back( &ratio );\n    params.push_back( &systemFullWidth );\n    MusFunctor justifyX( &MusObject::JustifyX );\n    // special case: because we redirect the functor, pass is a parameter to itself (!)\n    params.push_back( &justifyX );\n    //this->Process( &justifyX, params );\n       \n    // Trim the page to the needed position\n    // LP I am not sure about this. m_pageHeight / Width should not be modified\n    /*\n    this->m_pageWidth = 0; // first resest the page to 0\n    this->m_pageHeight = doc->m_pageHeight;\n    params.clear();\n    \n    MusFunctor trimSystem(&MusObject::TrimSystem);\n    this->Process( &trimSystem, params );\n    */\n    \n    //rc.DrawPage(  &bb_dc, this , false );\n}\n\nvoid MusPage::SetValues( int type )\n{\n/* \n    int i;\n    std::string values;\n    for (i = 0; i < nbrePortees; i++) \n\t{\n        switch ( type ) {\n            case PAGE_VALUES_VOICES: values += Mus::StringFormat(\"%d;\", (&m_staves[i])->voix ); break;\n            case PAGE_VALUES_INDENT: values += Mus::StringFormat(\"%d;\", (&m_staves[i])->indent ); break;\n        }\n\t}\n    values = wxGetTextFromUser( \"Enter values for the pages\", \"\", values );\n    if (values.Length() == 0 ) {\n        return;\n    }\n    wxArrayString values_arr = wxStringTokenize(values, \";\");\n    for (i = 0; (i < nbrePortees) && (i < (int)values_arr.GetCount()) ; i++) \n\t{\n        switch ( type ) {\n            case PAGE_VALUES_VOICES: (&m_staves[i])->voix = atoi( values_arr[i].c_str() ); break;\n            case PAGE_VALUES_INDENT: (&m_staves[i])->indent = atoi( values_arr[i].c_str() ); break;\n        }\t\n\t}\n*/\n    Mus::LogDebug(\"TODO\");\n    return;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muspitchinterface.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"muspitchinterface.h\"\n\n//----------------------------------------------------------------------------\n// MusPitchInterface\n//----------------------------------------------------------------------------\n\nMusPitchInterface::MusPitchInterface()\n{\n    m_accid = 0;\n    m_oct = 0;\n    m_pname = 0;\n}\n\n\nMusPitchInterface::~MusPitchInterface()\n{\n}\n\nvoid MusPitchInterface::SetPitch(int pname, int oct) \n{\n    m_oct = oct;\n    m_pname = pname;\n}\n\nbool MusPitchInterface::GetPitch(int *pname, int *oct) \n{\n    *oct = m_oct;\n    *pname = m_pname;\n    return true;\n}\n\nbool MusPitchInterface::HasIdenticalPitchInterface( MusPitchInterface *otherPitchInterface )\n{\n    if ( !otherPitchInterface ) {\n        return false;\n    }\n    if ( this->m_accid != otherPitchInterface->m_accid ) {\n        return false;\n    }\n    if ( this->m_oct != otherPitchInterface->m_oct ) {\n        return false;\n    }\n    if ( this->m_pname != otherPitchInterface->m_pname ) {\n        return false;\n    }\n    return true;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        muspositioninterface.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"muspositioninterface.h\"\n\n//----------------------------------------------------------------------------\n\n#include \"musdef.h\"\n\n//----------------------------------------------------------------------------\n// MusPositionInterface\n//----------------------------------------------------------------------------\n\nMusPositionInterface::MusPositionInterface()\n{\n    m_oct = 5;\n    m_pname = PITCH_C;\n}\n\n\nMusPositionInterface::~MusPositionInterface()\n{\n}\n\nvoid MusPositionInterface::SetPosition(int pname, int oct) \n{\n    m_oct = oct;\n    m_pname = pname;\n}\n\nbool MusPositionInterface::GetPosition(int *pname, int *oct) \n{\n    *oct = m_oct;\n    *pname = m_pname;\n    return true;\n}\n\nbool MusPositionInterface::HasIdenticalPositionInterface( MusPositionInterface *otherPositionInterface )\n{\n    if ( !otherPositionInterface ) {\n        return false;\n    }\n    if ( this->m_oct != otherPositionInterface->m_oct ) {\n        return false;\n    }\n    if ( this->m_pname != otherPositionInterface->m_pname ) {\n        return false;\n    }\n    return true;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrc.cpp\n// Author:      Laurent Pugin\n// Created:     2010\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musrc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"musdoc.h\"\n#include \"muslayerelement.h\"\n#include \"musnote.h\"\n\n//----------------------------------------------------------------------------\n// MusRC\n//----------------------------------------------------------------------------\n\nMusRC::MusRC( )\n{\n\tm_doc = NULL;\n    m_page = NULL;\n\tm_npage = 0;\n\n\tm_currentColour = AxBLACK;\n\tm_currentElement = NULL;\n    m_currentLayer = NULL;\n    m_currentMeasure = NULL;\n\tm_currentStaff = NULL;\n    m_currentSystem = NULL;\n\n\tm_lyricMode = false;\n\tm_inputLyric = false;\n    m_editorMode = MUS_EDITOR_EDIT;\n\t//m_editorMode = MUS_EDITOR_INSERT;\n\t\n\tm_notation_mode = MUS_MENSURAL_MODE;\n    //m_notation_mode = MUS_CMN_MODE;\n\t\n\tm_str.reserve(1000);\n}\n\n\nMusRC::~MusRC()\n{\n}\n\nvoid MusRC::SetDoc( MusDoc *doc )\n{\n\tif ( doc == NULL ) // unset file\n\t{\n\t\tm_doc = NULL;\n\t\tm_page = NULL;\n        m_currentElement = NULL;\n        m_currentLayer = NULL;\n        m_currentMeasure = NULL;\n        m_currentStaff = NULL;\n        m_currentSystem = NULL;\n        DoReset();\n\t\treturn;\n\t}\n    else {\n        m_doc = doc;\n        //m_notation_mode = m_layout->m_env.m_notationMode;\n        m_npage = 0;\n        // for now we just get the first page\n        SetPage( (MusPage*)m_doc->m_children[m_npage] );\n        //CheckPoint( UNDO_ALL, MUS_UNDO_FILE ); // ax2\n    }\n}\n\n\nvoid MusRC::SetPage( MusPage *page )\n{\n\tassert( page ); // MusPage cannot be NULL\n    \n    m_doc->SetRendPage( page );\n\n\tm_page = page;\n\n\tm_currentElement = NULL;\n    m_currentLayer = NULL;\n    m_currentMeasure = NULL;\n\tm_currentStaff = NULL;\n    \n    /*\n\t// selectionne le premier element\n\tif ( m_page->GetSystemCount() > 0 ) \n    {\n\t\tm_currentSystem = m_page->GetFirst();\n    \tif ( m_currentSystem->GetStaffCount() > 0 ) \n        {\n            m_currentStaff = m_currentSystem->GetFirst();\n            if (m_currentStaff->GetLayerCount() > 0 ) \n            {\n                m_currentLayer = m_currentStaff->GetFirst();\n                if ( m_currentLayer->GetElementCount() > 0 ) \n                {\n                    m_currentElement = m_currentLayer->GetFirst();\n                }\n            }\n        }\n\t}\n    */\n\n    OnPageChange();\n    DoRefresh();\n}\n\nbool MusRC::HasNext( bool forward ) \n{ \n\tif ( forward )\n\t\treturn ( m_doc && ((int)m_doc->GetChildCount() - 1 > m_npage) );\n\telse\n\t\treturn ( m_doc && (m_npage > 0) );\n    return false;\n\t\t\n}\n\nvoid MusRC::Next( bool forward ) \n{ \n\tif ( !m_doc )\n        return;\n\n\tif ( forward && this->HasNext( true ) )\n\t\tm_npage++;\n\telse if ( !forward && this->HasNext( false ) )\n\t\tm_npage--;\n\n\tSetPage( (MusPage*)m_doc->m_children[m_npage] );\n}\n\nvoid MusRC::LoadPage( int nopage )\n{\n    /*\n\tif ( !m_doc )\n\t\treturn;\n\n\tif ((nopage < 0) || (nopage > m_fh->nbpage - 1))\n\t\treturn;\n\n\tm_npage = nopage;\n\tSetPage( &m_doc->m_pages[m_npage] );\n    */\n    Mus::LogDebug( \"MusRC::LoadPage missing in ax2\" );\n}\n\nint MusRC::ToRendererX( int i ) { return i; }; // the same\n\n/** x value in the Logical world */\nint MusRC::ToLogicalX( int i )  { return i; };\n\n/** y value in the Renderer */\nint MusRC::ToRendererY( int i )  \n{ \n    if (!m_doc) {\n        return 0;\n    }\n    \n    return m_doc->m_rendPageHeight - i; // flipped\n}\n\n/** y value in the Logical world  */\nint MusRC::ToLogicalY( int i )  \n{ \n    { \n        if (!m_doc) {\n            return 0;\n        }\n        \n        return m_doc->m_rendPageHeight - i; // flipped\n    }\n}\n\nbool MusRC::IsNoteSelected() \n{ \n\tif (!m_currentElement) \n\t\treturn false;\n\telse\n\t\treturn m_currentElement->IsNote() || m_currentElement->IsNeume();\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrc.h\n// Author:      Laurent Pugin\n// Created:     2010\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_RENDERER_H__\n#define __MUS_RENDERER_H__\n\n#include <typeinfo>\n\n#include \"musdc.h\"\n#include \"musdef.h\"\n#include \"musscoredef.h\"\n\nclass MusBeam;\nclass MusBarline;\nclass MusDoc;\nclass MusLayer;\nclass MusLayerElement;\nclass MusMeasure;\nclass MusPage;\nclass MusStaff;\nclass MusSystem;\nclass MusTie;\nclass MusTuplet;\n\n//----------------------------------------------------------------------------\n// MusRC\n//----------------------------------------------------------------------------\n\n/** \n * This class is a rendering context and corresponds to the view of a MVC design pattern.\n */\nclass MusRC\n{\npublic:\n    // constructors and destructors\n    MusRC();\n\tvirtual ~MusRC();\n\n\t// edition\n    virtual void OnBeginEdition() {}\n    virtual void OnEndEdition() {}\n    virtual void OnBeginEditionClef() {}\n    virtual void OnEndEditionClef() {}\n    virtual void DoRefresh() {}\n    virtual void DoResize() {}\n    virtual void DoLyricCursor( int x, int y, MusDC *dc, std::string lyric ) {}\n    virtual void DoReset() {}\n    virtual void OnPageChange() {};\n\n\t// navigation\n\tvoid Next( bool forward );\n\tbool HasNext( bool forward );\n\tvoid LoadPage( int nopage );\n\t\n\t// simply returns the value of the last note-type element (mensural or neume)\n\tbool GetNotationMode();\n\t\n\t// convenience method that should be changed after refactoring\n\tbool IsNoteSelected();\n\t    \n    void SetDoc( MusDoc *doc );\n    \n    /** x value in the Renderer */\n\tint ToRendererX( int i );\n\t/** x value in the Logical world */\n\tint ToLogicalX( int i );\n\t/** y value in the Renderer */\n\tint ToRendererY( int i );\n\t/** y value in the Logical world  */\n\tint ToLogicalY( int i );\n\t\n\tstatic void SwapY( int *y1, int *y2 ) { int tmp = *y1; *y1 = *y2; *y2 = tmp; }\n    \n    /**\n     * Set the current page to *page.\n     * This method is dangerous because it can potentially be a page that do not belong to the layout.\n     * It should be check (currently not done)\n     * A safer option would be to pass the page number.\n     */\n\tvoid SetPage( MusPage *page );\n\n\t/* musrc_graph.cpp */\n\tvoid v_bline ( MusDC *dc, int y1, int y2, int x1, int nbr);\n\tvoid v_bline2 ( MusDC *dc, int y1, int y2, int x1, int nbr);\n\tvoid h_bline ( MusDC *dc, int x1, int x2, int y1, int nbr);\n\tvoid festa_string ( MusDC *dc, int x, int y, const std::string str, \n\t\t\t\t\t   MusStaff *staff, int dimin ); \n\tvoid DrawLeipzigFont ( MusDC *dc, int x, int y, unsigned char c, \n\t\t\t\t  MusStaff *staff, bool dimin );\n    void DrawTieBezier(MusDC *dc, int x, int y, int x1, bool direction);\n\t//void putfontfast ( MusDC *dc, int x, int y, unsigned char c );\n\tvoid putstring ( MusDC *dc, int x, int y, std::string s, int centrer, int staffSize = 0);\n\tvoid putlyric ( MusDC *dc, int x, int y, std::string s, int staffSize = 0, bool cursor = false);\n\tvoid box( MusDC *dc, int x1, int y1, int x2, int y2);\n\tvoid rect_plein2( MusDC *dc, int x1, int y1, int x2, int y2);\n\tint hGrosseligne ( MusDC *dc, int x1, int y1, int x2, int y2, int decal);\n\tint DoDrawDot ( MusDC *dc, int x, int y );\n\t/* musrc_bezier.cpp */\n\tstatic int CC(int ,int );\n\tstatic long BBlend(int ,int ,long );\n\tstatic int InitBezier(int );\n\tstatic void Bezier(long *,long *,long ,int );\n\tstatic void calcBez ( MusPoint *ptcoord, int _nbint );\n\tstatic void pntswap (MusPoint *x1, MusPoint *x2);\n    \n    /* musrc_page.cpp */\n\tvoid DrawPage( MusDC *dc, MusPage *page, bool background = true );\n    void DrawSystem( MusDC *dc, MusSystem *system );\n\tvoid DrawScoreDef( MusDC *dc, MusScoreDef *scoreDef, MusMeasure *measure, int x, MusBarline *barline = NULL );\n\tvoid DrawStaffGrp( MusDC *dc, MusMeasure *measure, MusStaffGrp *staffGrp, int x );\n\tvoid DrawBracket ( MusDC *dc, int x, int y1, int y2, int staffSize);\n\tvoid DrawBrace ( MusDC *dc, int x, int y1, int y2, int staffSize);\n    void DrawBarlines( MusDC *dc, MusMeasure *measure, MusStaffGrp *staffGrp, int x, MusBarline *barline );\n    void DrawBarline( MusDC *dc, int x, int y_top, int y_bottom, MusBarline *barline );\n\tvoid DrawBarlineDots ( MusDC *dc, int x, MusStaff *staff, MusBarline *barline );\n\tvoid DrawPartialBarline ( MusDC *dc, MusSystem *system, int x, MusStaff *pportee);\n    void DrawMeasure( MusDC *dc, MusMeasure *measure, MusSystem *system );\n    void DrawStaff( MusDC *dc, MusStaff *staff, MusMeasure *measure, MusSystem *system );\n\tvoid DrawStaffLines( MusDC *dc, MusStaff *staff, MusMeasure *measure, MusSystem *system );\n    int CalculatePitchPosY ( MusStaff *staff, char pname, int dec_clef, int oct);\n\tint CalculateNeumePosY ( MusStaff *staff, char note, int dec_clef, int oct);\n    int CalculateRestPosY ( MusStaff *staff, char duration);\n    void DrawLayer( MusDC *dc, MusLayer *layer, MusStaff *staff,  MusMeasure *measure );\n    void DrawLayerList( MusDC *dc, MusLayer *layer, MusStaff *staff, MusMeasure *measure, const std::type_info *elementType );\n\tvoid DrawSlur( MusDC *dc, MusLayer *layer, int x1, int y1, int x2, int y2, bool up, int height = -1);\n    int CalculatePitchCode ( MusLayer *layer, int y_n, int x_pos, int *octave );\n    \n    /* musrc_element.cpp */\n    /** @name Methods for drawing MusLayerElement containing other elements */\n    ///@{\n    void DrawElement( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff );\n    void DrawBeamElement(MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff);\n    void DrawTupletElement( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff );\n    void DrawLayerApp( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff );\n    ///@}\n    \n    void DrawDurationElement( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawBarline( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );  \n    void DrawClef( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawMensur( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawFermata(MusDC *dc, MusLayerElement *element, MusStaff *staff);\n    void DrawMensurCircle( MusDC *dc, int x, int yy, MusStaff *staff );\n    void DrawMensurDot( MusDC *dc, int x, int yy, MusStaff *staff ); \n    void DrawMensurFigures( MusDC *dc, int x, int y, int num, int numBase, MusStaff *staff); \n    void DrawMensurHalfCircle( MusDC *dc, int x, int yy, MusStaff *staff );\n    void DrawMensurReversedHalfCircle( MusDC *dc, int x, int yy, MusStaff *staff ); \n    void DrawMensurSlash( MusDC *dc, int x, int yy, MusStaff *staff );\n    void DrawMultiRest( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawNote( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );  \n    void DrawRest( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawSymbol( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff, MusLayerElement *parent = NULL );\n    void DrawSymbolAccid( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawSymbolCustos( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawSymbolDot( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    void DrawTie( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff, MusMeasure *measure );\n    void DrawTuplet( MusDC *dc, MusTuplet *tuplet, MusLayer *layer, MusStaff *staff);\n    void DrawTrill(MusDC *dc, MusLayerElement *element, MusStaff *staff);\n    void DrawLigature( MusDC *dc, int y, MusLayerElement *element, MusLayer *layer, MusStaff *staff );  \n    void DrawLedgerLines( MusDC *dc, int y_n, int y_p, int xn, unsigned int smaller, int staffSize);\n    void DrawLongRest ( MusDC *dc, int a, int b, MusStaff *staff);\n    void DrawBreveRest ( MusDC *dc, int a, int b, MusStaff *staff);\n    void DrawWholeRest ( MusDC *dc, int a, int b, int valeur, unsigned char dots, unsigned int smaller, MusStaff *staff);\n    void DrawQuarterRest ( MusDC *dc, int a, int b, int valeur, unsigned char dots, unsigned int smaller, MusStaff *staff);\n    void DrawDots ( MusDC *dc, int x1, int y1, int offy, unsigned char dots, MusStaff *staff );\n    void CalculateLigaturePosX ( MusLayerElement *element, MusLayer *layer, MusStaff *staff);\n    void DrawAcciaccaturaSlash(MusDC *dc, MusLayerElement *element);\n    void DrawKeySig( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff );\n    /* musrc_beam.cpp */\n    void DrawBeam(  MusDC *dc, MusLayer *layer, MusBeam *beam, MusStaff *staff );\n    \nprivate:\n    \n    //Used for calculating tuplets\n    bool GetTupletCoordinates(MusTuplet* tuplet, MusLayer *layer, MusPoint* start, MusPoint* end, MusPoint *center);\n    std::string IntToObliqueFigures(unsigned int number);\n    bool OneBeamInTuplet(MusTuplet* tuplet);\n    \npublic:\n    /** Document */\n    MusDoc *m_doc;\n    /** Page affichee */\n    MusPage *m_page;\n    /** No Page affichee */\n    int m_npage;\n\n\tstd::string m_str;\n    \n\t// static\n\tstatic MusPoint point_[4];\n\tstatic MusPoint bcoord[2*(BEZIER_NB_POINTS+1)];\n\n    int m_currentColour;\n    \n    // element currently selected\n\tMusLayerElement *m_currentElement;\n    MusLayer *m_currentLayer;\n    MusMeasure *m_currentMeasure;\n\tMusStaff *m_currentStaff;\n    MusSystem *m_currentSystem;\n    \n\tint m_notation_mode; // neumes or mensural notation mode\n\tbool m_lyricMode;\n\tbool m_inputLyric;\n\tMusEditorMode m_editorMode; // Edit or insert\n    \nprivate:\n\n    // static for ligatures\n    static int s_drawingLigX[2], s_drawingLigY[2];\t// pour garder coord. des ligatures    \n    static bool s_drawingLigObliqua;\t// marque le 1e passage pour une oblique\n\n    MusScoreDef m_drawingScoreDef;\n    \n\n};\n\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\r\n// Name:        musrc_beam.cpp\r\n// Author:      Laurent Pugin\r\n// Created:     2005\r\n// Copyright (c) Author and others. All rights reserved.\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n#include \"musrc.h\"\r\n\r\n//----------------------------------------------------------------------------\r\n\r\n#include <algorithm>\r\n\r\n//----------------------------------------------------------------------------\r\n\r\n#include \"musbeam.h\"\r\n#include \"musdoc.h\"\r\n#include \"muslayer.h\"\r\n#include \"muslayerelement.h\"\r\n#include \"musnote.h\"\r\n#include \"musstaff.h\"\r\n\r\n//----------------------------------------------------------------------------\r\n\r\n#include <math.h>\r\n\r\n/*\r\n#define BEAMEDIT 50\t// code arbitraire identifiant la structure de debordement pour beams\r\ntypedef struct BeamEdit {\t\r\n    short iHauteur;\r\n    float fPente;\r\n} BeamEdit;\r\n*/\r\n//static BeamEdit BeamEd, *ptBeamEd;\r\n\r\n/*\r\nvoid traiteQueue (int *hautqueue, Element *chk)\r\n{\tptdebord = (Debord *)chk->pdebord;\r\n\tptdebord ++;\t// pointe sur valeurs\r\n\tptBeamEd = (BeamEdit *)ptdebord;\r\n\t*hautqueue += ptBeamEd->iHauteur;\r\n\treturn;\r\n}\r\n*/\r\n\r\n/* position x, pos. curseur yy, decalage y sous curseur, rayon de note;\r\n   collecte et calcule les donnees */\r\n\r\n#define NbFRACTURES 20\t\t/* nombre de '+' possibles */\r\n#define NbREL 80\t\t/* nombre de valeurs reliees possibles */\r\n#define MAX_MIF 20\t/* nombre max de sous-groupes de beams */\r\n\r\n\r\nstatic struct coord {  float a;\r\n\t\t\tfloat b;\r\n\t\t\tunsigned vlr: 8;\t/* valeur */\r\n\t\t\tunsigned prov: 8;\t/* ON si portee sup. */\r\n            MusLayerElement *chk;\r\n\t     } \tcrd[NbREL]; /* garde les coord.d'entree*/\r\n\r\n\r\nint calcBeam = 0;\r\n/**\r\n * This structure is used for calculating the beam internally.\r\n*/\r\nstruct MusBeamFlag {\tunsigned beam_chrd:3;\t/* retournee par beam() a input() */\r\n\t\tunsigned beamchrd:3;\t/* accord() et note() */\r\n\t\tunsigned inpt:1;\t/* usage in input(),beam(),accord() */\r\n\t\tunsigned markchrd:1;\t/* in beam() */\r\n        unsigned niaf:8;\r\n};\r\nstruct MusBeamFlag bch;\r\ndouble sy_up = 0.0;\r\nfloat hauteurBarreMoyenne = 3.0;\r\ndouble dA, dB;\r\nchar extern_q_auto = 0;\r\nchar extern_queue = 0;\r\n\r\n/* This need to be put into a beam class */\r\n\r\nvoid MusRC::DrawBeam(  MusDC *dc, MusLayer *layer, MusBeam *beam, MusStaff *staff )\r\n{\r\n    MusLayerElement *chk;\r\n\tstatic struct fb {\r\n\t\tunsigned _liaison : 1;\t/* temoin pour liaison: si ON, il y a\r\n\t\t\t\t\t\t\t   de la liaison dans l'air et beam doit\r\n\t\t\t\t\t\t\t   doit appeler liaison_note. Cfr.liais_note()*/\r\n\t\tunsigned mrq_port : 2;\t/* ON si changement in yy; necessaire\r\n\t\t\t\t\t\t\t\tpour decider beams lorsque 2 portees */\r\n\t\tunsigned mq_val   : 1;\t/* marqueur de changement de valeur*/\r\n\t\tunsigned fl_cond : 1;\t/* flags concernant partage portees */\r\n\t\tunsigned flsht    : 3;\t/* garde le pnt->_shport */\r\n\t\tunsigned dir\t  : 3;\t/* marqueur direction queues */\r\n\t\tunsigned _grp\t  : 1;\t/* marqueur de groupes rythmiques */\r\n\t}\tfb;\r\n\tint iHauteur=0;\r\n\tfloat fPente = 0.0;\r\n\tint ct;\t\t\t/* compteur d'entree */\r\n\tint _ct;\t\t/* compte d'entree moins 1 */\r\n\tint cpte_stop;\t/* compteur de st_rl */\r\n\tunsigned st_rl[NbFRACTURES];\t/* garde les ruptures de beams */\r\n\tint _yy[2];\t\t/* garde dernier yy pour test mrq_port*/\r\n\tstatic int _ybeam[NbREL];\t/* garde les sommets de queues  */\r\n\tint shortest, valref;\t/* garde valeur la plus breve\r\n\t\t\t\t* m_dur. de reference */\r\n\tdouble high;\r\n\tdouble low;\t\t/* gardent les y extremes */\r\n\tdouble dx[2];\t\t\t/* rayon / 2 */\r\n\tdouble y_moy;\t\t/* calcul de moyenne y pour dir */\r\n\tdouble s_x=0.0, s_y=0.0, s_xy=0.0, s_x2=0.0, s_y2=0.0;\t/* sommes pour la regress. */\r\n\tdouble xr;\t\t\t\t/* variables de travail */\r\n\tdouble delt_y, barre_y, ecart, y1;\r\n\tdouble sy_dec_moy, sy_dec[2];\r\n\tdouble fbarre_y;\r\n\tint mx_i[MAX_MIF], mx_f[MAX_MIF], my_i[MAX_MIF], my_f[MAX_MIF];\r\n\tchar m_i[MAX_MIF];\t/* pour stocker les prov des marqueurs */\r\n\tint fx1,fx2,fy1,fy2;\t\t/* coord. */\r\n\tfloat milieu;\r\n\r\n\tint i, j, t, h, k, si;\t\t/* compteurs de boucles */\r\n\tint _mif, decalage;\r\n\tint valtest;\t\t\t/* travail */\r\n\tint apax;\t \t/* test pour valeur breve isolee en debut  de groupes */\r\n\t//int provshp=0;\r\n\tint deltabar, deltanbbar, deltablanc;\r\n\r\n\tif (!calcBeam)\t/* eviter side-effect de circuit... */\r\n\t{\tfb._liaison = OFF;\r\n\t\tfb._grp = OFF;\t\t\t/* reinitialisation du test (static) */\r\n\t}\r\n\t\r\n    beam->ResetList( beam );\r\n    \r\n    // Should we assert this at the beginning?\r\n    if (beam->m_list.empty())\r\n        return;\r\n    \r\n    // chk point to the first Note in the layed out layer\r\n    chk = dynamic_cast<MusLayerElement*>(beam->m_list.front());\r\n    \r\n    //\tbch.markchrd = shortest = fb.mq_val = valref = ct = cpte_stop = fb.mrq_port = OFF;\r\n\tbch.markchrd = 0;\r\n\tshortest = 0;\r\n\tfb.mq_val = 0;\r\n\tvalref = ct = cpte_stop = 0;\r\n\tfb.mrq_port = OFF;\r\n\thigh = y_moy = sy_up = sy_dec_moy = 0.0;\r\n\tfor (i=0; i<NbFRACTURES; i++)\r\n\t\tst_rl[i] = 0;\r\n\t/***if (e_t->_shport) { provshp = e_t->_shport; shportee (0);}***/\r\n\t\t/* retablir a la fin si provshp existe */\r\n\r\n\tlow = chk->m_yDrawing + staff->m_yDrawing;\t/* initialiser */\r\n    k = ((MusNote*)chk)->m_colored ? ((MusNote*)chk)->m_dur+1 : ((MusNote*)chk)->m_dur;\r\n    \r\n\tvalref = k;\t\t/* m_dur test conservee */\r\n    //\tvalref = chk->m_dur;\t\t/* m_dur test conservee */\r\n\tfb.flsht = 0;\r\n\r\n\tif (staff->notAnc) {\r\n\t\tdx[0] = dx[1] = 0.0;\r\n    } \r\n    else\r\n    {\t\r\n        dx[0] =  m_doc->m_rendNoteRadius[staff->staffSize][0] - ((m_doc->m_rendNoteRadius[staff->staffSize][0] * m_doc->m_env.m_stemCorrection) / 20);\r\n        dx[1] =  m_doc->m_rendNoteRadius[staff->staffSize][1] - ((m_doc->m_rendNoteRadius[staff->staffSize][1] * m_doc->m_env.m_stemCorrection) / 20);\r\n        dx[0] -= (m_doc->m_env.m_stemWidth)/2;\r\n        dx[1] -= (m_doc->m_env.m_stemWidth)/2;\r\n    }\r\n\t_yy[0] = staff->m_yDrawing;\t\r\n\r\n    /***\r\n\tif (calcBeam)\t// eviter side-effect de circuit...\r\n\t{\textern_q_auto = chk->m_stemLen;\r\n\t\textern_queue =  chk->m_stemDir;\r\n\t}\r\n    ***/\r\n    \r\n    extern_q_auto = 1; //RZ was ((MusNote*)chk)->m_stemLen; bit it is always 0!\r\n    extern_queue =  ((MusNote*)chk)->m_stemDir;\r\n\r\n    ListOfMusObjects::iterator iter = beam->m_list.begin();\r\n    \r\n\tdo\r\n\t{\r\n        \r\n        //Mus::LogDebug(\"-> %s\", chk->MusClassName().c_str() );\r\n        \r\n        if ( chk->IsNote() ) {\r\n            k = ((MusNote*)chk)->m_colored ? ((MusNote*)chk)->m_dur+1 : ((MusNote*)chk)->m_dur;\r\n        }\r\n\r\n        // if (chk->type == NOTE && /*chk->sil == _NOT &&*/ k > DUR_4)\r\n\t\tif (k > DUR_4)\r\n        {\r\n\t\t\t(crd+ct)->chk = chk;\r\n\t\t\t/* garantir uniformite des flags */\r\n\r\n\t\t\tif (!calcBeam && chk->IsNote())\t/* on ne se limite pas au calcul des queues */\r\n\t\t\t{\t\r\n                ((MusNote*)chk)->m_stemLen = extern_q_auto;\r\n\t\t\t\tif (!extern_q_auto)\t((MusNote*)chk)->m_stemDir = extern_queue;\r\n\t\t\t\tif ( !fb._liaison && (((MusNote*)chk)->m_slur[0] & SLUR_TERMINAL)) {\r\n\t\t\t\t\tfb._liaison = ON;\r\n                }\r\n                /***if (chk->grp==END) {\t\r\n                    fb._grp = ON; \r\n                    group.fin = chk;\r\n                }***/\r\n\t\t\t}\r\n\t\t\t/***if (!fb.mrq_port && chk->_shport) {\r\n\t\t\t\tfb.mrq_port = chk->_shport;\r\n            }***/\r\n\r\n\t\t\t(crd+ct)->a = chk->m_xDrawing + chk->m_hOffset - m_doc->m_env.m_stemWidth / 2;\t\t/* enregistrement des coord. */\r\n\t\t\t(crd+ct)->vlr = k;\r\n\t\t\tif (chk->IsNote() && ((MusNote*)chk)->m_breakSec && ct)\r\n                /* enregistr. des ruptures de beaming; des la 2e note;(autrement idiot)*/\r\n\t\t\t\t*(st_rl + (cpte_stop++)) = ct;\r\n\r\n\t\t\t/***if (extern_q_auto && chk->chord)\r\n\t\t\t{\tbch.markchrd=ON;\r\n\t\t\t\tfb.flsht = fb.flsht ? fb.flsht : chk->_shport;\r\n\t\t\t}***/\r\n            if (chk->IsNote())\t// viter de prendre en compte silences\r\n            {\r\n                shortest = std::max(k,shortest);\r\n                if (!fb.mq_val && k != valref) fb.mq_val = ON; /* plus d'une valeur est presente*/\r\n                valref = std::min(k,valref);\r\n            }\r\n\t\t\tct++;\r\n\t\t}\r\n        \r\n        iter++;\r\n        if (iter == beam->m_list.end()) {\r\n            break;\r\n        }\r\n        \r\n        chk = dynamic_cast<MusLayerElement*>(*iter);\r\n\t\tif (chk == NULL) { \r\n            return;\r\n        }\r\n        \r\n\t}\twhile (1);\r\n\r\n    // SECURITE : EVITER DE BARRER UN ACCORD ISOLE...\r\n/*\tif (chk->IsNote() && (((MusNote*)chk)->m_chord & CHORD_TERMINAL)  && (chk->m_xDrawing == layer->beamListPremier->m_xDrawing))\r\n\t{\tchk = layer->beamListPremier;\r\n\t\tdo {\t\r\n                ((MusNote*)chk)->m_beam[0] = 0;\r\n\t\t\t\tchk = layer->GetNext(chk);\r\n\t\t\t}\twhile (chk && chk->IsNote() && !((MusNote*)chk)->m_chord & CHORD_TERMINAL);\r\n\t\tlayer->beamListPremier = NULL;\r\n\t\treturn;\r\n\t}\r\n*/\r\n    \r\n    //Mus::LogDebug(\"ct %d\", ct );\r\n\r\n\t_ct = ct - 1;\t\t/* compte d'entree moins 1 */\r\n\r\n\t/* ici, verifier la provenance (haut/bas) des queues en cas de\r\n\t\tpartage entre portees, et repasser la liste */\r\n    /***\r\n\tif (fb.mrq_port)\r\n\t// le y le plus haut est dans _yy[0] \r\n\t{\tif (fb.mrq_port==1)\r\n\t\t{\t_yy[0] = (this != phead) ? staff->ptr_pp->m_yDrawing : staff->m_yDrawing; \r\n\t\t\t_yy[1] = staff->m_yDrawing;\r\n\t\t}\r\n\t\telse\r\n\t\t{\t_yy[1] = (this != ptail) ? staff->ptr_fp->m_yDrawing : staff->m_yDrawing; \r\n\t\t\t_yy[0] = staff->m_yDrawing;\r\n\t\t}\r\n\t}\r\n    ***/\r\n\tfor (i = 0; i < ct; i++)\r\n\t{\tswitch (fb.mrq_port)\r\n\t\t{\tcase 0: crd[i].prov = OFF;\r\n\t\t\t\t\t(crd+i)->b = crd[i].chk->m_yDrawing+staff->m_yDrawing;\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase 1: if (crd[i].chk->m_staffShift)\r\n\t\t\t\t\t{\tcrd[i].prov = ON;\r\n\t\t\t\t\t\t(crd+i)->b = crd[i].chk->m_yDrawing + _yy[0];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\tcrd[i].prov = OFF;\r\n\t\t\t\t\t\t(crd+i)->b = crd[i].chk->m_yDrawing + _yy[1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase 2: if (crd[i].chk->m_staffShift)\r\n\t\t\t\t\t{\tcrd[i].prov = OFF;\r\n\t\t\t\t\t\t(crd+i)->b = crd[i].chk->m_yDrawing + _yy[1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\tcrd[i].prov = ON;\r\n\t\t\t\t\t\t(crd+i)->b = crd[i].chk->m_yDrawing + _yy[0];\r\n\t\t\t\t\t}\r\n\t\t}\r\n\t\thigh= std::max((double)(crd+i)->b,high);\t\t/* enregistrement des extremes */\r\n\t\tlow = std::min((double)(crd+i)->b,low);\r\n        /* lie au choix, plus bas, d'introduire l'accelerateur pour sy_up...\r\n        if ((crd+i)->b==high) highIndice = i;\r\n        if ((crd+i)->b==low) lowIndice = i;\r\n        */\r\n\t\ty_moy += crd[i].b;\r\n\t}\r\n    /***\r\n\tif (provshp)\r\n\t\tshportee (provshp);\r\n    ***/\r\n    \r\n\tif (ct<2) {\r\n        //layer->beamListPremier = NULL;\r\n\t\treturn;\t\t/* test erreur input */\r\n    }\r\n\r\n\r\n\tfb.dir = OFF;\r\n\tif (extern_q_auto && (!fb.mrq_port)) /*** || (bch.inpt && bch.markchrd))) ***/\r\n\t/* direction queues: auto = moyenne */\r\n\t/* bch.inpt: le flot de donnees a ete envoye par input et non rd_objet */\r\n\t{\t\r\n        milieu = _yy[0] - (m_doc->m_rendInterl[staff->staffSize] * 2);\r\n\t\ty_moy /= ct;\r\n\t\tif ( y_moy <  milieu )\r\n\t\t\tfb.dir = ON;\r\n\r\n\t\tif (bch.inpt && bch.markchrd)\r\n\t\t/* entree de input: de l'accord est dans l'air */\r\n\t\t{\tif (!fb.flsht)\r\n\t\t\t\treturn;  //(fb.dir+1);\r\n\t\t\telse\r\n\t\t\t\treturn; //(fb.flsht+2);\r\n\t/* ce sera la valeur de bch.beam_chrd retournee a input; beam() sera\r\n\t\trappelee par corrchrd() qui se sert de bch. ... */\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\tfb.dir = extern_queue;\t// si mrq_port, dir tjrs egal a m_stemDir\r\n\r\n    if (crd[_ct].chk->m_cueSize == false)\r\n    {\r\n        deltanbbar = m_doc->m_rendBeamWidth[staff->staffSize];\r\n        deltablanc = m_doc->m_rendBeamWhiteWidth[staff->staffSize];\r\n    }\r\n    else\r\n    {\tdeltanbbar = std::max(2, (m_doc->m_rendBeamWidth[staff->staffSize]/2));\r\n        deltablanc = std::max(2, (m_doc->m_rendBeamWhiteWidth[staff->staffSize]-1));\r\n    }\r\n\tdeltabar = deltanbbar + deltablanc;\r\n\r\n\r\n    /* Calcul des sommes et facteurs s_y, s_xy necessaires a la regression.\r\n    La regression se base sur les sommets des queues, calculs en ajoutant un\r\n    cart standard fonction de la valeur la plus breve enregistree. Direction\r\n    connue, donc ajout ou retrait de l'ecart, et correction du x d'origine en\r\n    fonction de la direction.*/\r\n\r\n    /***\r\n    if (crd[_ct].chk->existDebord)\r\n    {\tptdebord = (Debord *)chk->pdebord;\r\n        ptdebord ++;\t// pointe sur valeurs\r\n        ptBeamEd = (BeamEdit *)ptdebord;\r\n        iHauteur = ptBeamEd->iHauteur;\r\n        fPente = ptBeamEd->fPente;\r\n        BeamEd = *ptBeamEd;\r\n    }\r\n    else ***/\r\n    {\t\r\n        iHauteur = 0;\r\n        fPente = 0.0;\r\n    }\r\n\r\n    /***\r\n\tif (fb.mrq_port && extern_q_auto)\r\n\t// deux portees concernees (partage), en mode automatique \r\n\t{\tecart = e_t->m_doc->m_rendInterl[staff->staffSize]*6;\r\n\t\tfor (i=0; i<ct; i++)\r\n\t\t{\tif ((crd+i)->prov)\r\n\t\t\t{\t(crd+i)->a -= dx[crd[i].chk->dimin];\r\n\t\t\t\t*(_ybeam+i) = crd[i].b - ecart;\r\n\t\t\t\tcrd[i].chk->m_stemDir = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\t(crd+i)->a += dx[crd[i].chk->dimin];\r\n\t\t\t\t*(_ybeam+i) = crd[i].b + ecart;\r\n\t\t\t\tcrd[i].chk->m_stemDir = 1;\r\n\t\t\t}\r\n\t\t\ts_y += _ybeam[i];\r\n \t\t\ts_x += crd[i].a;\r\n\t\t\ts_x2 += crd[i].a * crd[i].a;\r\n\t\t\ts_xy += crd[i].a * _ybeam[i];\r\n\t\t}\r\n\t}\r\n\telse ***/\r\n    \r\n\t// une seule portee; on tient compte de la direction precedemment calculee*/\r\n\t{\t\r\n        ecart = ((shortest-DUR_8)*(deltabar));\r\n\r\n\t\tif (crd[_ct].chk->m_cueSize)\r\n\t\t\tecart += m_doc->m_rendHalfInterl[staff->staffSize]*5;\r\n\t\telse\r\n        //   Le 24 Septembre 1993: obtenir des DUR_8 reliees a la hauteur des separees \r\n\t\t\tecart += (shortest > DUR_8) ? m_doc->m_rendInterl[staff->staffSize]*hauteurBarreMoyenne : m_doc->m_rendInterl[staff->staffSize]*(hauteurBarreMoyenne+0.5);\r\n\r\n\t\tif (!fb.dir && !staff->notAnc)\r\n\t\t{\tdx[0] = - dx[0];\r\n\t\t\tdx[1] = - dx[1];\r\n\t\t}\r\n        /***\r\n        if (crd[_ct].chk->existDebord) {\r\n        ecart = m_doc->m_rendInterl[0]*2;\r\n            if (!fb.mrq_port) extern_q_auto= 0;\r\n        }\r\n        ***/\r\n\r\n\t\tecart = (fb.dir ? ecart : -ecart);\r\n\r\n\t\ty_moy += ecart;\r\n\t\tif (extern_q_auto && ((fb.dir && y_moy <  milieu) || (!fb.dir && y_moy > milieu)) )\r\n\t\t\tecart += milieu-y_moy;\r\n\r\n\t\tfor (i=0; i<ct; i++)\r\n\t\t{\t*(_ybeam+i) = crd[i].b + ecart;\r\n\t\t\t(crd+i)->a +=  dx[crd[i].chk->m_cueSize];\r\n\t\t\ts_y += _ybeam[i];\r\n \t\t\ts_y2 += _ybeam[i] * _ybeam[i];\r\n\t\t\ts_x += crd[i].a;\r\n\t\t\ts_x2 += crd[i].a * crd[i].a;\r\n\t\t\ts_xy += crd[i].a * _ybeam[i];\r\n            if ( crd[i].chk->IsNote() ) {\r\n                ((MusNote*)crd[i].chk)->m_stemDir = fb.dir;\r\n            }\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ty1 = ct * s_xy - s_x * s_y;\r\n\txr = ct * s_x2 - s_x * s_x;\r\n\r\n\tif (y1 && xr)\t// securite: eviter division par 0 si deux x identiques\r\n\t\tdB = y1 / xr;\r\n\telse\r\n\t\tdB = 0.0;\r\n\t/* Correction esthetique : */\r\n\tif (fabs(dB) < m_doc->m_rendBeamMinSlope ) dB = 0.0;\r\n\tif (fabs(dB) > m_doc->m_rendBeamMaxSlope ) dB = (dB>0) ? m_doc->m_rendBeamMaxSlope : - m_doc->m_rendBeamMaxSlope;\r\n\t/* pente correcte: entre 0 et env 0.4 (0.2 a 0.4) */\r\n\r\nif (fPente)\r\n\tdB += fPente;\r\n\r\n\tdA = (s_y - dB * s_x) / ct;\r\n\r\n\r\n\th = cpte_stop ? 1 : (!fb.mq_val ? (shortest - DUR_4) : 1); /***((fb.mrq_port && extern_q_auto)?(valref-DUR_4):1));***/\r\n\t\t/* nombre de barres a dessiner */\r\n\r\n\r\n\t/* flag condition: pour eviter tests complexes repetes in boucles;\r\n\t * concerne les cas de partages entre portees. Vrai si pas de stop-rel\r\n\t * (i.e. possibilite de plusieurs barres communes traversantes) */\r\n\r\n\tfb.fl_cond = OFF;\r\n\r\n    /***\r\n\tif (fb.mrq_port && extern_q_auto)\r\n\t\tfb.fl_cond = ON;\t// independamment de mq_val\r\n    ***/\r\n\r\n\tif (fb.fl_cond)\r\n\t/*valeur pour allonger queues si partage entre portees et mode autom.*/\r\n\t{\r\n\t\ti = deltabar * h - deltablanc;\t/* nombre de points de dec */\r\n\t\tj = i / 2;\r\n\t\tsy_dec[0] = j;\r\n\t\tsy_dec[1] = -sy_dec[0];\r\n\r\n\t\tif ( i % 2)\r\n\t\t\tsy_dec[1] -= 1;\r\n\t\tsy_dec_moy = sy_dec[0] + abs (sy_dec[1]);\r\n\t}\r\n\r\n    if (iHauteur)\r\n        dA += iHauteur;\r\n\r\n\t/* calcul du ybeam des queues */\r\n\tfor ( i=0; i<ct; i++ )\r\n\t{\txr = *(_ybeam+i);\t/* xr, variable de travail */\r\n\t\t*(_ybeam+i)= dA + sy_up + dB * crd[i].a;\r\n\t\tif (fb.fl_cond)\r\n\t\t\t*(_ybeam+i) += sy_dec [crd[i].prov];\r\n\t\t\r\n\t\t/* test pour garantir l'absence de recoupement */\r\n        if (!iHauteur)\r\n            if (!fb.mrq_port || !extern_q_auto)\r\n            {\tif ((fb.dir && xr > *(_ybeam+i)) || (!fb.dir && xr < *(_ybeam+i)))\r\n                {\tsy_up += xr - *(_ybeam+i);\r\n                    i = -1;\t/* on refait la boucle avec un sy_up */\r\n                }\r\n            }\t\r\n\r\n\r\n\t}\r\n\r\n\tif (calcBeam) return;\r\n\r\n\r\n\r\n\t/* dessin de la barre pilote et des queues */\r\n\r\n\tfor (i=0; i<ct; i++)\r\n\t{\r\n\t\tif (fb.fl_cond)\t/* esth: eviter que queues depassent barres */\r\n\t\t{\tif (crd[i].prov)\t/* venant du haut, m_stemDir en bas */\r\n\t\t\t{\t/***fy1 = *(_ybeam+i)+v_pnt;***/\t/* on raccourcit m_stemDir */\r\n\t\t\t\tfy2 = crd[i].b-m_doc->m_rendVerticalUnit2[staff->staffSize];\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\t/***fy1 = *(_ybeam+i)-e_t->v_pnt;***/\t/* on allonge m_stemDir */\r\n\t\t\t\tfy2 = crd[i].b+m_doc->m_rendVerticalUnit2[staff->staffSize];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\t// on tient compte de l'paisseur qui fait des \"bosses\"\r\n\t\t{\tif (fb.dir)\t// m_stemDir en haut\r\n\t\t\t{\tfy1 = *(_ybeam+i) - m_doc->m_env.m_stemWidth;\r\n\t\t\t\tfy2 = crd[i].b+m_doc->m_rendVerticalUnit2[staff->staffSize];\r\n                crd[i].chk->m_stem_start.x = crd[i].chk->m_stem_end.x = crd[i].a;\r\n                crd[i].chk->m_stem_start.y = fy2;\r\n                crd[i].chk->m_stem_end.y = fy1;\r\n                crd[i].chk->m_drawn_stem_dir = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\tfy1 = *(_ybeam+i) + m_doc->m_env.m_stemWidth;\r\n\t\t\t\tfy2 = crd[i].b-m_doc->m_rendVerticalUnit2[staff->staffSize];\r\n                crd[i].chk->m_stem_start.x = crd[i].chk->m_stem_end.x = crd[i].a;\r\n                crd[i].chk->m_stem_start.y = fy2;\r\n                crd[i].chk->m_stem_end.y = fy1;\r\n                crd[i].chk->m_drawn_stem_dir = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((crd+i)->chk->IsNote() && ((MusNote*)(crd+i)->chk)->m_headshape != SANSQUEUE)\r\n\t\t{\t\r\n            v_bline (dc,fy2, fy1, crd[i].a, m_doc->m_env.m_stemWidth);\r\n            \r\n// ICI, bon endroit pour enfiler les STACCATOS - ne sont traits ici que ceux qui sont opposs  la tte (les autres, in wgnote.cpp)\r\n\t\t\tif (((MusNote*)(crd+i)->chk)->m_artic\r\n\t\t\t\t && (!((MusNote*)(crd+i)->chk)->m_chord || (((MusNote*)(crd+i)->chk)->m_chord & CHORD_TERMINAL)))\r\n\t\t\t// les cas non traits par note()\r\n/*\t\t\t{\tif (fb.dir || (fb.mrq_port && m_stemLen && !crd[i].prov))\r\n\t\t\t\t\tputStacc (dc,crd[i].a-dx[crd[i].chk->dimin],fy1+e_t->m_doc->m_rendInterl[staff->staffSize]-staff->m_yDrawing, 0,crd[i].chk->typStac);\r\n\t\t\t\telse\r\n\t\t\t\t\tputStacc (dc,crd[i].a-dx[crd[i].chk->dimin],fy1-e_t->m_doc->m_rendInterl[staff->staffSize]-staff->m_yDrawing, -1,crd[i].chk->typStac);\r\n\t\t\t}\r\n*/\r\n\t\t\t{\t\r\n                /***if (fb.mrq_port && extern_q_auto)\r\n\t\t\t\t{\tif (crd[i].prov)\r\n\t\t\t\t\t\tputStacc (dc,crd[i].a+dx[crd[i].chk->dimin],fy1-e_t->m_doc->m_rendInterl[staff->staffSize]-staff->m_yDrawing, -1,crd[i].chk->typStac);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tputStacc (dc,crd[i].a-dx[crd[i].chk->dimin],fy1+e_t->m_doc->m_rendInterl[staff->staffSize]-staff->m_yDrawing, 0,crd[i].chk->typStac);\r\n\t\t\t\t}\r\n\t\t\t\telse if (fb.dir)\r\n\t\t\t\t\tputStacc (dc,crd[i].a-dx[crd[i].chk->dimin],fy1+e_t->m_doc->m_rendInterl[staff->staffSize]-staff->m_yDrawing, 0,crd[i].chk->typStac);\r\n\t\t\t\telse\r\n\t\t\t\t\tputStacc (dc,crd[i].a-dx[crd[i].chk->dimin],fy1-e_t->m_doc->m_rendInterl[staff->staffSize]-staff->m_yDrawing, -1,crd[i].chk->typStac);\r\n                ***/\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n    // NOUVEAU\r\n    // Correction des positions x extremes en fonction de l'paisseur des queues\r\n\t(*crd).a -= (m_doc->m_env.m_stemWidth-1) / 3;\r\n\t(crd+_ct)->a += (m_doc->m_env.m_stemWidth-1) / 3;\r\n\r\n\tdelt_y = (!fb.dir || fb.fl_cond ) ? 1.0 : -1.0;\r\n\t/* on choisit une direction pour faire le premier paquet horizontal */\r\n\r\n\tfy1 = *_ybeam; fy2 = *(_ybeam+_ct);\r\n\r\n\r\n\tif (fb.fl_cond)\r\n    /* reequilibrage du tir horizontal: on aligne les beams sur les queues\r\n        qui ont ete allongees selon leur direction pour couvrir l'epaisseur */\r\n\r\n\t{\r\n\t\tif (!crd[0].prov) fy1 -=  sy_dec_moy;\r\n\t\tif (!crd[_ct].prov) fy2 -= sy_dec_moy;\r\n\t}\r\n\r\n\tfx1 = (*crd).a; fx2 = (crd+_ct)->a;\r\n\r\n\r\n\t/* dessin des barres supplementaires jusqu'a concurrence de la valeur\r\n\t *  minimum commune a tout le groupe: i.e. une seule s'il y a des \"stoprel\"\r\n\t *  (fragmentation de beaming), ou sinon valref (ou h).\r\n\t*/\r\n\t/* chk->cone est le flag des cones d'acc. et ralent. */\r\n\t//s_y = crd[0].chk->cone ? 0.0 : delt_y; // removed in ax2\r\n\t//s_y2 = (crd+_ct)->chk->cone ? 0.0 : delt_y; // removed in ax2\r\n\ts_y = delt_y; // removed in ax2\r\n\ts_y2 = delt_y; // removed in ax2\r\n\r\n\tfor (j=0; j<h ; j++)\r\n\t{\r\n\t\tdecalage = hGrosseligne (dc,fx1,fy1,fx2,fy2, deltanbbar*delt_y /***, workColor2***/);\r\n\t\tfy1 += decalage; fy2 += decalage;\r\n\r\n/* ici, redescendre  de l'epaisseur de la barre s'il y a accele */\r\n\t\tif (!s_y)\r\n\t\t\tfy1 += (deltanbbar * delt_y) * -1;\r\n\t\telse\r\n\t\t\tfy1 += s_y*deltablanc;\r\n\t\tif (!s_y2)\r\n\t\t\tfy2 += (deltanbbar * delt_y) * -1;\r\n\t\telse\r\n\t\t\tfy2 += s_y2*deltablanc;\r\n\t}\r\n\r\n\t/* calcul des x en cas de beaming multiple */\r\n\t/* parcours horizontal ajoutant barres en fonction de m_dur la plus \r\n\tbreve (shortest), controle par boucle while; la premiere boucle for\r\n\tcontrole le nombre d'etapes horizontales du parcours (par le nombre\r\n\tde commandes '+' enregistrees); la deuxieme boucle for teste pour\r\n\tchaque paquet entre deux '+' les valeurs; elle construit une array de \r\n\tmarqueurs partitionnant les sous-groupes; la troisieme boucle for est\r\n\tpilotee par l'indice de l'array; elle dessine horizontalement les barres \r\n\tde chaque sous-groupe en suivant les marqueurs */ \r\n\r\n \r\n\t/* cpte_stop=0 ? pas de rupture de beaming*/\r\n\r\n    if (fb.mq_val || cpte_stop)\t/* deuxieme partie du test */\r\n    {\r\n        valtest = DUR_8 + h;\r\n\r\n        if ( fb.fl_cond )\r\n        {\tbarre_y = deltablanc + sy_dec_moy;\r\n            /* = decalage entre bout de m_stemDir et position acquise des barres */\r\n        }\r\n        else\t/* pas de partage entre portees */\r\n\r\n            barre_y = deltabar;\r\n\r\n        /* h contient nombre de barres communes deja dessinees */\r\n        if (fb.dir)\t/* queues ascendantes: on descend */\r\n            barre_y = -barre_y;\r\n\r\n        while (valtest <= shortest)\r\n        {\tt = 0; si = 0;\r\n            for (i=0; i<=cpte_stop; i++)\t/* 1e boucle for */\r\n            {\th = (*(st_rl+si) ? *(st_rl+si) : ct);\r\n                /* var. test controlant 2e boucle for suivante\r\n                 * en fonction du compteur de \"+\" */\r\n    /*ici, t=j, i.e. increment des pos. de notes. On s'occupe maintenant de\r\n    l'ensemble des valeurs contenues dans un groupe marque par cpte_stop. C'est\r\n    la qu'il faut changer les signes des valeurs delta d'increment vertical.*/\r\n\r\n                for(k=0; k<MAX_MIF; k++)\t/* initialisation*/\r\n                {\tmx_i[k]=my_i[k]=mx_f[k]=my_f[k]=0;}\r\n\r\n                for (j=t,_mif=0,m_i[_mif]=0; j < h; j++)\t/* 2e boucle. */\r\n                {\t/* j<h : st_rl est trop loin de un cran */\r\n\r\n                /* Ici, dcision si SILENCE doit ou non avoir des barres; si oui, ligne\r\n                    suivante (condition: il doit etre pris aussi dans les crd plus haut):*/\r\n                    if (((crd+j)->vlr) >= (unsigned int)valtest)\t\r\n                /*\tsi NON, alors: */\r\n                    // if (((crd+j)->vlr) >= valtest && (crd+j)->chk->sil == _NOT)\t\r\n                    {\r\n                        /*place marqueurs pour m_dur.egales/superieures\r\n                         * a valtest en cours */\r\n                        mx_f[_mif] = crd[j].a; \r\n                        my_f[_mif] = *(_ybeam+j);\r\n                        if(!mx_i[_mif])\r\n                        {\tmx_i[_mif] = crd[j].a;\r\n                            my_i[_mif] = *(_ybeam+j);\r\n                            if (!_mif) apax = j;\r\n                            if (!crd[j].prov)\r\n                            /* enregistre les cas ou delta y est neg.*/\r\n                                m_i[_mif] = 1;\r\n                        }\r\n                    }\r\n                    /* rupture de chaine: on passe a un 2e groupe\r\n                     * de marqueurs */\r\n                    else if(mx_i[_mif])\r\n                    {\t_mif++;\t/*incr. s'il y a un marq.*/\r\n                        m_i[_mif] = 0;\r\n                    }\r\n                }\r\n\r\n                fbarre_y = barre_y;\t/* stockage */\r\n                for (k=0; k<=std::min((mx_f[_mif]?_mif:(_mif-1)),MAX_MIF); k++)\r\n                {\r\n                    /* \"constantes\" de corr. definissant origine du calcul des\r\n                     * y, dans les cas de partage entre portees automatiques;\r\n                     * (construction anterieure en montant si fl_cond) */\r\n                    if ( fb.fl_cond)\r\n                    {\tbarre_y = abs(fbarre_y); delt_y = abs (delt_y);\r\n\r\n                        if (m_i[k])\t\t/* i.e. portee inf. (!crd[j].prov) */\r\n                        {\tbarre_y = -barre_y;\r\n                            delt_y = -delt_y;\r\n                            sy_up = sy_dec[0];\t/* valeur positive */\r\n                        }\r\n\r\n                        else\r\n                            sy_up = sy_dec[1];\t/* valeur negative */\r\n\r\n                    }\r\n\r\n\r\n                    /* on passe en revue, horizontalement, les marqueurs\r\n                     * enregistres pour ce  groupe, en s'assurant que le\r\n                     * max MAX_MIF n'est pas depasse */\r\n                    if (mx_i[k] == mx_f[k])\t\t/* une seule position concernee */\r\n                    {\r\n                        if (apax == t && k==0 && mx_i[k] != crd[_ct].a)\t/* au debut du paquet */\r\n                        {\tfy1 = my_i[k] + barre_y;\r\n                            mx_f[k] = mx_i[k] + m_doc->m_rendLedgerLine[staff->staffSize][0];\r\n                            fy2 = dA + sy_up + barre_y + dB * mx_f[k];\r\n\r\n                            decalage= hGrosseligne (dc,mx_i[k],fy1,mx_f[k],fy2,deltanbbar*delt_y /***, workColor2***/ );\r\n                            fy1 += decalage; fy2 += decalage;\r\n\r\n                        }\r\n                        else\t\t/* corps ou fin de paquet */\r\n                        {\tfy2 = my_i[k] + barre_y;\r\n                            mx_i[k] -= m_doc->m_rendLedgerLine[staff->staffSize][0];\r\n                            fy1 = dA + sy_up + barre_y + dB * mx_i[k];\r\n                            decalage= hGrosseligne (dc,mx_i[k],fy1,mx_f[k],fy2,deltanbbar*delt_y /***,workColor2***/);\r\n                            fy1 += decalage; fy2 += decalage;\r\n\r\n                        }\r\n                    }\r\n                    else if (mx_i[k])\t\t/* s'il y a un marqueur */\r\n                    {\tfy1 = my_i[k] + barre_y;\r\n                        fy2 = my_f[k] + barre_y;\r\n                        decalage= hGrosseligne (dc,mx_i[k],fy1,mx_f[k],fy2,deltanbbar*delt_y /***,workColor2***/);\r\n                        fy1 += decalage; fy2 += decalage;\r\n\r\n                    }\t\t\t\t\r\n                }\t/* fin de boucle testant sous-ensembles marques _mif*/\r\n\r\n                if ( fb.fl_cond)\t/* retablissement des valeurs positives */\r\n                {\tbarre_y = abs(fbarre_y);\r\n                    delt_y =  abs(delt_y);\r\n                }\r\n\r\n                if (*st_rl)\r\n                {\tsi++; t = j;} \r\n                else t = 0;\r\n            }\t\t\t/* fin de premiere boucle for */\r\n\r\n            valtest += 1;\t/* increments de valeur et d'espace */\r\n            barre_y += delt_y*deltabar;\r\n        }\t\t\t/* fin de boucle while */\r\n    }\t\t\t\t/*fermeture de la deuxieme partie du test */\r\n\r\n\t/***beamPremier = layer->beamListPremier;***/\r\n\t//layer->beamListPremier = NULL; RZ COMMENTED\r\n\r\n    /***\r\n\tif (fb._grp)\t// group.fin)\r\n\t{\te_t->rel = OFF; \r\n\t\trythmeInf(dc);\r\n\t}\r\n    ***/\r\n\r\n\r\n\tif (fb._liaison)\r\n\t\treturn;\t\r\n\r\n/*\t1111, code retourne pour appeler liais_note (NULL) apres beam(): on\r\n    evite ainsi le risque d'appel recursif de beam. C'est le code de la\r\n\t liaison \"retardee\": la direction des\r\n\tqueues n'etait pas encore connue de liais_note lorsque la liaison a\r\n\tete demandee, puisqu' elle est calculee (en mode automatique) par\r\n\tla presente fonction (et placee dans le bit m_stemDir); le code NULL\r\n\tpermet un test d'association avec variable \"attente\" in\r\n\tliais_note (attente est engendree par coincidence rel && m_stemLen inter-\r\n\tdisant le choix de la direction de liaison); ainsi NULL && attente \r\n\tpermettent d'entrer dans l'algoritme */ \r\n\r\n\treturn;\t\r\n}\t\t\t\t/* fermeture de la fonction */\r\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrc_bezier.cpp\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musrc.h\"\n\n/** static members **/\nMusPoint MusRC::point_[];\nMusPoint MusRC::bcoord[];\n \nvoid MusRC::pntswap (MusPoint *x1, MusPoint *x2)\n{\tMusPoint a;\n\ta = *x1;\n\t*x1 = *x2;\n\t*x2 = a;\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrc_element.cpp\n// Author:      Laurent Pugin and Chris Niven\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musrc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <sstream>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musapp.h\"\n#include \"musbarline.h\"\n#include \"musbeam.h\"\n#include \"musclef.h\"\n#include \"musdoc.h\"\n#include \"muskeysig.h\"\n#include \"muslayerelement.h\"\n#include \"musleipzigbbox.h\"\n#include \"musmeasure.h\"\n#include \"musmensur.h\"\n#include \"musmultirest.h\"\n#include \"musnote.h\"\n#include \"musrest.h\"\n#include \"mussymbol.h\"\n#include \"musstaff.h\"\n#include \"mussystem.h\"\n#include \"mustie.h\"\n#include \"mustuplet.h\"\n\n//----------------------------------------------------------------------------\n// MusRC - MusLayerElement\n//----------------------------------------------------------------------------\n\nint MusRC::s_drawingLigX[2], MusRC::s_drawingLigY[2];\t// pour garder coord. des ligatures    \nbool MusRC::s_drawingLigObliqua = false;\t// marque le 1e passage pour une oblique\n\nvoid MusRC::DrawElement( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    \n    int previousColor = m_currentColour;\n\n    if (element == m_currentElement) {\n\t\tm_currentColour = AxRED;\n    }\n    else {\n        m_currentColour = AxBLACK;\n    }\n    \n    // Here we set the appropriate x value to be used for drawing\n    // With Raw documents, we use m_xRel that is calculated by the layout algorithm\n    // With Transcription documents, we use the m_xAbs\n    if ( element->m_xAbs == AX_UNSET ) {\n        assert( m_doc->GetType() == Raw );\n        //element->m_xDrawing = element->m_xRel + measure->m_xDrawing;\n        //element->m_xDrawing = element->m_xRel + measure->GetXRel();\n        element->m_xDrawing = element->GetXRel() + measure->m_xDrawing;\n    }\n    else\n    {\n        assert( m_doc->GetType() == Transcription );\n        element->m_xDrawing = element->m_xAbs;\n    }\n    \n    if (dynamic_cast<MusBarline*>(element)) {\n        DrawBarline(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusBeam*>(element)) {\n        DrawBeamElement(dc, element, layer, measure, staff);\n    }\n    else if (dynamic_cast<MusClef*>(element)) {\n        DrawClef(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusKeySig*>(element)) {\n        DrawKeySig(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusMensur*>(element)) {\n        DrawMensur(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusMultiRest*>(element)) {\n        DrawMultiRest(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusNote*>(element)) {\n        DrawDurationElement(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusRest*>(element)) {\n        DrawDurationElement(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusSymbol*>(element)) {\n        DrawSymbol(dc, element, layer, staff);\n    }\n    else if (dynamic_cast<MusTie*>(element)) {\n        DrawTie(dc, element, layer, staff, measure);\n    } \n    else if (dynamic_cast<MusTuplet*>(element)) {\n        DrawTupletElement(dc, element, layer, measure, staff);\n    }\n    else if (dynamic_cast<MusLayerApp*>(element)) {\n        DrawLayerApp(dc, element, layer, measure, staff);\n    }\n    \n    m_currentColour = previousColor;\n}\n\nvoid MusRC::DrawDurationElement( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n\n    MusDurationInterface *durElement = dynamic_cast<MusDurationInterface*>(element);\n\tif ( !durElement )\n\t\treturn;\n        \n\t\n    if (dynamic_cast<MusNote*>(element)) \n    {\n        MusNote *note = dynamic_cast<MusNote*>(element);\n        int oct = note->m_oct - 4;\n        \n        //if ( !m_lyricMode && BelongsToTheNote( m_currentElement ) ) // the current element is a lyric that belongs to the note we are drawing\n        //    m_currentColour = AxCYAN;\n            \n        dc->StartGraphic( element, \"note\", element->GetUuid() );\n        element->m_yDrawing = CalculatePitchPosY( staff, note->m_pname, layer->GetClefOffset( element ), oct );\n        \n        if (!note->m_chord) // && (!pelement->ElemInvisible || illumine))\n        {\t\n            DrawNote(dc, element, layer, staff);\n        //else \n        //{\n            //\tnote->accord(dc, staff);\n        }\n        dc->EndGraphic(element, this );\n\t}\n    else if (dynamic_cast<MusRest*>(element)) {\n        MusRest *rest = dynamic_cast<MusRest*>(element);\n        int oct = rest->m_oct - 4;\n\n        dc->StartGraphic( element, \"rest\", element->GetUuid() );\n        //if (!transp_sil)\n\t\t//\tpnote->code = getSilencePitch (pelement);\n        \n        // Automatically calculate rest position, if so requested\n        if (rest->m_pname == REST_AUTO)\n            element->m_yDrawing = CalculateRestPosY( staff, rest->m_dur);\n        else\n            element->m_yDrawing = CalculatePitchPosY( staff, rest->m_pname, layer->GetClefOffset( element ), oct);\n\t\t\n        DrawRest( dc, element, layer, staff );\n        dc->EndGraphic(element, this );\n\t}\n    \n\t/* \n\tfor ( int i = 0; i < (int)m_lyrics.GetCount(); i++ ){\n\t\tMusSymbol1 *lyric = &m_lyrics[i];\n\t\t\n\t\tif ( lyric != NULL )\n\t\t{\n            if ( lyric == m_currentElement )\n                m_currentColour = AxRED;\n            else if ( (this == m_currentElement) || BelongsToTheNote( m_currentElement ) )\n                m_currentColour = AxCYAN;\n\n\t\t\tputlyric(dc, lyric->m_xDrawing + staff->m_xDrawing, staff->m_yDrawing + lyric->dec_y , \n\t\t\t\t\t\t  lyric->m_debord_str, staff->staffSize, ( lyric == m_currentElement && m_inputLyric ) );\n\t\t}\t\t\n\t}\n    */ // ax2 lyrics\n\t\n\treturn;\n}\n\nvoid MusRC::DrawBeamElement(MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff) {\n    \n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    \n    MusBeam *beam = dynamic_cast\n    <MusBeam*>(element);\n\n    dc->StartGraphic( element, \"beam\", element->GetUuid() );\n    \n    for (unsigned int i = 0; i < beam->m_children.size(); i++) {\n        if ( dynamic_cast<MusLayerElement*>(beam->m_children[i]) ) {\n            MusLayerElement *element = dynamic_cast<MusLayerElement*>(beam->m_children[i]);\n            DrawElement(dc, element, layer, measure, staff);\n        }\n    }\n    \n    // Add to the list of postponed element \n    layer->AddToDrawingList( beam );\n    \n    dc->EndGraphic(element, this );\n}\n\nvoid MusRC::DrawTupletElement(MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff) {\n    \n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    \n    MusTuplet *tuplet = dynamic_cast<MusTuplet*>(element);\n    \n    dc->StartGraphic( element, \"tuplet\", element->GetUuid() );\n    \n    // Draw the inner elements\n    for (unsigned int i = 0; i < tuplet->m_children.size(); i++) {\n        if ( dynamic_cast<MusLayerElement*>(tuplet->m_children[i]) ) {\n            MusLayerElement *element = dynamic_cast<MusLayerElement*>(tuplet->m_children[i]);\n            DrawElement(dc, element, layer, measure, staff);\n        }\n    }\n    \n    // Add to the list of postponed element\n    layer->AddToDrawingList( tuplet );\n    \n    dc->EndGraphic(element, this );\n}\n\n// dessine la note en a,b+by. Calcule et dessine lignes addit. avec by=m_yDrawing\n// b = decalage en fonction oct., clef, a partir du curseur; by = pos. curs.\n// Accords: note doit connaitre le x non modifie par accord(), la fin de \n// l'accord (ptr_n->fchord), la valeur y extreme opposee au sommet de la\n// queue: le ptr *testchord extern peut garder le x et l'y.\n\n\nvoid MusRC::DrawNote ( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff)\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusNote*>(element)); // Element must be a MusNote\"\n    \n    MusNote *note = dynamic_cast<MusNote*>(element);\n    \n    bool inBeam = (note->GetFirstParent( &typeid( MusBeam ) ) != NULL );\n    \n\tint staffSize = staff->staffSize;\n\n\t//\tint horphyspoint=h_pnt;\n\tint b = element->m_yDrawing;\n\tint up=0, i, valdec, fontNo, ledge, queueCentre;\n\tint x1, x2, y2, espac7, decval, vertical;\n\tint formval = 0;\t// pour permettre dessiner colorations avec dcalage de val\n\tint rayon, milieu = 0;\n\n\tint xn = element->m_xDrawing, xl = element->m_xDrawing;\n\tint bby = staff->m_yDrawing;  // bby= y sommet portee\n\tint ynn = element->m_yDrawing + staff->m_yDrawing; \n\tstatic int ynn_chrd;\n\n\txn += note->m_hOffset;\n\t//val=note->m_dur;\n\tformval = (note->m_colored && note->m_dur > DUR_1) ? (note->m_dur+1) : note->m_dur;\n\tqueueCentre = 0;\n\n\n\trayon = m_doc->m_rendNoteRadius[staffSize][note->m_cueSize];\n\n\tif (note->m_dur > DUR_1 || (note->m_dur == DUR_1 && staff->notAnc))\t// annuler provisoirement la modif. des lignes addit.\n\t\tledge = m_doc->m_rendLedgerLine[staffSize][note->m_cueSize];\n\telse\n\t{\t\n        ledge= m_doc->m_rendLedgerLine[staffSize][2];\n\t\trayon += rayon/3;\n\t}\n\n\t/*NEW: diminuer le rayon d'une quantit paramtrable*/\n\tif (note->m_dur > DUR_1)\n\t\trayon -= ((rayon * m_doc->m_env.m_stemCorrection) / 20);\n\tx1 = xn-rayon;\t// position d'appel du caractre et de la queue gauche\n    xl = xn;\n\n\t// permettre d'inverser le cot de la tete de note avec flag lat\n\t/*if (this->lat && !this->chord)\n\t{\tif (this->queue)\n\t\t{\tx1 = xn + rayon;\n\t\t\txl = xn + rayon * 2;\n\t\t}\n\t\telse\n\t\t{\tx1 = xn - rayon * 3;\n\t\t\txl = xn - rayon * 2;\n\t\t}\n\t}*/ // ax2 - not support of lat\n\n\tDrawLedgerLines( dc, ynn, bby, xl, ledge, staffSize);\t// dessin lignes additionnelles\n\n\tif (note->m_dur == DUR_LG || note->m_dur == DUR_BR || ((note->m_lig) && note->m_dur == DUR_1))\t// dessin carrees\n\t{\n\t\tDrawLigature ( dc, ynn, element, layer, staff);\n \t}\n\telse if (note->m_dur==DUR_1)\n\t{\t\n        if ( is_in (note->m_headshape, LOSANGEVIDE, OPTIONLIBRE))\n\t\t\tfontNo = LEIPZIG_OFFSET_NOTE_HEAD+note->m_headshape;\n\t\telse if (note->m_colored) // && !note->m_ligObliqua) // in WG, use of obliq for coloration? \n\t\t\tfontNo = LEIPZIG_HEAD_WHOLE_FILLED;\n\t\telse\n\t\t\tfontNo = LEIPZIG_HEAD_WHOLE;\n\n\t\tDrawLeipzigFont( dc, x1, ynn, fontNo, staff, note->m_cueSize );\n\t\tdecval = ynn;\n\t}\n\telse\n\t{\t\n        if ( is_in (note->m_headshape, LOSANGEVIDE, OPTIONLIBRE))\n\t\t\tfontNo = LEIPZIG_OFFSET_NOTE_HEAD+note->m_headshape;\n\n\t\telse if (note->m_colored || formval == DUR_2)\n\t\t\tfontNo = LEIPZIG_HEAD_HALF;\n\t\telse\n\t\t\tfontNo = LEIPZIG_HEAD_QUARTER;\n\n\t\tDrawLeipzigFont( dc,x1, ynn, fontNo, staff, note->m_cueSize );\n\n\t\tmilieu = bby - m_doc->m_rendInterl[staffSize]*2;\n\n// test ligne mediane pour direction queues: notation mesuree, milieu queue haut\n\t\tif (staff->notAnc)\n\t\t\tmilieu +=  m_doc->m_rendHalfInterl[staffSize];\n\n\t\tif (note->m_chord) { /*** && this == testchord)***/\n\t\t\tynn_chrd = ynn;\n        }\n\t\tif (inBeam && formval > DUR_4)\n        {\n            // no stem\n\t\t}\n\t\telse if (note->m_headshape != SANSQUEUE && (!note->m_chord || (note->m_chord==CHORD_TERMINAL))) {\t\n            if (note->m_chord==CHORD_TERMINAL) {\t\n\t\t\t\t/***up = testchord->obj.not.haste;\n\t\t\t\txn = testchord->m_xDrawing;***/\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//***up = this->q_auto ? ((ynn < milieu)? ON :OFF):this->queue;\n\t\t\t\t// ENZ\n\t\t\t\tup = (ynn > milieu) ? ON : OFF;\n            }\n\t\t\t\n\t\t\t// ENZ\n\t\t\tif ( note->m_stemDir != 0 ) {\n\t\t\t\tup = (up == ON) ? OFF : ON;\n            }\n\t\t\t\n\t\t\tespac7 = note->m_cueSize ? ( m_doc->m_rendHalfInterl[staffSize]*5) : ( m_doc->m_rendHalfInterl[staffSize]*7);\n\t\t\tvertical = note->m_cueSize ?  m_doc->m_rendHalfInterl[staffSize] :  m_doc->m_rendInterl[staffSize];\n\t\t\tdecval = vertical * (valdec = formval-DUR_8);\n\t\t\t\n\t\t\t/***if (this->existDebord)\t// queue longueur manuelle\n\t\t\t\ttraiteQueue (&espac7, this);***/\n\n\t\t\t// diminuer le rayon de la moitie de l'epaisseur du trait de queue\n\t\t\trayon -= (m_doc->m_env.m_stemWidth) / 2;\n\n\t\t\tif (!up) {\t// si queue vers le bas (a gauche)\n\t\t\t\tespac7 = -espac7;\n\t\t\t\tdecval = -decval;\n\t\t\t\trayon = -rayon;\n\t\t\t}\n\n\t\t\ty2 = ((formval>DUR_8) ? (ynn + espac7 + decval) : (ynn + espac7));\n\n\t\t\tif ((note->m_chord==CHORD_INITIAL) || (note->m_chord==CHORD_MEDIAL)) {\n\t\t\t\tynn = ynn_chrd;\n            }\n\n\t\t\t/***if (this->q_auto)\n\t\t\t{\tthis->queue = (up > 0);\n\t\t\t\tif ( (y2 >= milieu && ynn > milieu) || (y2 <= milieu && ynn < milieu) )\n\t\t\t\t// note et queue du meme cote par rapport au centre de la portee\n\t\t\t\t{\ty2 = milieu;\n\t\t\t\t\tqueueCentre = 1;\n\t\t\t\t}\n\t\t\t}***/\n\n\t\t\tif (staff->notAnc)\n\t\t\t\trayon = 0;\n\t\t\tx2 = xn + rayon;\n\n\t\t\tif (up)\n\t\t\t{\n\t\t\t\tif (formval > DUR_8 && !queueCentre)\n\t\t\t\t// Le 24 Septembre 1993. Correction esthetique pour rapprocher tailles \n\t\t\t\t//   des DUR_8 et DUR_16 (longeur de queues trop inegales).\n\t\t\t\t\ty2 -= m_doc->m_rendHalfInterl[staffSize];\n\t\t\t\tdecval = y2;\n\t\t\t\tif (staff->notAnc)\n\t\t\t\t\tv_bline ( dc,y2,(int)(ynn + m_doc->m_rendHalfInterl[staffSize]),x2, m_doc->m_env.m_stemWidth );//queue en descendant\n\t\t\t\telse\n\t\t\t\t\tv_bline ( dc,y2,(int)(ynn+ m_doc->m_rendVerticalUnit2[staffSize]),x2 - (m_doc->m_env.m_stemWidth / 2), m_doc->m_env.m_stemWidth );//queue en descendant\n                \n                element->m_stem_start.x = element->m_stem_end.x = x2 - (m_doc->m_env.m_stemWidth / 2);\n                element->m_stem_end.y = y2;\n                element->m_stem_start.y = (int)(ynn+ m_doc->m_rendVerticalUnit2[staffSize]);\n                element->m_drawn_stem_dir = true;\n                \n\t\t\t\tif (formval > DUR_4)\n\t\t\t\t{\n                    y2 += m_doc->m_env.m_stemWidth / 2; // ENZO correction empirique...\n\t\t\t\t\tDrawLeipzigFont( dc,x2,y2,LEIPZIG_STEM_FLAG_UP, staff, note->m_cueSize );\n\t\t\t\t\tfor (i=0; i < valdec; i++)\n\t\t\t\t\t\tDrawLeipzigFont( dc,x2,y2-=vertical,LEIPZIG_STEM_FLAG_UP, staff, note->m_cueSize );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{                \n\t\t\t\tif (formval > DUR_8 && !queueCentre)\n\t\t\t\t// Le 24 Septembre 1993. Correction esthetique pour rapprocher tailles \n\t\t\t\t//   des DUR_8 et DUR_16 (longeur de queues trop inegales).\n\t\t\t\t\ty2 += m_doc->m_rendHalfInterl[staffSize];\n\t\t\t\tdecval = y2;\n\n\t\t\t\tif (staff->notAnc)\n\t\t\t\t\tv_bline ( dc,y2,ynn- m_doc->m_rendHalfInterl[staffSize],x2 - (m_doc->m_env.m_stemWidth / 2), m_doc->m_env.m_stemWidth );//queue en descendant\n\t\t\t\telse\n\t\t\t\t\tv_bline ( dc,y2,(int)(ynn- m_doc->m_rendVerticalUnit2[staffSize]),x2 - (m_doc->m_env.m_stemWidth / 2), m_doc->m_env.m_stemWidth );\t// queue en montant\n\n                element->m_stem_start.x = element->m_stem_end.x = x2 - (m_doc->m_env.m_stemWidth / 2);\n                element->m_stem_start.y = (int)(ynn- m_doc->m_rendVerticalUnit2[staffSize]);\n                element->m_stem_end.y = y2;\n                element->m_drawn_stem_dir = false;\n                \n\t\t\t\t// ENZ\n\t\t\t\t// decalage du crochet vers la gauche\n\t\t\t\t// changement dans la fonte Leipzig 4.3  cause de problemes d'affichage\n\t\t\t\t// en de de 0 avec la notation ancienne\n\t\t\t\t// dans la fonte les crochets ont ete decales de 164 vers la droite\n\t\t\t\tint cr_offset = m_doc->m_rendNoteRadius[staffSize][note->m_cueSize]  + (m_doc->m_env.m_stemWidth / 2);\n\t\t\t\tif (formval > DUR_4)\n\t\t\t\t{\n                    y2 -= m_doc->m_env.m_stemWidth / 2; // ENZO correction empirique...\n\t\t\t\t\tDrawLeipzigFont( dc,x2 - cr_offset,y2,LEIPZIG_STEM_FLAG_DOWN , staff, note->m_cueSize );\n\t\t\t\t\tfor (i=0; i < valdec; i++)\n\t\t\t\t\t\tDrawLeipzigFont( dc,x2  - cr_offset,y2+=vertical,LEIPZIG_STEM_FLAG_DOWN, staff, \n\t\t\t\t\t\t\t\t\t note->m_cueSize );\n\t\t\t\t}\n\t\t\t}\n            if (note->m_cueSize && note->m_acciaccatura)\n                DrawAcciaccaturaSlash(dc, element);\n\t\t}\t// fin de dessin queues et crochets\n\n\t}\n    \n\tDrawLedgerLines( dc, ynn, bby, xl, ledge, staffSize);\n\n\tif (note->m_slur[0])\n\t{\t\n        if (note->m_slur[0]==SLUR_TERMINAL)\n\t\t{\t/***liaison = OFF;\t// pour tests de beam...\n\t\t\tliais_note(hdc, this);***/\n\t\t}\n\t\t/***if (this->dliai && !attente)\tpremierLie = this;***/\n\t}\n    \n\tif (note->m_accid) // && !this->accInvis) // ax2 no support invisible accidental yet\n\t{\n\t\tif (note->m_chord)\n            {}/***x1 = x_acc_chrd (this,0);***/\n\t\telse\n\t\t\tx1 -= 1.5 * m_doc->m_rendAccidWidth[staffSize][note->m_cueSize];\n\t\tMusSymbol accid( SYMBOL_ACCID );\n        accid.m_oct = note->m_oct;\n        accid.m_pname = note->m_pname;\n\t\taccid.m_accid = note->m_accid;\n        accid.m_xDrawing = x1;\n        DrawSymbol( dc, &accid, layer, staff, element ); // ax2\n\t}\n\tif (note->m_chord)\n\t{\t\n        /***x2 = testchord->m_xDrawing + m_doc->m_rendStep2;\n\t\tif (this->haste)\n\t\t{\tif (this->lat || (this->ptr_fe && this->ptr_fe->type==NOTE && this->ptr_fe->obj.not.lat)\n\t\t\t\t|| (this->ptr_pe && element->m_xDrawing==this->ptr_pe->m_xDrawing && this->ptr_pe->type==NOTE && this->ptr_pe->obj.not.lat\n\t\t\t\t\t&& this->dec_y - this->ptr_pe->dec_y < m_doc->m_rendInterl[staffSize]\n\t\t\t\t\t&& 0 != ((int)b % (int)m_doc->m_rendInterl[staffSize]))\n\t\t\t\t)\n\t\t\t\tx2 += m_doc->m_rendNoteRadius[staffSize][dimin] * 2;\n\t\t}*///\n\t}\n\telse\n\t{\tif (note->m_dur < DUR_2 || (note->m_dur > DUR_8 && !inBeam && up))\n\t\t\tx2 = xn + m_doc->m_rendStep1*7/2;\n\t\telse\n\t\t\tx2 = xn + m_doc->m_rendStep1*5/2;\n\n\t\t//if (this->lat) // ax2 - no support of note head flip\n        //    x2 += rayon*2;\n\t}\n\n\tif (note->m_dots) // && (!this->pointInvisible)) // ax2 - no support of invisible dots yet\n\t{\n\t\tDrawDots( dc,x2,b, 0, note->m_dots, staff );\n\t}\n/*\n\tif (this->stacc && (!this->rel || !this->queue_lig))\n\t{\n\t\tif (!this->chord || ((!this->queue_lig && this == testchord) || (this->queue_lig && this->fchord )))\n\t\t{\n\t\t\tif (val > DUR_BR)\n\t\t\t{\tif  (!this->queue_lig)\n\t\t\t\t{\tif ((this->queue && !this->chord) || (this->chord && this->haste))\n\t\t\t\t\t{\tb -= m_doc->m_rendInterl[staffSize];\n\t\t\t\t\t\tdecval = -m_doc->m_rendInterl[staffSize];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tb += m_doc->m_rendInterl[staffSize];\n\t\t\t\t\t\tdecval = 0;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse\t// tous les cas inverss par queue_lig\n\t\t\t\t{\tb = decval-staff->m_yDrawing;\n\t\n\t\t\t\t\tif ((!this->queue && !this->chord) || (this->chord && !this->haste))\n\t\t\t\t\t{\tb -= m_doc->m_rendInterl[staffSize];\n\t\t\t\t\t\tdecval = -1;\n\t\t\t\t\t\tif (val <= DUR_1)\n\t\t\t\t\t\t\tdecval = -m_doc->m_rendInterl[staffSize];\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\tb += m_doc->m_rendHalfInterl[staffSize];\n\t\t\t\t\t\tdecval = 0;\n\t\t\t\t\t\tif (val <= DUR_1)\n\t\t\t\t\t\t\tb += m_doc->m_rendHalfInterl[staffSize];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn;\n\t\t\tputStacc (hdc,xn,b,decval,this->typStac);\n\t\t}\n\t}\n*/\n\t\n\t//temp debug code\n//\tm_currentColour = wxCYAN;\n//\trect_plein2(dc, element->m_xDrawing - 3, ynn - 3, element->m_xDrawing + 3, ynn + 3);\n//\tMus::LogDebug(\"xrel: %d, ynn: %d\", element->m_xDrawing, ynn);\n//\tm_currentColour = wxBLACK;\n\t//temp debug code\n    \n    \n    // Add the ties to the postponed drawing list\n    if ( note->GetTieAttrInitial() ) {\n        // normally, we add the tie from the terminal note,\n        // however, when the notes are not on the same system (or page),\n        // we need to draw them twice. For this reason, we look if the\n        // parent system is the same or not. If not, we also add to the list\n        // the tie from the inital note\n        MusNote *noteTerminal = note->GetTieAttrInitial()->GetSecondNote();\n        if ( noteTerminal ) {\n            MusSystem *parentSystem1 = dynamic_cast<MusSystem*>( note->GetFirstParent( &typeid(MusSystem) ) );\n            MusSystem *parentSystem2 = dynamic_cast<MusSystem*>( noteTerminal->GetFirstParent( &typeid(MusSystem) ) );\n            if ( (parentSystem1 != parentSystem2) && parentSystem1 ) {\n                layer->AddToDrawingList( note->GetTieAttrInitial() );\n            }\n        }\n    }\n    if ( note->GetTieAttrTerminal() ) {\n        layer->AddToDrawingList( note->GetTieAttrTerminal() );\n    }\n\n\t\n\n    if (note->m_fermata)\n        DrawFermata(dc, element, staff);\n\n    if (note->m_embellishment == EMB_TRILL)\n        DrawTrill(dc, element, staff);\n    \n\treturn;\n}\n\n\nvoid MusRC::DrawRest ( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\t\n    assert(layer); // Pointer to layer cannot be NULL\n    assert(staff); // Pointer to staff cannot be NULL\n    assert(dynamic_cast<MusRest*>(element)); // Element must be a MusRest\n        \n    MusRest *rest = dynamic_cast<MusRest*>(element);\n\n\tint formval = rest->m_dur;\n\tint a = element->m_xDrawing + rest->m_hOffset;\n    int b = element->m_yDrawing;\n\n\t//unsigned char dot = this->point;\n\t/*if (inv_val && (!this->oblique && formval > DUR_1 || this->oblique && formval > DUR_2))\n\t\tformval += 1;*/ // ax2 - no support of inv_val for rest - need to use @dur.ges\n\n\tif (rest->m_dur == VALSilSpec) // WG multi-rest? \n    {\n\t\tformval = DUR_1;\n    }\n\telse if (formval > DUR_2)\n    {\n\t\ta -= m_doc->m_rendNoteRadius[staff->staffSize][rest->m_cueSize];\n    }\n\n\tif (formval == DUR_BR || formval == DUR_2) \n    {\n\t\tb -= 0; //m_doc->m_rendInterl[staff->staffSize]; // LP position des silences\n    }\n\n\tif (formval == DUR_1)\n\t{\t\n        if (staff->portNbLine == 1) {\n\t\t// silences sur portee a une seule ligne\n\t\t\tb += m_doc->m_rendInterl[staff->staffSize];\n\t\t}\n        else\n        {\n\t\t\t//b += m_doc->m_rendInterl[staff->staffSize]*2; \n\t\t\tb -= 0; //m_doc->m_rendInterl[staff->staffSize]*2;// LP positions des silences\n        }\n\t}\n\n\tif (rest->m_dur == VALSilSpec && rest->m_multimeasure_dur > 1) // LP: not sure what is actually does...\n    {\n        Mus::LogError(\"Tried to set multi meausure in rest\\n\");\n    }\n\telse\n\t{\t\n        switch (formval)\n\t\t{\t\n            case DUR_LG: DrawLongRest ( dc, a, b, staff); break;\n\t\t\tcase DUR_BR: DrawBreveRest( dc, a, b, staff); break;\n\t\t\tcase DUR_1:\n\t\t\tcase DUR_2: DrawWholeRest ( dc, a, b, formval, rest->m_dots, rest->m_cueSize, staff); break;\n\t\t\t//case CUSTOS: s_nr ( dc, a, b - m_doc->m_rendHalfInterl[staff->staffSize] + 1, '#' - LEIPZIG_REST_QUARTER + DUR_4 , staff); break; // Now in MusSymbol\n\t\t\tdefault: DrawQuarterRest( dc, a, b, formval, rest->m_dots, rest->m_cueSize, staff);\n\t\t}\n\t}\n    \n    if(rest->m_fermata)\n        DrawFermata(dc, element, staff);\n    \n\treturn;\n}\n\n\nvoid MusRC::DrawLedgerLines( MusDC *dc, int y_n, int y_p, int xn, unsigned int smaller, int staffSize)\n{\n\tint yn, ynt, yh, yb, test, v_decal = m_doc->m_rendInterl[staffSize];\n\tint dist, xng, xnd;\n\tregister int i;\n\n\n\tyh = y_p + m_doc->m_rendHalfInterl[staffSize];\n    yb = y_p - m_doc->m_rendStaffSize[staffSize]- m_doc->m_rendHalfInterl[staffSize];\n\n\tif (!is_in(y_n,yh,yb))                           // note hors-portee?\n\t{\n\t\txng = xn - smaller;\n\t\txnd = xn + smaller;\n\n\t\tdist = ((y_n > yh) ? (y_n - y_p) : y_p - m_doc->m_rendStaffSize[staffSize] - y_n);\n  \t\tynt = ((dist % m_doc->m_rendInterl[staffSize] > 0) ? (dist - m_doc->m_rendHalfInterl[staffSize]) : dist);\n\t\ttest = ynt/ m_doc->m_rendInterl[staffSize];\n\t\tif (y_n > yh)\n\t\t{\tyn = ynt + y_p;\n\t\t\tv_decal = - m_doc->m_rendInterl[staffSize];\n\t\t}\n\t\telse\n\t\t\tyn = y_p - m_doc->m_rendStaffSize[staffSize] - ynt;\n\n\t\t//hPen = (HPEN)SelectObject (hdc, CreatePen (PS_SOLID, _param.EpLignesPORTEE+1, workColor2));\n\t\t//xng = toZoom(xng);\n\t\t//xnd = toZoom(xnd);\n\n        dc->SetPen( m_currentColour, ToRendererX( m_doc->m_env.m_staffLineWidth ), AxSOLID );\n        dc->SetBrush(m_currentColour , AxTRANSPARENT );\n\n\t\tfor (i = 0; i < test; i++)\n\t\t{\n\t\t\tdc->DrawLine( ToRendererX(xng) , ToRendererY ( yn ) , ToRendererX(xnd) , ToRendererY ( yn ) );\n\t\t\t//h_line ( dc, xng, xnd, yn, _param.EpLignesPORTEE);\n\t\t\t//yh =  toZoom(yn);\n\t\t\t//MoveToEx (hdc, xng, yh, NULL);\n\t\t\t//LineTo (hdc, xnd, yh);\n\n\t\t\tyn += v_decal;\n\t\t}\n\n        dc->ResetPen();\n        dc->ResetBrush();\n\t}\n\treturn;\n}\n\n/** This function draws multi-measure rests\n **/\n#define NUMBER_REDUCTION 5\nvoid MusRC::DrawMultiRest(MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff)\n{\t\n    int x, x2, y, y2, length;\n\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusMultiRest*>(element)); // Element must be a MusSymbol\"\n    \n    MusMultiRest *multirest = dynamic_cast<MusMultiRest*>(element);\n    dc->StartGraphic( element, \"multirest\", element->GetUuid() );\n    \n    int a = element->m_xDrawing + multirest->m_hOffset;\n    \n    // We do not support more than three chars\n    if (multirest->GetNumber() > 999)\n        multirest->SetNumber(999);\n    \n    // This is 1/2 the length of th black rectangle\n\tlength = (m_doc->m_rendStep1 * 5);\n    \n    // Position centered in third line\n    // it would be m_rendInterl * 6.5, or m_rendInterl / 2 * 13\n\ty = staff->m_yDrawing - (m_doc->m_rendInterl[staff->staffSize] / 2) * 5;\n    y2 = y + m_doc->m_rendInterl[staff->staffSize];\n\t\n    // a is the central point, claculate x and x2\n    x = a - length;\n    x2 = a + length;\n    \n    // Draw the base rect\n    // make it 8 pixels smaller than the interline space\n    // these are the two 4 substracted and added\n\trect_plein2(dc, x, y2 - 4, x2, y + 4);\n    \n    //Draw the to lines at beginning and end\n    // make it 8 pixesl longers, and 4 pixels width\n    v_bline(dc, y - 4, y2 + 4, x, 4);\n    v_bline(dc, y - 4, y2 + 4, x2, 4);\n    \n    // Draw the text above\n    int w, h;\n    unsigned int start_offset = 0; // offset from x to center text\n    \n    // convert to string\n    std::stringstream text;\n    text << multirest->GetNumber();\n    \n    dc->GetTextExtent( text.str(), &w, &h);\n    start_offset = (x2 - x - w) / 2; // calculate offset to center text\n    \n    putstring(dc, x + start_offset, staff->m_yDrawing + 5, text.str(), false);\n    \n    dc->EndGraphic(element, this);\n    \n    return;\n\n}\n\nvoid MusRC::DrawLongRest ( MusDC *dc, int a, int b, MusStaff *staff)\n\n{\tint x, x2, y = b + staff->m_yDrawing, y2;\n\n\tx = a; //- m_doc->m_rendStep1/3; \n\tx2 = a+ (m_doc->m_rendStep1 *2 / 3); // LP\n\tif (b % m_doc->m_rendInterl[staff->staffSize])\n\t\ty -= m_doc->m_rendHalfInterl[staff->staffSize];\n\ty2 = y + m_doc->m_rendInterl[staff->staffSize]*2;\n\trect_plein2( dc,x,y2,x2,y);\n\treturn;\n}\n\n\nvoid MusRC::DrawBreveRest ( MusDC *dc, int a, int b, MusStaff *staff)\n\n{\tint x, x2, y = b + staff->m_yDrawing, y2;\n\n\tx = a; //- m_doc->m_rendStep1/3; \n\tx2 = a+ (m_doc->m_rendStep1 *2 / 3); // LP\n\n\tif (b % m_doc->m_rendInterl[staff->staffSize])\n\t\ty -= m_doc->m_rendHalfInterl[staff->staffSize];\n\ty2 = y + m_doc->m_rendInterl[staff->staffSize];\n\trect_plein2 ( dc,x,y2,x2,y);\n\tx = a - m_doc->m_rendStep1; x2 = a + m_doc->m_rendStep1;\n\n\th_bline ( dc, x,x2,y2,1);\n\th_bline ( dc, x,x2,y, 1);\n\treturn;\n}\n\nvoid MusRC::DrawWholeRest ( MusDC *dc, int a, int b, int valeur, unsigned char dots, unsigned int smaller, MusStaff *staff)\n\n{\tint x, x2, y = b + staff->m_yDrawing, y2, vertic = m_doc->m_rendHalfInterl[staff->staffSize];\n\tint off;\n\tfloat foff;\n\n\tif (staff->notAnc)\n\t\tfoff = (m_doc->m_rendStep1 *1 / 3);\n\telse\n\t\tfoff = (m_doc->m_rendLedgerLine[staff->staffSize][2] * 2) / 3; // i.e., la moitie de la ronde\n\n\tif (smaller)\n\t\tfoff *= (int)( (float)m_doc->m_rendGraceRatio[0] / (float)m_doc->m_rendGraceRatio[1] );\n\toff = (int)foff;\n\n\tx = a - off;\n\tx2 = a + off;\n\n\tif (valeur == DUR_1)\n\t\tvertic = -vertic;\n\n\tif (b % m_doc->m_rendInterl[staff->staffSize])\n\t{\n\t\tif (valeur == DUR_2)\n\t\t\ty -= vertic;\n\t\telse\n\t\t\ty += vertic;\n\t}\n\n\ty2 = y + vertic;\n\trect_plein2 ( dc, x,y,x2,y2);\n\n\toff /= 2;\n\tx -= off;\n\tx2 += off;\n\n\tif (y > (int)staff->m_yDrawing  || y < (int)staff->m_yDrawing - m_doc->m_rendStaffSize[staff->staffSize])\n\t\th_bline ( dc, x, x2, y, m_doc->m_env.m_staffLineWidth);\n\n\tif (dots)\n\t\tDrawDots ( dc,(x2 + m_doc->m_rendStep1), y2, -(int)staff->m_yDrawing, dots, staff);\n}\n\n\nvoid MusRC::DrawQuarterRest ( MusDC *dc, int a, int b, int valeur, unsigned char dots, unsigned int smaller, MusStaff *staff)\n{\n\tint _intrl = m_doc->m_rendInterl[staff->staffSize];\n\n\tDrawLeipzigFont( dc, a, (b + staff->m_yDrawing), LEIPZIG_REST_QUARTER + (valeur-DUR_4), staff, smaller );\n\n\t//DrawLeipzigFont( dc, a, (b + staff->m_yDrawing - m_doc->m_rendHalfInterl[staff->staffSize]), '#', staff, note->m_cueSize);\n\n\tif (dots)\n\t{\tif (valeur >= DUR_16)\n\t\t\t_intrl = 0;\n\t\tDrawDots ( dc, (a+ m_doc->m_rendStep2), b, _intrl, dots, staff);\n\t}\n\treturn;\n}\n\n\nvoid MusRC::DrawDots ( MusDC *dc, int x1, int y1, int offy, unsigned char dots, MusStaff *staff )\n\n{\n\ty1 += offy + staff->m_yDrawing;\n    if ((y1 % (int)m_doc->m_rendInterl[staff->staffSize]) == 0) {\n        y1 += m_doc->m_rendHalfInterl[staff->staffSize];\n    }\n    \n\tint i;\n\tfor (i = 0; i < dots; i++) {\n\t\tDoDrawDot ( dc, x1, y1);\n\t\tx1 += std::max (6, 2 * m_doc->m_rendStep1);\n\t}\n\treturn;\n}\n\n\n\nvoid MusRC::CalculateLigaturePosX ( MusLayerElement *element, MusLayer *layer, MusStaff *staff)\n{\n\tif (element == NULL) \n    {\n    \treturn;\n    }\n    MusLayerElement *previous = layer->GetPrevious(element);\n\tif (previous == NULL || !previous->IsNote()) \n    {\n        return;\n    }\n    MusNote *previousNote = dynamic_cast<MusNote*>(previous);\n    if (previousNote->m_lig==LIG_TERMINAL)\n    {\n        return;\n    } \n\tif (previousNote->m_lig && previousNote->m_dur <= DUR_1)\n\t{\t\n        element->m_xDrawing = previous->m_xDrawing + m_doc->m_rendBrevisWidth[staff->staffSize] * 2;\n\t}\n    return;\n}\n\nvoid MusRC::DrawLigature ( MusDC *dc, int y, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\t\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusNote*>(element)); // Element must be a MusNote\"\n    \n    MusNote *note = dynamic_cast<MusNote*>(element);\n    \n\n\tint xn, x1, x2, yy2, y1, y2, y3, y4, y5;\n\tint milieu, up, epaisseur;\n\n\tepaisseur = std::max (2, m_doc->m_rendBeamWidth[staff->staffSize]/2);\n\txn = element->m_xDrawing;\n\t\n\tif ((note->m_lig==LIG_MEDIAL) || (note->m_lig==LIG_TERMINAL))\n    {\n\t\tCalculateLigaturePosX ( element, layer, staff );\n    }\n\telse {\n\t\txn = element->m_xDrawing + note->m_hOffset;\n    }\n\n\n\t// calcul des dimensions du rectangle\n\tx1 = xn - m_doc->m_rendBrevisWidth[staff->staffSize]; x2 = xn +  m_doc->m_rendBrevisWidth[staff->staffSize];\n\ty1 = y + m_doc->m_rendHalfInterl[staff->staffSize]; \n\ty2 = y - m_doc->m_rendHalfInterl[staff->staffSize]; \n\ty3 = (int)(y1 + m_doc->m_rendVerticalUnit1[staff->staffSize]);\t// partie d'encadrement qui depasse\n\ty4 = (int)(y2 - m_doc->m_rendVerticalUnit1[staff->staffSize]);\t\n\n\tif (!note->m_ligObliqua && (!MusRC::s_drawingLigObliqua))\t// notes rectangulaires, y c. en ligature\n\t{\n\t\tif ( !note->m_colored)\n\t\t{\t\t\t\t//\tdouble base des carrees\n\t\t\thGrosseligne ( dc, x1,  y1,  x2,  y1, -epaisseur );\n\t\t\thGrosseligne ( dc, x1,  y2,  x2,  y2, epaisseur );\n\t\t}\n\t\telse\n\t\t\trect_plein2( dc,x1,y1,x2,y2);\t// dessine val carree pleine // ENZ correction de x2\n\n\t\tv_bline ( dc, y3, y4, x1, m_doc->m_env.m_stemWidth );\t// corset lateral\n\t\tv_bline ( dc, y3, y4, x2, m_doc->m_env.m_stemWidth );\n\t}\n\telse\t\t\t// traitement des obliques\n\t{\n\t\tif (!MusRC::s_drawingLigObliqua)\t// 1e passage: ligne verticale initiale\n\t\t{\n\t\t\tv_bline (dc,y3,y4,x1, m_doc->m_env.m_stemWidth );\n\t\t\tMusRC::s_drawingLigObliqua = true;\n\t\t\t//oblique = OFF;\n//\t\t\tif (val == DUR_1)\t// queue gauche haut si DUR_1\n//\t\t\t\tqueue_lig = ON;\n\t\t}\n\t\telse\t// 2e passage: lignes obl. et verticale finale\n\t\t{\n\t\t\tx1 -=  m_doc->m_rendBrevisWidth[staff->staffSize]*2;\t// avance auto\n\n\t\t\ty1 = *MusRC::s_drawingLigY - m_doc->m_rendHalfInterl[staff->staffSize];\t// ligat_y contient y original\n\t\t\tyy2 = y2;\n\t\t\ty5 = y1+ m_doc->m_rendInterl[staff->staffSize]; y2 += m_doc->m_rendInterl[staff->staffSize];\t// on monte d'un INTERL\n\n\t\t\tif (note->m_colored)\n\t\t\t\thGrosseligne ( dc,  x1,  y1,  x2,  yy2, m_doc->m_rendInterl[staff->staffSize]);\n\t\t\telse\n\t\t\t{\thGrosseligne ( dc,  x1,  y1,  x2,  yy2, 5);\n\t\t\t\thGrosseligne ( dc,  x1,  y5,  x2,  y2, -5);\n\t\t\t}\n\t\t\tv_bline ( dc,y3,y4,x2,m_doc->m_env.m_stemWidth);\t//cloture verticale\n\n\t\t\tMusRC::s_drawingLigObliqua = false;\n//\t\t\tqueue_lig = OFF;\t//desamorce alg.queue DUR_BR\n\n\t\t}\n\t}\n\n\tif (note->m_lig)\t// memoriser positions d'une note a l'autre; relier notes par barres\n\t{\t\n        *(MusRC::s_drawingLigX+1) = x2; *(MusRC::s_drawingLigY+1) = y;\t// relie notes ligaturees par barres verticales\n\t\t//if (in(x1,(*MusRC::s_drawingLigX)-2,(*MusRC::s_drawingLigX)+2) || (this->fligat && this->lat && !MusNote1::marq_obl))\n\t\t\t// les dernieres conditions pour permettre ligature verticale ancienne\n\t\t//\tv_bline (dc, *ligat_y, y1, (this->fligat && this->lat) ? x2: x1, m_doc->m_parameters.m_stemWidth); // ax2 - drawing vertical lines missing\n\t\t*MusRC::s_drawingLigX = *(MusRC::s_drawingLigX + 1);\n\t\t*MusRC::s_drawingLigY = *(MusRC::s_drawingLigY + 1);\n\t}\n\n\t\n\ty3 = y2 - m_doc->m_rendHalfInterl[staff->staffSize]*6;\n\n\tif (note->m_lig)\n\t{\t\n        if (note->m_dur == DUR_BR) //  && this->queue_lig)\t// queue gauche bas: DUR_BR initiale descendante // ax2 - no support of queue_lig (see WG corrigeLigature)\n\t\t{\n            v_bline ( dc, y2, y3, x1, m_doc->m_env.m_stemWidth );\n        }\n\t\telse if (note->m_dur == DUR_LG) // && !this->queue_lig) // DUR_LG en ligature, queue droite bas // ax2 - no support of queue_lig\n\t\t{\n            v_bline (dc, y2, y3, x2, m_doc->m_env.m_stemWidth );\n        }\n\t\telse if (note->m_dur == DUR_1) // && this->queue_lig )\t// queue gauche haut // ax2 - no support of queue_lig\n\t\t{\t\n            y2 = y1 + m_doc->m_rendHalfInterl[staff->staffSize]*6;\n\t\t\tv_bline ( dc, y1, y2, x1, m_doc->m_env.m_stemWidth );\n\t\t} \n\t}\n\telse if (note->m_dur == DUR_LG)\t\t// DUR_LG isolee: queue comme notes normales\n\t{\t\n\t\tmilieu = staff->m_yDrawing - m_doc->m_rendInterl[staff->staffSize]*6;\n\t\t//***up = this->q_auto ? ((y < milieu)? ON :OFF):this->queue;\n\t\t// ENZ\n\t\tup = (y < milieu) ? ON : OFF;\n\t\t// ENZ\n\t\tif ( !note->m_stemDir == 0 )\n\t\t\tup = (up == ON) ? OFF : ON;\n\t\t\t\n\t\tif (up)\n\t\t{\t\n            y3 = y1 + m_doc->m_rendHalfInterl[staff->staffSize]*6;\n\t\t\ty2 = y1;\n\t\t}\n\t\tv_bline ( dc, y2,y3,x2, m_doc->m_env.m_stemWidth );\n\t}\n\n\treturn;\n}\n\nvoid MusRC::DrawBarline( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(staff->m_parent); // Pointer to system cannot be NULL\"\n    assert(dynamic_cast<MusBarline*>(element)); // Element must be a MusBarline\"\n    \n    MusBarline *barline = dynamic_cast<MusBarline*>(element);\n    int x = element->m_xDrawing + barline->m_hOffset;\n\n    dc->StartGraphic( element, \"barline\", element->GetUuid() );\n    \n    if (barline->m_partialBarline)\n    {\n        DrawPartialBarline ( dc, (MusSystem*)staff->m_parent, x, staff);\n    }\n    else\n    {\n        //DrawBarline( dc, (MusSystem*)staff->m_parent, x,  m_doc->m_env.m_barlineWidth, barline->m_onStaffOnly, staff);\n    }\n    \n\n    \n    dc->EndGraphic(element, this ); //RZ\n}\n\nvoid MusRC::DrawClef( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusClef*>(element)); // Element must be a MusClef\"\n    \n    MusClef *clef = dynamic_cast<MusClef*>(element);\n\n    dc->StartGraphic( element, \"clef\", element->GetUuid() );\n\t\n\tint b = staff->m_yDrawing;\n\tint a = element->m_xDrawing;\n    int sym = LEIPZIG_CLEF_G;\t//sSOL, position d'ordre des cles sol fa ut in fonts\n\n\tif (staff->portNbLine > 5)\n\t\tb -= ((staff->portNbLine - 5) * 2) *m_doc->m_rendHalfInterl[ staff->staffSize ]; // LP: I am not sure it works with any number of lines\n\n    /*  poser sym=no de position sSOL dans la fonte\n     *\tau depart; ne faire operation sur b qu'une fois pour cas semblables,\n     *  et au palier commun superieur, incrementer sym, sans break.\n     */\n\tswitch(clef->m_clefId)\n\t{\n\t\tcase UT1 : \n            sym += 2;\n\t\tcase SOL1 : \n            b -= m_doc->m_rendStaffSize[ staff->staffSize ]; \n            break;\n\t\tcase SOLva : \n            sym += 1;\n\t\tcase UT2 : \n            sym += 2;\n\t\tcase SOL2 : \n            b -= m_doc->m_rendInterl[ staff->staffSize ]*3; \n            break;\n\t\tcase FA3 : \n            sym--;\n\t\tcase UT3 : \n            b -= m_doc->m_rendInterl[ staff->staffSize ]*2; \n            sym += 2; \n            break;\n\t\tcase FA5 : \n            sym++; \n            break;\n\t\tcase FA4 : \n            sym--;\n\t\tcase UT4 : \n            b -= m_doc->m_rendInterl[ staff->staffSize ];\n\t\tcase UT5 :  \n            sym += 2; \n            break;\n\t\tcase CLEPERC :  \n            b -= m_doc->m_rendInterl[ staff->staffSize ]*2;\n            sym = LEIPZIG_CLEF_PERC; \n            break;\n\t\tdefault: \n            break;\n\t}\n\n\ta -= m_doc->m_rendStep1*2;\n\tif (clef->m_cueSize)\n\t\ta+= m_doc->m_rendStep1;\n\n\tDrawLeipzigFont ( dc, a, b, sym, staff, clef->m_cueSize  );\n   \n    dc->EndGraphic(element, this ); //RZ\n}\n\nvoid MusRC::DrawMensur( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusMensur*>(element)); // Element must be a MusMensur\"\n\n    MusMensur *mensur = dynamic_cast<MusMensur*>(element);\n \n    dc->StartGraphic( element, \"mensur\", element->GetUuid() );\n\t\n\tint x, yp;\n\tfloat mDen=1.0, mNum=1.0;\n\n\tif (mensur->m_meterSymb)\n\t{\t\n\t\typ = staff->m_yDrawing - (m_doc->m_rendHalfInterl[ staff->staffSize ]*6);\n\t\t\n\t\tunsigned char fontChar = LEIPZIG_METER_SYMB_COMMON;\n\t\tswitch (mensur->m_meterSymb)\n\t\t{\t\n            case METER_SYMB_COMMON:\n\t\t\t\tfontChar = LEIPZIG_METER_SYMB_COMMON;\n\t\t\t\tmNum = 4; mDen = 4; break;\n\t\t\tcase METER_SYMB_CUT:\n\t\t\t\tfontChar = LEIPZIG_METER_SYMB_CUT;\n\t\t\t\tmNum = 2; mDen = 2; break;\n\t\t\tcase METER_SYMB_2:\n\t\t\t\tfontChar = LEIPZIG_METER_SYMB_2;\n\t\t\t\tmNum = 2; mDen = 2; break;\n\t\t\tcase METER_SYMB_3:\n\t\t\t\tfontChar = LEIPZIG_METER_SYMB_3;\n\t\t\t\tmNum = 3; mDen = 2; break;\n\t\t\tcase METER_SYMB_2_CUT:\n\t\t\t\tfontChar = LEIPZIG_METER_SYMB_2_CUT;\t\n\t\t\t\tmNum = 4; mDen = 2; break;\n\t\t\tcase METER_SYMB_3_CUT:\n\t\t\t\tfontChar = LEIPZIG_METER_SYMB_3_CUT;\t\n\t\t\t\tmNum = 6; mDen = 2; break;\n            default:\n                break;\n\t\t}\n\t\tif ( dc )\n\t\t{\t\n\t\t\tDrawLeipzigFont( dc, element->m_xDrawing, yp, fontChar, staff, staff->staffSize);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (mensur->m_sign==MENSUR_SIGN_O)\n\t\t{\t\n            mNum = 2; mDen = 2;\n\t\t\tDrawMensurCircle ( dc, element->m_xDrawing, staff->m_yDrawing, staff);\n\t\t}\n\t\telse if (mensur->m_sign==MENSUR_SIGN_C && !mensur->m_reversed)\n\t\t{\t\n            mNum = 2; mDen = 2;\n\t\t\tDrawMensurHalfCircle ( dc, element->m_xDrawing, staff->m_yDrawing, staff);\n\t\t}\n\t\telse if (mensur->m_sign==MENSUR_SIGN_C && mensur->m_reversed)\n\t\t{\t\n            mNum = 4; mDen = 2;\n\t\t\tDrawMensurReversedHalfCircle ( dc, element->m_xDrawing, staff->m_yDrawing, staff);\n\t\t}\n\t\tif (mensur->m_slash) // we handle only one single slash\n\t\t{\t\n            DrawMensurSlash ( dc, element->m_xDrawing, staff->m_yDrawing, staff);\n\t\t\tmDen = 1;\n\t\t}\n\t\tif (mensur->m_dot) // we handle only one single dot\n\t\t{\t\n            DrawMensurDot (dc, element->m_xDrawing, staff->m_yDrawing, staff);\n\t\t\tmNum = 9; mDen = 4;\n\t\t}\n\t}\n\n\n\tif (mensur->m_num)\n\t{\t\n        x = element->m_xDrawing;\n\t\tif (mensur->m_sign || mensur->m_meterSymb) \n        {\n\t\t\tx += m_doc->m_rendStep1*5; // step forward because we have a sign or a meter symbol\n        }\n\t\tDrawMensurFigures ( dc, x, staff->m_yDrawing, mensur->m_num, mensur->m_numBase, staff);\n\t\t//mDen = max ( this->durDen, (unsigned short)1); // ax2\n\t\t//mNum = max ( this->durNum, (unsigned short)1); // ax2\n\t}\n    /*\n\tMesVal = mNum / mDen;\n\tmesureNum = (int)mNum;\n\tmesureDen = (int)mDen;\n    */ // ax2 \n    \n    dc->EndGraphic(element, this ); //RZ\n\n}\n\n\nvoid MusRC::DrawMensurCircle( MusDC *dc, int x, int yy, MusStaff *staff )\n{\n\tassert( dc ); // DC cannot be NULL\n\t\n\tint y =  ToRendererY (yy - m_doc->m_rendInterl[ staff->staffSize ] * 2);\n\tint r = ToRendererX( m_doc->m_rendInterl[ staff->staffSize ]);\n\n\tint w = std::max( ToRendererX(4), 2 );\n\n    dc->SetPen( m_currentColour, w, AxSOLID );\n    dc->SetBrush( m_currentColour, AxTRANSPARENT );\n\n\tdc->DrawCircle( ToRendererX(x), y, r );\n\n    dc->ResetPen();\n    dc->ResetBrush();\n}\t\n\nvoid MusRC::DrawMensurHalfCircle( MusDC *dc, int x, int yy, MusStaff *staff )\n{\n\tassert( dc ); // DC cannot be NULL\n\n\tint w = std::max( ToRendererX(4), 2 );\n    dc->SetPen( m_currentColour, w, AxSOLID );\n    dc->SetBrush( m_currentColour, AxTRANSPARENT );\n\n\tint y =  ToRendererY (yy - m_doc->m_rendInterl[ staff->staffSize ]);\n\tint r = ToRendererX( m_doc->m_rendInterl[ staff->staffSize ]);\n\n\tx = ToRendererX (x);\n\tx -= 3*r/3;\n\n\tdc->DrawEllipticArc( x, y, 2*r, 2*r, 70, 290 );\n\t\t\n    dc->ResetPen();\n    dc->ResetBrush();\n\n\treturn;\n}\t\n\nvoid MusRC::DrawMensurReversedHalfCircle( MusDC *dc, int x, int yy, MusStaff *staff )\n{\t\n\tassert( dc ); // DC cannot be NULL\n\n\tint w = std::max( ToRendererX(4), 2 );\n    dc->SetPen( m_currentColour, w, AxSOLID );\n    dc->SetBrush( m_currentColour, AxTRANSPARENT );\n\n\tint y =  ToRendererY (yy - m_doc->m_rendInterl[ staff->staffSize ]);\n\tint r = ToRendererX( m_doc->m_rendInterl[ staff->staffSize ] );\n\n    // needs to be fixed\n\tx = ToRendererX (x);\n\tx -= 4*r/3;\n\n\tdc->DrawEllipticArc( x, y, 2*r, 2*r, 250, 110 );\n    \n    dc->ResetPen();\n    dc->ResetBrush();\n\n\treturn;\n}\t\n\nvoid MusRC::DrawMensurDot ( MusDC *dc, int x, int yy, MusStaff *staff )\n{\n\tassert( dc ); // DC cannot be NULL\n\n\tint y =  ToRendererY (yy - m_doc->m_rendInterl[ staff->staffSize ] * 2);\n\tint r = std::max( ToRendererX(4), 2 );\n\t\n    dc->SetPen( m_currentColour, 1, AxSOLID );\n    dc->SetBrush( m_currentColour, AxSOLID );\n\n\tdc->DrawCircle( ToRendererX(x) -r/2 , y, r );\n\t\t\n    dc->ResetPen();\n    dc->ResetBrush();\n\n\treturn;\n}\t\n\n\nvoid MusRC::DrawMensurSlash ( MusDC *dc, int a, int yy, MusStaff *staff )\n{\t\n\tassert( dc ); // DC cannot be NULL\n\t\n\tint y1 = yy;\n\tint y2 = y1 - m_doc->m_rendStaffSize[ staff->staffSize ];\n\t\n\tv_bline2 ( dc, y1, y2, a, 3);\n\treturn;\n}\t\n\n\nvoid MusRC::DrawMensurFigures( MusDC *dc, int x, int y, int num, int numBase, MusStaff *staff)\n{\n\tassert( dc ); // DC cannot be NULL\t\n    \t\n\tint ynum, yden;\n\tstd::string s;\n\n\tif (numBase)\n\t{\t\n\t\tynum = y - (m_doc->m_rendHalfInterl[staff->staffSize]*4);\n\t\tyden = ynum - (m_doc->m_rendInterl[staff->staffSize]*2);\n\t}\n\telse\n\t\tynum = y - (m_doc->m_rendHalfInterl[staff->staffSize]*6);\n\n\tif (numBase > 9 || num > 9)\t// avancer\n\t\tx += m_doc->m_rendStep1*2;\n\n\ts = Mus::StringFormat(\"%u\",num);\n\tputstring ( dc, x, ynum, s, 1, staff->staffSize);\t// '1' = centrer\n\n\tif (numBase)\n\t{\n        s = Mus::StringFormat(\"%u\",numBase);\n\t\tputstring ( dc, x, yden, s, 1, staff->staffSize);\t// '1' = centrer\n\t}\n\treturn;\n}\n\n\nvoid MusRC::DrawSymbol( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff, MusLayerElement *parent )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusSymbol*>(element)); // Element must be a MusSymbol\"\n    \n    // This is used when we add dynamically an element (eg. accidentals before notes)\n    // So we can get the clef without adding the new elem in the list\n    MusLayerElement *list_elem = element;\n    if (parent) list_elem = parent;\n    \n    MusSymbol *symbol = dynamic_cast<MusSymbol*>(element);\n    int oct = symbol->m_oct - 4;\n    element->m_yDrawing = CalculatePitchPosY( staff, symbol->m_pname, layer->GetClefOffset( list_elem ), oct);\n    \n    if (symbol->m_type==SYMBOL_ACCID) {\n        DrawSymbolAccid(dc, element, layer, staff);\n    }\n    else if (symbol->m_type==SYMBOL_CUSTOS) {\n        DrawSymbolCustos(dc, element, layer, staff);\n    }\n    else if (symbol->m_type==SYMBOL_DOT) {\n        DrawSymbolDot(dc, element, layer, staff);\n    }\n    \n}\n\n\nvoid MusRC::DrawSymbolAccid( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusSymbol*>(element)); // Element must be a MusSymbol\"\n    \n    MusSymbol *accid = dynamic_cast<MusSymbol*>(element);\n    dc->StartGraphic( element, \"accid\", element->GetUuid() );\n    \n    int x = element->m_xDrawing + accid->m_hOffset;\n    int y = element->m_yDrawing + staff->m_yDrawing;\n    \n    int symc;\n    switch (accid->m_accid)\n    {\tcase ACCID_NATURAL :  symc = LEIPZIG_ACCID_NATURAL; break;\n        //case ACCID_DOUBLE_SHARP : symc = LEIPZIG_ACCID_DOUBLE_SHARP; DrawLeipzigFont ( dc, x, y, symc, staff, accid->m_cueSize );\n        // so far, double sharp (and flat) have been used for key signature. This is poor design and should be fixed\n        case ACCID_DOUBLE_SHARP : symc = LEIPZIG_ACCID_SHARP; DrawLeipzigFont ( dc, x, y, symc, staff, accid->m_cueSize );    \n                    y += 7*m_doc->m_rendHalfInterl[staff->staffSize]; // LP\n        case ACCID_SHARP : symc = LEIPZIG_ACCID_SHARP; break;\n        case ACCID_DOUBLE_FLAT :  symc = LEIPZIG_ACCID_FLAT; DrawLeipzigFont ( dc, x, y, symc, staff, accid->m_cueSize );\n                    y += 7*m_doc->m_rendHalfInterl[staff->staffSize]; // LP\n        case ACCID_FLAT :  symc = LEIPZIG_ACCID_FLAT; break;\n        case ACCID_QUARTER_SHARP : symc = LEIPZIG_ACCID_QUARTER_SHARP; break;\n        case ACCID_QUARTER_FLAT :  symc= LEIPZIG_ACCID_QUARTER_FLAT; break;\n    }\n    DrawLeipzigFont ( dc, x, y, symc, staff, accid->m_cueSize );\n\n    \n    dc->EndGraphic(element, this ); //RZ\n\n}\n\n\nvoid MusRC::DrawSymbolCustos( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusSymbol*>(element)); // Element must be a MusSymbol\"\n    \n    MusSymbol *custos = dynamic_cast<MusSymbol*>(element);\n    dc->StartGraphic( element, \"custos\", element->GetUuid() );\n\n    int x = element->m_xDrawing + custos->m_hOffset;\n    int y = element->m_yDrawing + staff->m_yDrawing;\n    y -= m_doc->m_rendHalfInterl[staff->staffSize] - m_doc->m_rendVerticalUnit2[staff->staffSize];  // LP - correction in 2.0.0\n    \n    DrawLeipzigFont( dc, x, y, 35, staff, custos->m_cueSize );\n    \n    dc->EndGraphic(element, this ); //RZ\n\n}\n\nvoid MusRC::DrawSymbolDot( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusSymbol*>(element)); // Element must be a MusSymbol\"\n    \n    MusSymbol *dot = dynamic_cast<MusSymbol*>(element);\n    dc->StartGraphic( element, \"dot\", element->GetUuid() );\n    \n    int x = element->m_xDrawing + dot->m_hOffset;\n    int y = element->m_yDrawing;\n\n    switch (dot->m_dot)\n    {\t\n        case 1 : DoDrawDot( dc, x, y ); x += std::max (6, m_doc->m_rendStep1);\n        case 0 : DoDrawDot ( dc, x, y );\n    }\n    \n    dc->EndGraphic(element, this );\n\n}\n\nvoid MusRC::DrawKeySig( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n\n    MusKeySig *ks = dynamic_cast<MusKeySig*>(element);\n    int symb;\n    int x, y;\n    \n    MusClef *c = layer->GetClef(element);\n    if (!c) {\n        return;\n    }\n    \n    dc->StartGraphic( element, \"keysig\", element->GetUuid() );\n    \n    for (int i = 0; i < ks->m_num_alter; i++) {\n        \n        element->m_yDrawing = CalculatePitchPosY( staff, ks->GetAlterationAt(i), layer->GetClefOffset( element ), ks->GetOctave(ks->GetAlterationAt(i), c->m_clefId));\n        \n        x = element->m_xDrawing + (m_doc->m_rendAccidWidth[staff->staffSize][0] + 5) * i;\n        y = element->m_yDrawing + staff->m_yDrawing;\n        \n        if (ks->m_alteration == ACCID_FLAT)\n            symb = LEIPZIG_ACCID_FLAT;\n        else\n            symb = LEIPZIG_ACCID_SHARP;\n        \n        DrawLeipzigFont ( dc, x, y, symb, staff, false );\n    }\n    \n    dc->EndGraphic(element, this ); //RZ\n    \n}\n\nvoid MusRC::DrawTie( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusStaff *staff, MusMeasure *measure )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(dynamic_cast<MusTie*>(element)); // The element must be a tie\n    \n    bool up = false;\n    \n    MusTie *tie = dynamic_cast<MusTie*>(element);\n    MusLayerElement *note1 = tie->GetFirstNote();\n    MusLayerElement *note2 = tie->GetSecondNote();\n    MusSystem *currentSystem = dynamic_cast<MusSystem*>( staff->GetFirstParent( &typeid(MusSystem) ) );\n    MusSystem *parentSystem1 = NULL;\n    MusSystem *parentSystem2 = NULL;\n    \n    // In order to know if we are drawing a normal tie or a tie splitted over two systems, we need\n    // to look at the parent system of each note.\n    if ( note1 ) {\n        parentSystem1 = dynamic_cast<MusSystem*>( note1->GetFirstParent( &typeid(MusSystem) ) );\n    }\n    if ( note2 ) {\n        parentSystem2 = dynamic_cast<MusSystem*>( note2->GetFirstParent( &typeid(MusSystem) ) );\n    }\n    \n    // This is the case when the tie is split over two system of two pages.\n    // In this case, we are now drawing its beginning to the end of the measure (i.e., the last aligner)\n    if ( parentSystem2 && currentSystem && ( parentSystem2 != currentSystem) ) {\n        MusAlignment *nextAlignement = note1->GetAlignment();\n        while (nextAlignement) {\n            if (nextAlignement->GetType() == ALIGNMENT_MEASURE_END) break;\n            nextAlignement = dynamic_cast<MusAlignment*>(nextAlignement->GetNextSibling());\n        }\n        if (!nextAlignement) {\n            return;\n        }\n        int y = note1->m_yDrawing + staff->m_yDrawing;\n        int x2 = measure->m_xDrawing + nextAlignement->GetXRel();\n        DrawTieBezier(dc, note1->m_xDrawing, y - 14, x2, true);\n    }\n    // Now this is the case when the tie is split but we are drawing the end of it\n    else if ( parentSystem1 && currentSystem && ( parentSystem1 != currentSystem) ) {\n        MusAlignment *previousAlignement = note2->GetAlignment();\n        while (previousAlignement) {\n            if (previousAlignement->GetType() != ALIGNMENT_DEFAULT) break;\n            previousAlignement = dynamic_cast<MusAlignment*>(previousAlignement->GetPreviousSibling());\n        }\n        if (!previousAlignement) {\n            return;\n        }\n        int y = note2->m_yDrawing + staff->m_yDrawing;\n        //int x1 = measure->m_xDrawing + previousAlignement->GetXRel() + previousAlignement->GetMaxWidth();\n        // is it actually better for x1 just to have a fixed value\n        int x1 = note2->m_xDrawing - m_doc->m_rendStep2;\n        DrawTieBezier(dc, x1, y - 14, note2->m_xDrawing, true);\n    }\n    // Finally the normal case, but double check we have two notes\n    else if ( note1 && note2 ) {\n        \n        // Copied from DrawNote\n        // We could use the stamDir information\n        // but then we have to take in account (1) beams (2) stemmed and non stemmed notes tied together\n        int ynn = note1->m_yDrawing + staff->m_yDrawing;\n        int bby = staff->m_yDrawing;\n        int milieu = bby - m_doc->m_rendInterl[staff->staffSize] * 2;\n        \n        up = (ynn < milieu) ? true : false;\n        \n        dc->StartGraphic( element, \"tie\", element->GetUuid() );\n        \n        // FIXME, take in account elements that can be netween notes, eg keys time etc\n        // 20 height nice with 70, not nice with 50\n        if (up)\n            DrawTieBezier(dc, note1->m_xDrawing, note1->m_yDrawing + staff->m_yDrawing - 14, note2->m_xDrawing, true);\n        else\n            DrawTieBezier(dc, note1->m_xDrawing, note1->m_yDrawing + staff->m_yDrawing + 14, note2->m_xDrawing, false);\n\n        dc->EndGraphic(element, this );\n    }\n    \n}\n\nvoid MusRC::DrawAcciaccaturaSlash(MusDC *dc, MusLayerElement *element) {\n    \n    MusNote *note = dynamic_cast<MusNote*>(element);\n    \n    if (note->m_dur < DUR_8)\n        return;\n    \n    dc->SetPen(AxBLACK, 2, AxSOLID);\n    dc->SetBrush( AxBLACK, AxSOLID );\n    \n    if (element->m_drawn_stem_dir)\n        dc->DrawLine(element->m_stem_start.x - 10, ToRendererY(element->m_stem_start.y + 10), element->m_stem_start.x + 20, ToRendererY(element->m_stem_start.y + 40));\n    else\n        dc->DrawLine(element->m_stem_start.x - 10, ToRendererY(element->m_stem_start.y - 10), element->m_stem_start.x + 20, ToRendererY(element->m_stem_start.y - 40));\n    \n    dc->ResetPen();\n    dc->ResetBrush();\n}\n\n/** Draws a fermata\n rest - the fermata is always above the stavv\n note - for breves and semibreves, only above the staff\n      - for flagged notes, the fermata is on the side of the notehead\n */\nvoid MusRC::DrawFermata(MusDC *dc, MusLayerElement *element, MusStaff *staff) {\n    int x, y;\n    int emb_offset = 0; // if there is and embellishment, offset the note up\n    \n    // We position the fermata in the same horizontal pos. of th eobject\n    x = element->m_xDrawing;\n    \n    // First case, notes\n    if (dynamic_cast<MusNote*>(element)) {\n        MusNote *note = dynamic_cast<MusNote*>(element);\n        \n        // stem down or semibreve/longa, fermata up!\n        if (!element->m_drawn_stem_dir && (note->m_dur != DUR_1 || note->m_dur != DUR_BR)) {\n            \n            // only for up-fermatas, if there is a trill on the same note\n            // add a 35 pixel space so they do not collide\n            if (note->m_embellishment)\n                emb_offset = 35;\n            \n            // check that the notehead is in the staff.\n            if ((element->m_yDrawing + staff->m_yDrawing) < staff->m_yAbs)\n                // in the staff, set the fermata 20 pixels above the last line (+ embellishment offset)\n                y = staff->m_yAbs + 20 + emb_offset;\n            else\n                // out of the staff, place the trill 20 px above the notehead\n                y = (element->m_yDrawing + staff->m_yDrawing) + 20 + emb_offset;\n            \n            // draw the up-fermata\n            DrawLeipzigFont ( dc, element->m_xDrawing, y, LEIPZIG_FERMATA_UP, staff, false );\n        } else { // stem up fermata down\n            \n            // This works as above, only we check that the note head is not\n            // UNDER the staff\n            if ((element->m_yDrawing + staff->m_yDrawing) > (staff->m_yDrawing - m_doc->m_rendStaffSize[staff->staffSize]))\n                // notehead in staff, set at 20 px under\n                y = staff->m_yDrawing - m_doc->m_rendStaffSize[staff->staffSize] - 20;\n            else\n                // notehead under staff, set 20 px under notehead\n                y = (element->m_yDrawing + staff->m_yDrawing) - 20;\n            \n            DrawLeipzigFont ( dc, element->m_xDrawing, y, LEIPZIG_FERMATA_DOWN, staff, false );\n        }\n    } else if (dynamic_cast<MusRest*>(element)) {\n        // this is a rest\n        // rests for the moment are always in the staff\n        // so just place the fermata above the staff + 20 px\n        y = staff->m_yAbs + 20;\n        DrawLeipzigFont ( dc, element->m_xDrawing, y, LEIPZIG_FERMATA_UP, staff, false );\n    }\n}\n\n// Draw a trill above the notehead\n// This function works as the up-fermata portion of DrawFermata\n// if there are many symbols to draw we could make a generalized function\nvoid MusRC::DrawTrill(MusDC *dc, MusLayerElement *element, MusStaff *staff) {\n    int x, y;    \n    x = element->m_xDrawing;\n\n    if ((element->m_yDrawing + staff->m_yDrawing) < staff->m_yAbs)\n        y = staff->m_yAbs + 30;\n    else\n        y = (element->m_yDrawing + staff->m_yDrawing) + 30;\n    \n    DrawLeipzigFont ( dc, element->m_xDrawing, y, LEIPZIG_EMB_TRILL, staff, false );\n}\n\n\nvoid MusRC::DrawLayerApp( MusDC *dc, MusLayerElement *element, MusLayer *layer, MusMeasure *measure, MusStaff *staff ){\n    \n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    assert(staff->m_parent); // Pointer to staff system cannot be NULL\"\n    \n    MusLayerApp *app = dynamic_cast<MusLayerApp*>(element);    \n    int i;\n    for (i = 0; i < app->GetRdgCount(); i++ )\n    {\n        MusLayer *rdg = (MusLayer*)app->m_children[i];\n        int j;\n        for (j = 0; j < rdg->GetElementCount(); j++ ) {\n            MusLayerElement *lelem = (MusLayerElement*)rdg->m_children[j];\n            if (i == 0) {\n                m_currentColour = AxGREEN;\n            }\n            else {\n                m_currentColour = AxBLUE;\n            }\n            DrawElement(dc, lelem, layer, measure, staff );\n            /*\n            MusLayerElement rdgElement(&rdg->m_elements[j] );\n            rdgElement.m_layer = element->m_layer;\n            rdgElement.SetLayout( m_doc );\n            rdgElement.m_xDrawing = element->m_xDrawing;\n            DrawElement(dc, &rdgElement, layer, staff );\n            rdgElement.m_layer = NULL;\n            */\n        }\n        \n        /*\n        MusStaff *appStaff = new MusStaff( staff->m_n );\n        appStaff->m_yDrawing = staff->m_yDrawing + m_doc->m_rendStaffSize[staff->staffSize];\n        appStaff->m_system = staff->m_system;\n        appStaff->SetLayout( m_doc );\n        DrawStaff(dc, appStaff, staff->m_system );\n        delete appStaff;\n        */\n    }\n}\n\n/*\n * Lyric code not refactored in ax2\n    \nvoid MusNote1::DeleteLyricFromNote( MusSymbol1 *lyric )\n{\n\tfor ( int i = 0; i < (int)this->m_lyrics.GetCount(); i++ ){\n\t\tMusSymbol1 *tmp = &this->m_lyrics[i];\n\t\tif ( lyric == tmp ){\n\t\t\tthis->m_lyrics.RemoveAt( i );\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nMusSymbol1 *MusNote1::GetFirstLyric( )\n{\n\tif ( this->m_lyrics.GetCount() == 0 ) \n\t\treturn NULL;\n\telse\n\t\treturn &this->m_lyrics[0];\n}\n\nMusSymbol1 *MusNote1::GetLastLyric( )\n{\n\tint num = this->m_lyrics.GetCount(); \n\tif ( num == 0 ) \n\t\treturn NULL;\n\telse \n\t\treturn &this->m_lyrics[num-1];\n}\n\nMusSymbol1 *MusNote1::GetLyricNo( int no )\n{\n\tint num = this->m_lyrics.GetCount(); \n\tif ( (no < 0) || (num <= no) ) \n\t\treturn NULL;\n\telse \n\t\treturn &this->m_lyrics[no];\n}\n\n*/\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mustie.h\n// Author:      Rodolfo Zitellini\n// Created:     26/06/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_TIE_H__\n#define __MUS_TIE_H__\n\n#include \"muslayer.h\"\n#include \"musnote.h\"\n#include \"musobject.h\"\n\n//----------------------------------------------------------------------------\n// MusTie\n// A TIE class is a simple slur - it takes in account only two notes, the first and second:\n// NOTE tie NOTE tie etc\n//----------------------------------------------------------------------------\n\nclass MusTie: public MusLayerElement\n{\npublic:\n    // constructors and destructors\n    MusTie();\n    virtual ~MusTie();\n    \n    virtual std::string MusClassName( ) { return \"MusTie\"; };\n    \n    /**\n     * @name Set and get the first and second note of the tie\n     * The setter asserts that no note was previously set.\n     */\n    ///@{\n    void SetFirstNote( MusNote *note );\n    void SetSecondNote( MusNote *note );\n    MusNote *GetFirstNote() { return m_first; };\n    MusNote *GetSecondNote() { return m_second; };\n    ///@}\n    \nprivate:\n    \npublic:\n    \nprivate:\n    MusNote *m_first;\n    MusNote *m_second;\n    \n};\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musapp.h\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#ifndef __MUS_APP_H__\n#define __MUS_APP_H__\n\n#include \"muslayerelement.h\"\n\nclass MusLayerRdg;\n\n//----------------------------------------------------------------------------\n// MusLayerApp\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <app> element within a <layer> element.\n */\nclass MusLayerApp: public MusLayerElement\n{\npublic:\n    // constructors and destructors\n    MusLayerApp();\n    virtual ~MusLayerApp();\n    \n    void AddLayerRdg( MusLayerRdg *layerRdg );\n    \n    int GetRdgCount() { return (int)m_children.size(); };\n    \n    // functor\n    virtual int Save( ArrayPtrVoid params );\n    \nprivate:\n    \npublic:\n\nprivate:\n    \n};\n\n\n//----------------------------------------------------------------------------\n// MusLayerRdg\n//----------------------------------------------------------------------------\n\n/** \n * This class models the MEI <rdg> element for a <app> in a <layer>\n */\nclass MusLayerRdg: public MusObject\n{\npublic:\n    // constructors and destructors\n    MusLayerRdg( );\n    virtual ~MusLayerRdg();\n    \n\tvoid AddElement( MusLayerElement *element, int idx = -1 );\n    \n\tint GetElementCount() const { return (int)m_children.size(); };\n    \n    // functor\n    virtual int Save( ArrayPtrVoid params );\n\nprivate:\n    \npublic:\n    /** The source id */\n    std::string m_source;\n    \nprivate:\n    \n};\n\n\n#endif\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrc_graph.cpp\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musrc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n\n#include \"musdoc.h\"\n#include \"musstaff.h\"\n\nvoid MusRC::v_bline ( MusDC *dc, int y1, int y2, int x1, int nbr)\n{\n\tassert( dc ); // DC cannot be NULL\n\n    dc->SetPen( m_currentColour, std::max( 1, ToRendererX(nbr) ), AxSOLID );\n    dc->SetBrush( m_currentColour, AxSOLID );\n\n\tdc->DrawLine( ToRendererX(x1) , ToRendererY(y1), ToRendererX(x1), ToRendererY(y2) );\n\n    dc->ResetPen();\n    dc->ResetBrush();\n\treturn;\n}\n\n\n\nvoid MusRC::v_bline2 ( MusDC *dc, int y1, int y2, int x1, int nbr)\t\n{\n\tassert( dc ); // DC cannot be NULL\n\n\tSwapY( &y1, &y2 );\n\n\tint x2;\n  \tx2 = x1 - nbr;\n\tif (ToRendererX(nbr) < 1)\n\t\tnbr = ToLogicalX(1);\n\n    dc->SetPen( m_currentColour, 1, AxSOLID );\n    dc->SetBrush( m_currentColour, AxSOLID );\n\n\tdc->DrawRectangle( ToRendererX( x2 ), ToRendererY(y1), ToRendererX(nbr) , ToRendererX( y1 - y2 ));\n\n    dc->ResetPen();\n    dc->ResetBrush();\n\t\n\treturn;\n}\n\n\nvoid MusRC::h_bline ( MusDC *dc, int x1, int x2, int y1, int nbr)\n{\t\t\n\tassert( dc ); // DC cannot be NULL\n\n    dc->SetPen( m_currentColour, std::max( 1, ToRendererX(nbr) ), AxSOLID );\n    dc->SetBrush( m_currentColour, AxTRANSPARENT );\n\n\tdc->DrawLine( ToRendererX(x1) , ToRendererY(y1), ToRendererX(x2), ToRendererY(y1) );\n\n    dc->ResetPen();\n    dc->ResetBrush();\n\treturn;\n}\n\n//draw a box, lol. It's like a rectangle, but not filled in.\nvoid MusRC::box( MusDC *dc, int x1, int y1, int x2, int y2)\n{\n\tassert( dc ); // DC cannot be NULL\n\t\n\tSwapY( &y1, &y2 );\n\n    dc->SetPen( m_currentColour, 3, AxSOLID);\n\t\n\tdc->DrawRectangle( ToRendererX(x1), ToRendererY(y1), ToRendererX(x2 - x1), ToRendererX(y1 - y2));\n\t\n    dc->ResetPen();\n\t\n\treturn;\n}\n\nvoid MusRC::rect_plein2( MusDC *dc, int x1, int y1, int x2, int y2 )\t/* dessine rectangle plein */\n{\t\n\tassert( dc ); // DC cannot be NULL\n\n\tSwapY( &y1, &y2 );\n\n    dc->SetPen( m_currentColour, 1, AxSOLID  );\n    dc->SetBrush( m_currentColour, AxSOLID );\n\n\tdc->DrawRectangle( ToRendererX( x1 ), ToRendererY(y1), ToRendererX(x2 - x1) , ToRendererX( y1 - y2 ));\n\n    dc->ResetPen();\n    dc->ResetBrush();\n\n\treturn;\n}\n\nint MusRC::hGrosseligne ( MusDC *dc, int x1, int y1, int x2, int y2, int decal)\n{\t\n\tMusPoint p[4];\n\tint dec = decal;\n  \n    dc->SetPen( m_currentColour, 1, AxSOLID );\n    dc->SetBrush( m_currentColour, AxSOLID );\n\n\tdecal = ToRendererX(decal);\n\tp[0].x = ToRendererX(x1);\n\tp[0].y =  ToRendererY(y1);\n\tp[1].x = ToRendererX(x2);\n\tp[1].y =  ToRendererY(y2);\n\tp[2].x = p[1].x;\n\tp[2].y = p[1].y - decal;\n\tp[3].x = p[0].x;\n\tp[3].y = p[0].y - decal;\n\n\tdc->DrawPolygon ( 4, p ); //(sizeof (bcoord)*2) / sizeof (POINT)); nbrInt*2+ 1;\n\n    dc->ResetPen();\n    dc->ResetBrush();\n\treturn dec;\n}\n\n\nint MusRC::DoDrawDot ( MusDC *dc, int x, int y )\n{\n\tint r = std::max( ToRendererX(3), 2 );\n\t\n    dc->SetPen( m_currentColour, 1, AxSOLID );\n    dc->SetBrush( m_currentColour, AxSOLID );\n\n\tdc->DrawCircle( ToRendererX(x) , ToRendererY(y), r );\n\t\t\n    dc->ResetPen();\n    dc->ResetBrush();\n\n\treturn y;\n}\n\nvoid MusRC::DrawLeipzigFont ( MusDC *dc, int x, int y, unsigned char c, \n\t\t\t\t\t\t MusStaff *staff, bool dimin )\n{  \n\tint staffSize = staff->staffSize;\n\tint fontCorr = 0;\n    if (dc->CorrectMusicAscent()) {\n        fontCorr = m_doc->m_rendFontHeightAscent[staffSize][dimin];\n    }\n\n\tassert( dc ); // DC cannot be NULL\n\n    // Font offset management for clef in mensural mode - needs improvement (font modification?)\n\tif (staff->notAnc && (unsigned char)c >= LEIPZIG_OFFSET_IN_FONT)\n\t{\t\n\t\tc+= LEIPZIG_OFFSET_MENSURAL;\n\t\tif (dimin && is_in (c, 227, 229))\t// les trois clefs\n\t\t{\t\n\t\t\tc+= 14;\t// les cles d===e tablature\n            if (dc->CorrectMusicAscent()) {\n                fontCorr = m_doc->m_rendFontHeightAscent[ staffSize][0];\n            }\n\t\t}\n\t}\n\tif (!staff->notAnc || !is_in (c, 241, 243))\t// tout sauf clefs de tablature\n\t{\n        dc->SetFont( &m_doc->m_rendFonts[ staffSize ][ dimin ] );\n\t}\n\n\tif ( dc)\n\t{\t\n\t\tdc->SetBackground( AxBLUE );\n\t\tdc->SetBackgroundMode( AxTRANSPARENT );\n\n\t\tm_str = (char)c;\n\t\tdc->SetTextForeground( m_currentColour );\n        dc->SetPen( m_currentColour, 1, AxSOLID );\n        dc->SetBrush( m_currentColour, AxSOLID );\n\n\t\t//Mus::LogDebug(\"Drawing text here, x: %d, y: %d, y (zoomed): %d, y + fontcorr: %d\"\n\t\t//\t   , ToRendererX(x), y, ToRendererY(y), ToRendererY(y + fontCorr));\n        // DrawMusicText is the same with AxWxDc but different with MusSvgDC\n\t\tdc->DrawMusicText( m_str, ToRendererX(x), ToRendererY(y + fontCorr) );\n\n        dc->ResetPen();\n        dc->ResetBrush();\n\t}\n\n\treturn;\n}\n\nvoid MusRC::putstring ( MusDC *dc, int x, int y, std::string s, int centrer, int staffSize)\n{ \n\tassert( dc ); // DC cannot be NULL\n\n    int fontCorr = 0;\n    \n    dc->SetFont( &m_doc->m_rendFonts[ staffSize ][0] );\n    x = ToRendererX(x);\n    if (dc->CorrectMusicAscent()) {\n        fontCorr = m_doc->m_rendFontHeightAscent[staffSize][0];\n    }\n    \n    \n\tif ( centrer )\n\t{\n        Mus::LogDebug(\"Centering string not implemented with MusDC\");\n\t\t\n        int w, h;\n\t\tdc->GetTextExtent( s, &w, &h );\n\t\tx -= w / 2;\n        \n\t}\n\tdc->SetTextForeground( m_currentColour );\n\tdc->DrawText( s, x, ToRendererY(y + fontCorr ));\n}\n\nvoid MusRC::putlyric ( MusDC *dc, int x, int y, std::string s, int staffSize, bool cursor)\n{ \n\tassert( dc ); // DC cannot be NULL\n\n    dc->SetFont( &m_doc->m_rendLyricFonts[ staffSize ] );\n\tx = ToRendererX(x);\n\n\tdc->SetTextForeground( m_currentColour );\n\tdc->DrawText( s, x, ToRendererY( y ) );\n    \n    if (cursor)\n        DoLyricCursor( x, y, dc, s );\t\n}\n\nvoid MusRC::DrawTieBezier(MusDC *dc, int x, int y, int x1, bool direction)\n{\n    int height = std::max( MIN_TIE_HEIGHT, std::min( 1 * m_doc->m_rendInterl[0], abs( x1 - x ) / 4 ) );\n    \n    int thickness = std::max( m_doc->m_rendInterl[0] / 3, MIN_TIE_THICKNESS );\n    \n    int one, two; // control points at 1/4 and 3/4 of total lenght\n    int bez1[6], bez2[6]; // filled array with control points and end point\n    \n    int top_y, top_y_fill; // Y for control points in both beziers\n    \n    one = (x1 - x) / 4; // point at 1/4\n    two = (x1 - x) / 4 * 3; // point at 3/4\n    \n    if (direction) {\n        // tie goes up\n        top_y = y - height;\n        // the second bezier in internal\n        top_y_fill = top_y + thickness;\n    } else {\n        //tie goes down\n        top_y = y + height;\n        // second bezier is internal as above\n        top_y_fill = top_y - thickness;\n    }\n    \n    // Points for first bez, they go from xy to x1y1\n    bez1[0] = ToRendererX(x + one); bez1[1] = ToRendererY(top_y);\n    bez1[2] = ToRendererX(x + two); bez1[3] = ToRendererY(top_y);\n    bez1[4] = ToRendererX(x1); bez1[5] = ToRendererY(y);\n    \n    // second bez. goes back\n    bez2[0] = ToRendererX(x + two); bez2[1] = ToRendererY(top_y_fill);\n    bez2[2] = ToRendererX(x + one); bez2[3] = ToRendererY(top_y_fill);\n    bez2[4] = ToRendererX(x); bez2[5] = ToRendererY(y);\n    \n    // Actually draw it\n    dc->DrawComplexBezierPath(ToRendererX(x), ToRendererY(y), bez1, bez2);\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrc_page.cpp\n// Author:      Laurent Pugin and Chris Niven\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musrc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <math.h>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"musbeam.h\"\n#include \"musbarline.h\"\n#include \"musclef.h\"\n#include \"musdoc.h\"\n#include \"muskeysig.h\"\n#include \"muslayer.h\"\n#include \"muslayerelement.h\"\n#include \"musmeasure.h\"\n#include \"musmensur.h\"\n#include \"muspage.h\"\n#include \"musstaff.h\"\n#include \"mussystem.h\"\n#include \"mustie.h\"\n#include \"mustuplet.h\"\n\n//----------------------------------------------------------------------------\n// MusRC - MusPage\n//----------------------------------------------------------------------------\n\nvoid MusRC::DrawPage( MusDC *dc, MusPage *page, bool background ) \n{\n\tassert( dc ); // DC cannot be NULL\n    assert( page );\n    \n    int i;\n\tMusSystem *system = NULL;\n    \n    // Set the current score def to the page one\n    // The page one has previously been set by MusObject::SetPageScoreDef\n    m_drawingScoreDef = page->m_drawingScoreDef;\n\n    if ( background )\n        dc->DrawRectangle( 0, 0, m_doc->m_rendPageWidth, m_doc->m_rendPageHeight );\n    \n    dc->DrawBackgroundImage( );\n    \n    MusPoint origin = dc->GetLogicalOrigin();\n    dc->SetLogicalOrigin( origin.x - m_doc->m_rendPageLeftMar, origin.y );\n\n    dc->StartPage();\n\n    for (i = 0; i < page->GetSystemCount(); i++) \n\t{\n\t\tsystem = (MusSystem*)page->m_children[i];\n        DrawSystem( dc, system );\n        \n        // TODO here: also update x_abs and m_yDrawing positions for system. How to calculate them?\n    }\n    \n    dc->EndPage();\n}\n\n//----------------------------------------------------------------------------\n// MusRC - MusSystem\n//----------------------------------------------------------------------------\n\n\n// drawing\n\n\nvoid MusRC::DrawSystem( MusDC *dc, MusSystem *system ) \n{\n\tassert( system ); // other asserted before\n    \n\tint i;\n    MusMeasure *measure;\n    \n    dc->StartGraphic( system, \"system\", system->GetUuid() );\n    \n    \n    if ( system->m_yAbs == AX_UNSET ) {\n        assert( m_doc->GetType() == Raw );\n        system->m_yDrawing = system->m_yRel;\n        system->m_xDrawing = system->m_xRel;\n    }\n    else\n    {\n        assert( m_doc->GetType() == Transcription );\n        system->m_yDrawing = system->m_yAbs;\n        system->m_xDrawing = system->m_xAbs;\n    }\n    \n    \n    for (i = 0; i < (int)system->GetMeasureCount(); i++)\n\t{\n\t\tmeasure = (MusMeasure*)system->m_children[i];\n        DrawMeasure( dc , measure, system );\n\t}\n\n    // We draw the groups after the staves because we use the m_y_darwing member of the staves\n    // that needs to be intialized.\n    // Warning: we assume for now the scoreDef occuring in the system will not change the staffGrps content\n    // and @symbol values, otherwise results will be unexpected...\n    // First get the first measure of the system\n    measure  = dynamic_cast<MusMeasure*>(system->GetFirstChild( &typeid(MusMeasure) ) );\n    if ( measure ) {\n        // NULL for the MusBarline parameters indicates that we are drawing the scoreDef\n        DrawScoreDef( dc, &m_drawingScoreDef, measure, system->m_xDrawing, NULL );\n    }\n    \n    dc->EndGraphic(system, this );\n\n}\n\nvoid MusRC::DrawScoreDef( MusDC *dc, MusScoreDef *scoreDef, MusMeasure *measure, int x, MusBarline *barline  )\n{\n    assert( scoreDef ); // other asserted before\n\n    // we need at least one measure to be able to draw the groups - we need access to the staff elements,\n    assert( measure );\n    \n    MusStaffGrp *staffGrp = dynamic_cast<MusStaffGrp*>(scoreDef->GetFirstChild( &typeid(MusStaffGrp) ) );\n    if ( !staffGrp ) {\n        return;\n    }\n    \n    if ( barline == NULL) {\n        // Draw the first staffGrp and from there its children recursively\n        DrawStaffGrp( dc, measure, staffGrp, x );\n    }\n    else{\n        dc->StartGraphic( barline, \"barline\", barline->GetUuid() );\n        DrawBarlines( dc, measure, staffGrp, x, barline );\n        dc->EndGraphic( barline, this );\n    }\n    \n\treturn;\n}\n\n\nvoid MusRC::DrawStaffGrp( MusDC *dc, MusMeasure *measure, MusStaffGrp *staffGrp, int x )\n{\n    assert( measure );\n    assert( staffGrp );\n    \n    ListOfMusObjects *staffDefs = staffGrp->GetList( staffGrp );\n    if ( staffDefs->empty() ) {\n        return;\n    }\n    \n    // Get the first and last staffDef of the staffGrp\n    MusStaffDef *firstDef = dynamic_cast<MusStaffDef*>(staffDefs->front());\n    MusStaffDef *lastDef = dynamic_cast<MusStaffDef*>(staffDefs->back());\n    \n    if (!firstDef || !lastDef ) {\n        Mus::LogDebug(\"Could not get staffDef while drawing staffGrp - Mus::DrawStaffGrp\");\n        return;\n    }\n    \n    // Get the corresponding staff looking at the previous (or first) measure\n    MusStaff *first = measure->GetStaffWithNo( firstDef->GetStaffNo() );\n    MusStaff *last = measure->GetStaffWithNo( lastDef->GetStaffNo() );\n    \n    if (!first || !last ) {\n        Mus::LogDebug(\"Could not get staff (%d; %d) while drawing staffGrp - Mus::DrawStaffGrp\", firstDef->GetStaffNo(), lastDef->GetStaffNo() );\n        return;\n    }\n    \n    int y_top = first->m_yDrawing;\n    // for the bottom position we need to take into account the number of lines and the staff size\n    int y_bottom = last->m_yDrawing - (last->portNbLine - 1) * m_doc->m_rendInterl[last->staffSize];\n    \n    // actually draw the line, the brace or the bracket\n    if ( staffGrp->GetSymbol() == STAFFGRP_LINE ) {\n        v_bline( dc , y_top, y_bottom, x, m_doc->m_env.m_barlineWidth);\n    }\n    else if ( staffGrp->GetSymbol() == STAFFGRP_BRACE ) {\n        DrawBrace ( dc, x, y_top, y_bottom, last->staffSize );\n    }\n    else if ( staffGrp->GetSymbol() == STAFFGRP_BRACKET ) {\n        DrawBracket( dc, x, y_top, y_bottom, last->staffSize );\n        x -= 2 * m_doc->m_rendBeamWidth[0] - m_doc->m_rendBeamWhiteWidth[0];\n    }\n    \n    // recursively draw the children\n    int i;\n    MusStaffGrp *childStaffGrp = NULL;\n    for (i = 0; i < staffGrp->GetChildCount(); i++) {\n        childStaffGrp = dynamic_cast<MusStaffGrp*>(staffGrp->GetChild( i ));\n        if ( childStaffGrp ) {\n            DrawStaffGrp( dc, measure, childStaffGrp, x );\n        }\n    }\n}\n\n\nvoid MusRC::DrawBracket ( MusDC *dc, int x, int y1, int y2, int staffSize)\n{\n\tint xg, xd, yg, yd, ecart, centre;\n\n    dc->SetPen( m_currentColour , 2, AxSOLID );\n    dc->SetBrush( m_currentColour , AxTRANSPARENT );\n    \n    ecart = m_doc->m_rendBeamWidth[0] + m_doc->m_rendBeamWhiteWidth[0];\n    centre = x - ecart;\n    \n    xg = centre - ecart*2;\n    xd = centre + ecart*2;\n    \n    yg = y1 + m_doc->m_rendInterl[ staffSize ] * 2;\n    yd = y1;\n    SwapY( &yg, &yd );\n    dc->DrawEllipticArc( ToRendererX(xg), ToRendererY(yg), ToRendererX(xd-xg), ToRendererX(yg-yd), 90, 40 );\n    \n    yg = y2;\n    yd = y2 - m_doc->m_rendInterl[ staffSize ] * 2;\n    SwapY( &yg, &yd );\n    dc->DrawEllipticArc( ToRendererX(xg), ToRendererY(yg), ToRendererX(xd-xg), ToRendererX(yg-yd), 320, 270 );\n    \n    dc->ResetPen();\n    dc->ResetBrush();\n    \n    xg = x - (m_doc->m_rendBeamWhiteWidth[0] + 1);\n    // determine le blanc entre barres grosse et mince\n    v_bline2( dc, y1, y2, xg, m_doc->m_rendBeamWidth[0]);\n\n\treturn;\n}\n\n\nvoid MusRC::DrawBrace ( MusDC *dc, int x, int y1, int y2, int staffSize)\n{\t\n    int new_coords[2][6];\n    \n\tassert( dc ); // DC cannot be NULL\n\n\tSwapY( &y1, &y2 );\n\t\n\tint ymed, xdec, fact, nbrInt;\n    \n    dc->SetPen( m_currentColour , 1, AxSOLID );\n    dc->SetBrush( m_currentColour , AxSOLID );\n    \n\tx -= m_doc->m_rendBeamWhiteWidth[ staffSize ];  // distance entre barre et debut accolade\n    \n\tnbrInt = BEZIER_NB_POINTS;\n    \n\tymed = (y1 + y2) / 2;\n\tfact = m_doc->m_rendBeamWidth[ staffSize ]-1 + m_doc->m_env.m_barlineWidth;\n\txdec = ToRendererX(fact);\n    \n\tpoint_[0].x = ToRendererX(x);\n\tpoint_[0].y = ToRendererY(y1);\n\tpoint_[1].x = ToRendererX(x - m_doc->m_rendStep2);\n\tpoint_[1].y = point_[0].y - ToRendererX( m_doc->m_rendInterl[ staffSize ]*3);\n\tpoint_[3].x = ToRendererX(x - m_doc->m_rendStep1*2);\n\tpoint_[3].y = ToRendererY(ymed);\n\tpoint_[2].x = ToRendererX(x + m_doc->m_rendStep1);\n\tpoint_[2].y = point_[3].y + ToRendererX( m_doc->m_rendInterl[ staffSize ]);\n    \n    new_coords[0][0] = point_[1].x;\n    new_coords[0][1] = point_[1].y;\n    new_coords[0][2] = point_[2].x;\n    new_coords[0][3] = point_[2].y;\n    new_coords[0][4] = point_[3].x;\n    new_coords[0][5] = point_[3].y;\n    \n\tpntswap (&point_[0], &point_[3]);\n\tpntswap (&point_[1], &point_[2]);\n\t\n\tpoint_[1].x += xdec;\n\tpoint_[2].x += xdec;\n\tpoint_[1].y = point_[0].y + ToRendererX( m_doc->m_rendInterl[ staffSize ]*2);\n    \n    new_coords[1][0] = point_[1].x;\n    new_coords[1][1] = point_[1].y;\n    new_coords[1][2] = point_[2].x;\n    new_coords[1][3] = point_[2].y;\n    new_coords[1][4] = point_[3].x;\n    new_coords[1][5] = point_[3].y;\n    \n    dc->DrawComplexBezierPath(ToRendererX(x), ToRendererY(y1), new_coords[0], new_coords[1]);\n    \n\t// on produit l'image reflet vers le bas: 0 est identique \n\tpoint_[1].y = point_[0].y - ToRendererX( m_doc->m_rendInterl[ staffSize ]*2);\n\tpoint_[3].y = ToRendererY(y2);\n\tpoint_[2].y = point_[3].y + ToRendererX( m_doc->m_rendInterl[ staffSize ]*3);\n    \n    new_coords[0][0] = point_[1].x;\n    new_coords[0][1] = point_[1].y;\n    new_coords[0][2] = point_[2].x;\n    new_coords[0][3] = point_[2].y;\n    new_coords[0][4] = point_[3].x;\n    new_coords[0][5] = point_[3].y;\n    \n\tpntswap (&point_[0], &point_[3]);\n\tpntswap (&point_[1], &point_[2]);\n\t\n\tpoint_[1].x -= xdec;\n\tpoint_[2].x -= xdec;\n\tpoint_[2].y = point_[3].y - ToRendererX( m_doc->m_rendInterl[ staffSize ]);\n    \n    new_coords[1][0] = point_[1].x;\n    new_coords[1][1] = point_[1].y;\n    new_coords[1][2] = point_[2].x;\n    new_coords[1][3] = point_[2].y;\n    new_coords[1][4] = point_[3].x;\n    new_coords[1][5] = point_[3].y;\n    \n    dc->DrawComplexBezierPath(point_[3].x, point_[3].y, new_coords[0], new_coords[1]);\n    \n    dc->ResetPen();\n    dc->ResetBrush();\n        \n\treturn;\n}\n\n\nvoid MusRC::DrawBarlines( MusDC *dc, MusMeasure *measure, MusStaffGrp *staffGrp, int x, MusBarline *barline )\n{\n    assert( measure );\n    assert( staffGrp );\n    \n    if ( !staffGrp->GetBarthru() ) {\n        // recursively draw the children (staffDef or staffGrp)\n        int i;\n        MusStaffGrp *childStaffGrp = NULL;\n        MusStaffDef *childStaffDef = NULL;\n        for (i = 0; i < staffGrp->GetChildCount(); i++) {\n            childStaffGrp = dynamic_cast<MusStaffGrp*>(staffGrp->GetChild( i ));\n            childStaffDef = dynamic_cast<MusStaffDef*>(staffGrp->GetChild( i ));\n            if ( childStaffGrp ) {\n                DrawBarlines( dc, measure, childStaffGrp, x, barline );\n            }\n            else if ( childStaffDef ) {\n                MusStaff *staff = measure->GetStaffWithNo( childStaffDef->GetStaffNo() );\n                if (!staff ) {\n                    Mus::LogDebug(\"Could not get staff (%d) while drawing staffGrp - Mus::DrawBarlines\", childStaffDef->GetStaffNo() );\n                    continue;\n                }\n                int y_top = staff->m_yDrawing;\n                // for the bottom position we need to take into account the number of lines and the staff size\n                int y_bottom = staff->m_yDrawing - (staff->portNbLine - 1) * m_doc->m_rendInterl[staff->staffSize];\n                DrawBarline( dc, x, y_top, y_bottom, barline );\n                if ( barline->HasRepetitionDots() ) {\n                    DrawBarlineDots( dc, x, staff, barline );\n                }\n            }\n        }\n    }\n    else {\n \n        ListOfMusObjects *staffDefs = staffGrp->GetList( staffGrp );\n        if ( staffDefs->empty() ) {\n            return;\n        }\n        \n        // Get the first and last staffDef of the staffGrp\n        MusStaffDef *firstDef = dynamic_cast<MusStaffDef*>(staffDefs->front());\n        MusStaffDef *lastDef = dynamic_cast<MusStaffDef*>(staffDefs->back());\n        \n        if (!firstDef || !lastDef ) {\n            Mus::LogDebug(\"Could not get staffDef while drawing staffGrp - Mus::DrawStaffGrp\");\n            return;\n        }\n        \n        // Get the corresponding staff looking at the previous (or first) measure\n        MusStaff *first = measure->GetStaffWithNo( firstDef->GetStaffNo() );\n        MusStaff *last = measure->GetStaffWithNo( lastDef->GetStaffNo() );\n        \n        if (!first || !last ) {\n            Mus::LogDebug(\"Could not get staff (%d; %d) while drawing staffGrp - Mus::DrawStaffGrp\", firstDef->GetStaffNo(), lastDef->GetStaffNo() );\n            return;\n        }\n        \n        int y_top = first->m_yDrawing;\n        // for the bottom position we need to take into account the number of lines and the staff size\n        int y_bottom = last->m_yDrawing - (last->portNbLine - 1) * m_doc->m_rendInterl[last->staffSize];\n        \n        DrawBarline( dc, x, y_top, y_bottom, barline );\n        \n        // Now we have a barthru barline, but we have dots so we still need to go through each staff\n        if ( barline->HasRepetitionDots() ) {\n            int i;\n            MusStaffDef *childStaffDef = NULL;\n            for (i = 0; i < staffGrp->GetChildCount(); i++) {\n                childStaffDef = dynamic_cast<MusStaffDef*>(staffGrp->GetChild( i ));\n                if ( childStaffDef ) {\n                    MusStaff *staff = measure->GetStaffWithNo( childStaffDef->GetStaffNo() );\n                    if (!staff ) {\n                        Mus::LogDebug(\"Could not get staff (%d) while drawing staffGrp - Mus::DrawBarlines\", childStaffDef->GetStaffNo() );\n                        continue;\n                    }\n                    DrawBarlineDots( dc, x, staff, barline );\n                }\n            }\n        }\n    }\n}\n\nvoid MusRC::DrawBarline( MusDC *dc, int x, int y_top, int y_bottom, MusBarline *barline )\n{\n    assert( dc );\n\n\tint x1 = x - m_doc->m_rendBeamWidth[0] - m_doc->m_env.m_barlineWidth;\n\tint x2 = x + m_doc->m_rendBeamWidth[0] + m_doc->m_env.m_barlineWidth;\n    \n\tif (barline->m_barlineType == BARLINE_SINGLE)\n    {\n        v_bline( dc , y_top, y_bottom, x, m_doc->m_env.m_barlineWidth);\n    }\n    else if (barline->m_barlineType == BARLINE_RPTBOTH)\n    {\n        v_bline( dc , y_top, y_bottom, x1, m_doc->m_env.m_barlineWidth);\n        v_bline( dc , y_top, y_bottom, x, m_doc->m_rendBeamWidth[0]);\n        v_bline( dc , y_top, y_bottom, x2, m_doc->m_env.m_barlineWidth);\n    }\n    else if (barline->m_barlineType  == BARLINE_RPTSTART)\n    {\n        v_bline( dc , y_top, y_bottom, x, m_doc->m_rendBeamWidth[0]);\n        v_bline( dc , y_top, y_bottom, x2, m_doc->m_env.m_barlineWidth);\n    }\n    else if (barline->m_barlineType == BARLINE_RPTEND)\n\t{\n        v_bline( dc , y_top, y_bottom, x1, m_doc->m_env.m_barlineWidth);\n        v_bline( dc , y_top, y_bottom, x, m_doc->m_rendBeamWidth[0]);\n\t}\n\telse if (barline->m_barlineType  == BARLINE_DBL)\n\t{\n        // Narrow the bars a little bit - should be centered?\n        x1 += m_doc->m_env.m_barlineWidth;\n        v_bline( dc , y_top, y_bottom, x, m_doc->m_env.m_barlineWidth);\n        v_bline( dc , y_top, y_bottom, x1, m_doc->m_env.m_barlineWidth);\n\t}\n\telse if (barline->m_barlineType  == BARLINE_END)\n    {\n        v_bline( dc , y_top, y_bottom, x1, m_doc->m_env.m_barlineWidth);\n        v_bline( dc , y_top, y_bottom, x, m_doc->m_rendBeamWidth[0]);\n    }\n}\n\n \nvoid MusRC::DrawBarlineDots ( MusDC *dc, int x, MusStaff *staff, MusBarline *barline )\n{\n\tassert( dc ); // DC cannot be NULL\n    \n\tint x1 = x - 2 * m_doc->m_rendBeamWidth[0] - m_doc->m_env.m_barlineWidth;\n\tint x2 = x + 2 * m_doc->m_rendBeamWidth[0] + m_doc->m_env.m_barlineWidth;\n    \n    int y_bottom = staff->m_yDrawing - staff->portNbLine  * m_doc->m_rendHalfInterl[staff->staffSize];\n    int y_top = y_bottom + m_doc->m_rendInterl[staff->staffSize];\n \n    if ((barline->m_barlineType  == BARLINE_RPTSTART) || (barline->m_barlineType == BARLINE_RPTBOTH))\n    {\n        DoDrawDot(dc, x2, y_bottom );\n        DoDrawDot(dc, x2, y_top );\n\n    }\n    if ((barline->m_barlineType == BARLINE_RPTEND) || (barline->m_barlineType == BARLINE_RPTBOTH))\n\t{\n        DoDrawDot(dc, x1, y_bottom );\n        DoDrawDot(dc, x1, y_top );\n\t}\n    \n\treturn;\n}\n\n\nvoid MusRC::DrawPartialBarline ( MusDC *dc, MusSystem *system, int x, MusStaff *pportee)\n{\n\tassert( dc ); // DC cannot be NULL\n\n\tint b, bb;\n\n    /* ax3\n\tMusStaff *next = system->GetNext( NULL );\n\tif ( next )\n\t{\t\n\t\tb = pportee->m_yDrawing - m_doc->m_rendStaffSize[ pportee->staffSize ]*2;\n\t\tbb = next->m_yDrawing - m_doc->m_rendStaffSize[ next->staffSize];\n\n\t\tif (m_doc->m_env.m_barlineWidth > 2)\t// barres plus epaisses qu'un 1/2 mm\n\t\t\tv_bline2 ( dc, b, bb, x,  m_doc->m_env.m_barlineWidth);\n\t\telse\n\t\t\tv_bline ( dc, b, bb, x,  m_doc->m_env.m_barlineWidth);\n\t\t\n\t}\n    */\n\n}\n\n\n\n//----------------------------------------------------------------------------\n// MusRC - MusMeasure\n//----------------------------------------------------------------------------\n\nvoid MusRC::DrawMeasure( MusDC *dc, MusMeasure *measure, MusSystem *system )\n{\n\tassert( dc ); // DC cannot be NULL\n    \n    // This is a special case where we do not draw (SVG, Bounding boxes, etc.) the measure if un-measured music\n    if ( measure->IsMeasuredMusic()) {\n        dc->StartGraphic( measure, \"measure\", measure->GetUuid() );\n    }\n    \n    // Here we set the appropriate y value to be used for drawing\n    // With Raw documents, we use m_xRel that is calculated by the layout algorithm\n    // With Transcription documents, we use the m_xAbs\n    if ( measure->m_xAbs == AX_UNSET ) {\n        assert( m_doc->GetType() == Raw );\n        measure->m_xDrawing = measure->m_xRel + system->m_xDrawing;\n    }\n    else\n    {\n        assert( m_doc->GetType() == Transcription );\n        measure->m_xDrawing = measure->m_xAbs;\n    }\n    \n\tMusStaff *staff = NULL;\n\tint j;\n    \n\tfor(j = 0; j < measure->GetStaffCount(); j++)\n\t{\n\t\tstaff = (MusStaff*)measure->m_children[j];\n\t\tDrawStaff( dc, staff, measure, system );\n    }\n\n    if ( measure->GetLeftBarlineType() != BARLINE_NONE) {\n        DrawScoreDef( dc, &m_drawingScoreDef, measure, measure->m_xDrawing, measure->GetLeftBarline() );\n    }\n    if ( measure->GetRightBarlineType() != BARLINE_NONE) {\n        DrawScoreDef( dc, &m_drawingScoreDef, measure, measure->m_xDrawing + measure->GetXRelRight(), measure->GetRightBarline() );\n    }\n    \n    if ( measure->IsMeasuredMusic()) {\n        dc->EndGraphic( measure, this );\n    }\n}\n\n\n//----------------------------------------------------------------------------\n// MusRC - MusStaff\n//----------------------------------------------------------------------------\n\nint MusRC::CalculateNeumePosY ( MusStaff *staff, char note, int dec_clef, int oct)\n{\n    assert(staff); // Pointer to staff cannot be NULL\"\n\n\tstatic char notes[] = {1,2,3,4,5,6,7};\n\tint y_int;\n\tchar *pnote, i;\n\tpnote = &notes[0] - 1;\n\t\n\ty_int = ((dec_clef + oct*7) - 17 ) * m_doc->m_rendHalfInterl[staff->staffSize];\n\tif (staff->portNbLine > 4)\n\t\ty_int -= ((staff->portNbLine - 4) * 2) * m_doc->m_rendHalfInterl[staff->staffSize];\n\t\n\tfor (i=0; i<(signed)sizeof(notes); i++)\n\t\tif (*(pnote+i) == note)\n\t\t\treturn(y_int += (i*m_doc->m_rendHalfInterl[staff->staffSize]));\n\treturn 0;\n}\n\nint MusRC::CalculatePitchPosY ( MusStaff *staff, char pname, int dec_clef, int oct)\n{\n    assert(staff); // Pointer to staff cannot be NULL\"\n\t\n    static char touches[] = {PITCH_C,PITCH_D,PITCH_E,PITCH_F,PITCH_G,PITCH_A,PITCH_B};\n\tint y_int;\n\tchar *ptouche, i;\n\tptouche=&touches[0];\n\n\ty_int = ((dec_clef + oct*7) - 9 ) * m_doc->m_rendHalfInterl[staff->staffSize];\n\tif (staff->portNbLine > 5)\n\t\ty_int -= ((staff->portNbLine - 5) * 2) * m_doc->m_rendHalfInterl[staff->staffSize];\n\n\t/* exprime distance separant m_yDrawing de\n\tposition 1e Si, corrigee par dec_clef et oct. Elle est additionnee\n\tensuite, donc elle doit etre NEGATIVE si plus bas que m_yDrawing */\n\tfor (i=0; i<(signed)sizeof(touches); i++)\n\t\tif (*(ptouche+i) == pname)\n\t\t\treturn(y_int += ((i+1)*m_doc->m_rendHalfInterl[staff->staffSize]));\n\treturn 0;\n}\n\nint MusRC::CalculateRestPosY ( MusStaff *staff, char duration)\n{\n    assert(staff); // Pointer to staff cannot be NULL\"\n\n\tint staff_space = m_doc->m_rendHalfInterl[staff->staffSize];\n    int base = -17 * staff_space; // -17 is a magic number copied from above\n    int offset;\n    \n    switch (duration) {\n        case DUR_LG: offset = 12; break;\n        case DUR_BR: offset = 13; break;\n        case DUR_1: offset = 15; break;\n        case DUR_2: offset = 13; break;\n        case DUR_4: offset = 11; break;\n        case DUR_8: offset = 11; break;\n        case DUR_16: offset = 11; break;\n        case DUR_32: offset = 11; break;\n        case DUR_64: offset = 10; break;\n        case DUR_128: offset = 10; break;\n        case DUR_256: offset = 9; break;\n        case VALSilSpec: offset = 15; break; // MM rests have same height as wholes\n            \n        default: offset = 12; break; // Signal an error, put the clef up high\n    }\n    return base + staff_space * offset;\n}\n\nvoid MusRC::DrawStaffLines( MusDC *dc, MusStaff *staff, MusMeasure *measure, MusSystem *system )\n{\n\tassert( dc ); // DC cannot be NULL\n        \n    if (staff->invisible)\n        return;\n\n\tint j, x1, x2, yy;\n\n\tyy = staff->m_yDrawing;\n\n\tx1 = system->m_systemLeftMar;\n    x2 = m_doc->m_rendPageWidth - m_doc->m_rendPageLeftMar - m_doc->m_rendPageRightMar - system->m_systemRightMar;\n\n\tdc->SetPen( m_currentColour, ToRendererX( m_doc->m_env.m_staffLineWidth ), AxSOLID );\n    dc->SetBrush( m_currentColour , AxSOLID );\n\n\tx1 = ToRendererX (x1);\n\tx2 = ToRendererX (x2);\n\n\tfor(j = 0;j < staff->portNbLine; j++)\n\t{\n\t\tdc->DrawLine( x1 , ToRendererY ( yy ) , x2 , ToRendererY ( yy ) );\n\t\tyy -= m_doc->m_rendInterl[staff->staffSize];\n\t}\n    \n    dc->ResetPen( );\n    dc->ResetBrush( );\n    \n\treturn;\n}\n\n\n\nvoid MusRC::DrawStaff( MusDC *dc, MusStaff *staff, MusMeasure *measure, MusSystem *system )\n{\n\tassert( dc ); // DC cannot be NULL\n    \n    dc->StartGraphic( staff, \"staff\", staff->GetUuid());\n    \n    // Here we set the appropriate y value to be used for drawing\n    // With Raw documents, we use m_yRel that is calculated by the layout algorithm\n    // With Transcription documents, we use the m_yAbs\n    if ( staff->m_yAbs == AX_UNSET ) {\n        assert( m_doc->GetType() == Raw );\n        staff->m_yDrawing = staff->GetYRel() + system->m_yDrawing;\n    }\n    else\n    {\n        assert( m_doc->GetType() == Transcription );\n        staff->m_yDrawing = staff->m_yAbs;\n    }\n    \n    DrawStaffLines( dc, staff, measure, system );\n        \n\tMusLayer *layer = NULL;\n\tint j;\n    \n\tfor(j = 0; j < staff->GetLayerCount(); j++)\n\t{\n\t\tlayer = (MusLayer*)staff->m_children[j];\n\t\tDrawLayer( dc, layer, staff, measure );\n\t}\n    \n    dc->EndGraphic( staff, this );\n}\n\n\n//----------------------------------------------------------------------------\n// MusRC - MusLayer\n//----------------------------------------------------------------------------\n\n\n// a partir d'un y, trouve la hauteur d'une note exprimee en code touche et\n// octave. Retourne code clavier, et situe l'octave. \n\nint MusRC::CalculatePitchCode ( MusLayer *layer, int y_n, int x_pos, int *octave )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(layer->m_parent); // Pointer to staff cannot be NULL\"\n\t\n    static int touches[] = {PITCH_C,PITCH_D,PITCH_E,PITCH_F,PITCH_G,PITCH_A,PITCH_B};\n\tint y_dec, yb, plafond;\n\tint degres, octaves, position, code;\n\tchar clefId=0;\n\n    int staffSize = ((MusStaff*)layer->m_parent)->staffSize;\n\t// calculer position du do central en fonction clef\n\ty_n += (int) m_doc->m_rendVerticalUnit2[staffSize];\n\tyb = ((MusStaff*)layer->m_parent)->m_yDrawing -  m_doc->m_rendStaffSize[((MusStaff*)layer->m_parent)->staffSize]*2; // UT1 default\n\t\n\n\tplafond = yb + 8 *  m_doc->m_rendOctaveSize[staffSize];\n\tif (y_n > plafond)\n\t\ty_n = plafond;\n\n    MusLayerElement *previous = NULL;\n\tMusLayerElement *pelement = layer->GetAtPos( x_pos );\n\tif ( (previous = layer->GetPrevious( pelement ) ) )\n\t\tpelement = previous;\n\n\tMusClef *clef = layer->GetClef (pelement);\n    if (clef) {\n        clefId = clef->m_clefId;\n        yb += (clef->GetClefOffset()) * m_doc->m_rendHalfInterl[staffSize];\t// UT1 reel\n    }\n\tyb -= 4 *  m_doc->m_rendOctaveSize[staffSize];\t// UT, note la plus grave\n\n\ty_dec = y_n - yb;\t// decalage par rapport a UT le plus grave\n\n\tif (y_dec< 0)\n\t\ty_dec = 0;\n\n\tdegres = y_dec /  m_doc->m_rendHalfInterl[staffSize];\t// ecart en degres (PITCH_C..PITCH_B) par rapport a UT1\n\toctaves = degres / 7;\n\tposition = degres % 7;\n\n\tcode = touches[position];\n\t*octave = octaves /*- OCTBIT*/; // LP remove OCTBIT : oct 0  7\n\n\treturn (code);\n}\n\n\nMusPoint CalcPositionAfterRotation( MusPoint point , float rot_alpha, MusPoint center)\n{\n    int distCenterX = (point.x - center.x);\n    int distCenterY = (point.y - center.y);\n    // pythagore, distance entre le point d'origine et le centre\n    int distCenter = (int)sqrt( pow( (double)distCenterX, 2 ) + pow( (double)distCenterY, 2 ) );\n\t\n\t// angle d'origine entre l'axe x et la droite passant par le point et le centre\n    float alpha = atan ( (float)distCenterX / (float)(distCenterY) );\n    \n    MusPoint new_p = center;\n    int new_distCenterX, new_distCenterY;\n\n    new_distCenterX = ( (int)( sin( alpha - rot_alpha ) * distCenter ) );\n\tnew_p.x += new_distCenterX;\n\n    new_distCenterY = ( (int)( cos( alpha - rot_alpha ) * distCenter ) );\n\tnew_p.y += new_distCenterY;\n\n    return new_p;\n}\n\n/**\n  x1 y1 = point de depart\n  x2 y2 = point d'arrivee\n  up = liaison vers le haut\n  heigth = hauteur de la liaison (  plat )\n  **/\nvoid MusRC::DrawSlur( MusDC *dc, MusLayer *layer, int x1, int y1, int x2, int y2, bool up, int height )\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(layer->m_parent); // Pointer to staff cannot be NULL\"\n\n    dc->SetPen( m_currentColour, 1, AxSOLID );\n    dc->SetBrush( m_currentColour, AxSOLID );\n\n\n    int distX = x1 - x2;\n    int distY = y1 - y2;\n    // pythagore, distance entre les points de depart et d'arrivee\n    int dist = (int)sqrt( pow( (double)distX, 2 ) + pow( (double)distY, 2 ) );\n\n\t// angle\n    float alpha2 = float( distY ) / float( distX );\n    alpha2 = atan( alpha2 );\n\tMusPoint orig(0,0);\n\n\tint step = dist / 10; // espace entre les points\n\tint nbpoints = dist / step;\n\tdist += 2*step; // ajout d'un pas de chaque cote, supprime  l'affichage\n\tif ( nbpoints <= 2)\n\t\tnbpoints = 3;\n\telse if ( !(nbpoints % 2) ) // nombre impair de points\n\t\tnbpoints++;\n\n\tint i,j, k;\n\tdouble a, b;\n\ta = dist / 2; // largeur de l'ellipse\n\tint nbp2 = nbpoints/2;\n\tMusPoint *points = new MusPoint[2*nbpoints]; // buffer double - aller retour\n\n\t// aller\n\tb = 100; // hauteur de l'ellipse\n\tpoints[nbp2].x = (int)a; // point central\n\tpoints[nbp2].y = (int)b;\n\tfor(i = 0, j = nbpoints - 1, k = 1; i < nbp2; i++, j--, k++) // calcul de l'ellipse\n\t{\n\t\tpoints[i].x = k*step;\n\t\tpoints[i+nbp2+1].y = (int)sqrt( (1 - pow((double)points[i].x,2) / pow(a,2)) * pow(b,2) );\n\t\tpoints[j].x = dist - points[i].x;\n\t\tpoints[j-nbp2-1].y = points[i+nbp2+1].y;\t\t\n\t}\n\tint dec_y = points[0].y; // decalage y  cause des 2 pas ajoutes\n\tfor(i = 0; i < nbpoints; i++)\n\t{\n\t\tpoints[i] = CalcPositionAfterRotation( points[i], alpha2, orig ); // rotation\t\t\n\t\tpoints[i].x = ToRendererX( points[i].x + x1 - 1*step ); // transposition\n\t\tpoints[i].y = ToRendererY( points[i].y + y1 - dec_y );\n\t}\n\tdc->DrawSpline( nbpoints, points );\n\n\t// retour idem\n\tb = 90;\t\n\tpoints[nbp2+nbpoints].x = (int)a;\n\tpoints[nbp2+nbpoints].y = (int)b;\n\tfor(i = nbpoints, j = 2*nbpoints - 1, k = 1; i < nbp2+nbpoints; i++, j--, k++)\n\t{\t\n\t\tpoints[j].x = k*step;\n\t\tpoints[i+nbp2+1].y = (int)sqrt( (1 - pow((double)points[j].x,2) / pow(a,2)) * pow(b,2) );\n\t\tpoints[i].x = dist - points[j].x;\n\t\tpoints[j-nbp2-1].y = points[i+nbp2+1].y;\t\n\t}\n\tdec_y = points[nbpoints].y;\n\n\tfor(i = nbpoints; i < 2*nbpoints; i++)\n\t{\n\t\tpoints[i] = CalcPositionAfterRotation( points[i], alpha2, orig );\n\t\tpoints[i].x = ToRendererX( points[i].x + x1 - 1*step );\n\t\tpoints[i].y = ToRendererY( points[i].y + y1 - dec_y );\n\t}\n\tdc->DrawSpline( nbpoints, points+nbpoints );\n\n\t// remplissage ?\n\n    dc->ResetPen( );\n    dc->ResetBrush( );\n\n\tdelete[] points;\n\n}\n\nvoid MusRC::DrawLayer( MusDC *dc, MusLayer *layer, MusStaff *staff, MusMeasure *measure)\n{\n\tassert( dc ); // DC cannot be NULL\n\n\tMusLayerElement *element = NULL;\n\tint j;\n    \n    // first we need to clear the drawing list of postponed elements\n    layer->ResetDrawingList();\n    \n    if (layer->GetClefAttr()) {\n        DrawElement(dc, layer->GetClefAttr(), layer, measure, staff);\n    }\n    if (layer->GetKeySigAttr()) {\n        DrawElement(dc, layer->GetKeySigAttr(), layer, measure, staff);\n    }\n    if (layer->GetMensurAttr()) {\n        DrawElement(dc, layer->GetMensurAttr(), layer, measure, staff);\n    }\n    \n\tfor(j = 0; j < layer->GetElementCount(); j++)\n\t{\n\t\telement = (MusLayerElement*)layer->m_children[j];\n        \n        if ( !element->m_in_layer_app ) {\n            DrawElement( dc, element, layer, measure, staff );\n        }\n\t}\n    \n    // first draw the beams\n    DrawLayerList(dc, layer, staff, measure, &typeid(MusBeam) );\n    // then tuplets\n    DrawLayerList(dc, layer, staff, measure, &typeid(MusTuplet) );\n    // then ties\n    DrawLayerList(dc, layer, staff, measure, &typeid(MusTie) );\n    \n}\n\n\nvoid MusRC::DrawLayerList( MusDC *dc, MusLayer *layer, MusStaff *staff, MusMeasure *measure, const std::type_info *elementType )\n{\n\tassert( dc ); // DC cannot be NULL\n    \n    ListOfMusObjects *drawingList = layer->GetDrawingList();\n\tMusLayerElement *element = NULL;\n    \n    ListOfMusObjects::iterator iter;\n    \n    for (iter = drawingList->begin(); iter != drawingList->end(); ++iter)\n    {\n        element = dynamic_cast<MusLayerElement*>(*iter);\n        if (!element) continue; \n        \n        if ( (typeid(*element) == *elementType) &&  (*elementType == typeid(MusBeam) ) ) {\n            MusBeam *beam = dynamic_cast<MusBeam*>(element);\n            DrawBeam( dc, layer, beam, staff );\n        }\n        else if ( (typeid(*element) == *elementType) &&  (*elementType == typeid(MusTuplet) ) ) {\n            MusTuplet *tuplet = dynamic_cast<MusTuplet*>(element);\n            DrawTuplet( dc, tuplet, layer, staff );\n        }\n        else if ( (typeid(*element) == *elementType) &&  (*elementType == typeid(MusTie) ) ) {\n            MusTie *tie = dynamic_cast<MusTie*>(element);\n            DrawTie( dc, tie, layer, staff, measure );\n        }\n    }\n}\n\n\n\n\n\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrc_tuplet.cpp\n// Author:      Rodolfo Zitellini\n// Created:     21/08/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musrc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"musbarline.h\"\n#include \"musbeam.h\"\n#include \"musclef.h\"\n#include \"muskeysig.h\"\n#include \"muslayerelement.h\"\n#include \"musleipzigbbox.h\"\n#include \"musmensur.h\"\n#include \"musnote.h\"\n#include \"musrest.h\"\n#include \"mussymbol.h\"\n#include \"mustie.h\"\n#include \"mustuplet.h\"\n\n#define TUPLET_OFFSET 20\n#define OBLIQUE_OFFSET 0x52 //move to oblique figures\n\nstd::string MusRC::IntToObliqueFigures(unsigned int number) {\n    char buf[16];\n    unsigned int len;\n    \n    memset(buf, 0x00, sizeof(buf));\n    \n    // We do not convert more that FF values\n    if (number > 0xFF) number = 0xFF;\n    \n    sprintf(buf, \"%i\", number);\n    \n    len = strlen(buf);\n    assert((sizeof(buf) - 1) > len ); // String conversion overflow \n    \n    for (unsigned int i = 0; i < strlen(buf); i++) {\n        buf[i] += OBLIQUE_OFFSET;\n    }\n    \n    return std::string(buf);\n}\n\n/**\n * Analyze a tuplet object and figure out if all the notes are in the same beam\n * or not\n */\nbool MusRC::OneBeamInTuplet(MusTuplet* tuplet) {\n    \n    MusBeam *currentBeam, *firstBeam = NULL;\n    ArrayOfMusObjects elems;\n    \n    // Are we contained in a beam?\n    if (dynamic_cast<MusBeam*>(tuplet->GetFirstParent(&typeid(MusBeam), 3)) && !tuplet->m_children.empty())\n        return true;\n\n    \n    // No we contain a beam? Go on and search for it in the children\n    for (unsigned int i = 0; i < tuplet->m_children.size(); i++) {\n        if (dynamic_cast<MusNote*>(tuplet->m_children[i]))\n            return false;\n        \n        currentBeam = dynamic_cast<MusBeam*>(tuplet->m_children[i]);\n        \n        if (!currentBeam)\n            continue;\n        \n        // The first time we find a beam, set the previous one\n        if (firstBeam == NULL)\n            firstBeam = currentBeam;\n        \n        // First beam has to be the same always\n        // if it is a different one, it means the tuplet\n        // is broken into two beams\n        if (firstBeam != currentBeam)\n            return false;\n        \n    }\n    \n    // Get here if tuplet\n    // has no beams or notes\n    // should not happen!\n    assert(currentBeam);\n        \n    return true;\n}\n\n/**\n * This function gets the tuplet coords for drawing the bracket and number\n * @param tuplet - the tuplet object\n * @param layer - layer obj\n * @param start, end, center - these are the coordinates returned\n * @return the direction of the beam\n *\n * We can divide the tuplets in three types:\n * 1) All notes beamed\n * 2) All notes unbeamed\n * 3) a mixture of the above\n * \n * The first type are the simplest to calculate, as we just need the \n * start and end of the beam\n * types 2 and 3 are threaed in the same manner to calculate the points:\n * - if all the stems are in the same direction, the bracket goes from the\n *   first to the last stem and the number is centered. If a stem in the\n *   middle il longher than the first or last, the y positions are offsetted\n *   accordingly to evitate collisions\n * - if stems go in two different directions, the bracket and number are\n *   placed in the side that has more stems in that direction. If the\n *   stems are equal, if goes up. In this case the bracket is orizontal\n *   so we just need the tallnes of the most tall stem. If a notehead\n *   il lower (or upper) than this stem, we compensate that too with an offset\n \n */\n\nbool MusRC::GetTupletCoordinates(MusTuplet* tuplet, MusLayer *layer, MusPoint* start, MusPoint* end, MusPoint *center) {\n    MusPoint first, last;\n    int x, y;\n    bool direction = true; //true = up, false = down\n    \n    MusLayerElement *firstNote, *lastNote;\n    \n    // AllNotesBeamed tries to figure out if all the notes are in the same beam\n    if (OneBeamInTuplet(tuplet)) {\n        \n        firstNote = dynamic_cast<MusLayerElement*>(tuplet->m_list.front());\n        lastNote = dynamic_cast<MusLayerElement*>(tuplet->m_list.back());\n\n        // yes they are in a beam\n        // get the x position centered from the STEM so it looks better\n        // NOTE start and end are left to 0, this is the signal that no bracket has to be drawn\n        x = firstNote->m_stem_start.x + (lastNote->m_stem_start.x - firstNote->m_stem_start.x) / 2;\n        \n        // align the center point at the exact center of the first an last stem\n        // TUPLET_OFFSET is summed so it does not collide with the stem\n        if (firstNote->m_drawn_stem_dir)\n            y = lastNote->m_stem_end.y + (firstNote->m_stem_end.y - lastNote->m_stem_end.y) / 2 + TUPLET_OFFSET;\n        else \n            y = lastNote->m_stem_end.y + (firstNote->m_stem_end.y - lastNote->m_stem_end.y) / 2 - TUPLET_OFFSET;\n        \n        // Copy the generated coordinates\n        center->x = x;\n        center->y = y;\n        direction =  firstNote->m_drawn_stem_dir; // stem direction is same for all notes\n    } else {\n            \n        //ArrayOfMusObjects all_notes;\n        \n        // We can have a mixed group of Beams and notes. Flatten it\n        /*\n        for (unsigned int i = 0; i < tuplet->m_children.size(); i++) {\n            if (dynamic_cast<MusNote*>(tuplet->m_children[i]))\n                all_notes.push_back(tuplet->m_children[i]);\n            \n            if (dynamic_cast<MusBeam*>(tuplet->m_children[i])) {\n                MusBeam* beam = dynamic_cast<MusBeam*>(tuplet->m_children[i]);\n                std::copy( beam->m_list.begin(), beam->m_list.end(), std::back_inserter( all_notes ) );\n            }\n        }*/\n        \n        firstNote = dynamic_cast<MusLayerElement*>(tuplet->m_list.front());\n        lastNote = dynamic_cast<MusLayerElement*>(tuplet->m_list.back());\n        \n        // There are unbeamed notes of two different beams\n        // treat all the notes as unbeames\n        int ups = 0, downs = 0; // quantity of up- and down-stems\n        \n        // In this case use the center of the notehead to calculate the exact center\n        // as it looks better\n        x = firstNote->m_xDrawing + (lastNote->m_xDrawing - firstNote->m_xDrawing) / 2;\n        \n        // Return the start and end position for the brackes\n        // starting from the first edge and last of the BBoxes\n        start->x = firstNote->m_selfBB_x1;\n        end->x = lastNote->m_selfBB_x2;\n        \n        // THe first step is to calculate all the stem directions\n        // cycle into the elements and count the up and down dirs\n        ListOfMusObjects::iterator iter = tuplet->m_list.begin();\n        while (iter != tuplet->m_list.end()) {\n            MusLayerElement *currentNote = dynamic_cast<MusLayerElement*>(*iter);\n            \n            if (currentNote->m_drawn_stem_dir == true)\n                ups++;\n            else\n                downs++;\n            \n            ++iter;\n        }\n        // true means up\n        direction = ups > downs ? true : false;\n        \n        // if ups or downs is 0, it means all the stems go in the same direction\n        if (ups == 0 || downs == 0) {\n            \n            // Calculate the average between the first and last stem\n            // set center, start and end too.\n            if (direction) { // up\n                y = lastNote->m_stem_end.y + (firstNote->m_stem_end.y - lastNote->m_stem_end.y) / 2 + TUPLET_OFFSET;\n                start->y = firstNote->m_stem_end.y + TUPLET_OFFSET;\n                end->y = lastNote->m_stem_end.y + TUPLET_OFFSET;\n            } else {\n                y = lastNote->m_stem_end.y + (firstNote->m_stem_end.y - lastNote->m_stem_end.y) / 2 - TUPLET_OFFSET;\n                start->y = firstNote->m_stem_end.y - TUPLET_OFFSET;\n                end->y = lastNote->m_stem_end.y - TUPLET_OFFSET;\n            }\n            \n            // Now we cycle again in all the intermediate notes (i.e. we start from the second note\n            // and stop at last -1)\n            // We will see if the position of the note is more (or less for down stems) of the calculated\n            // average. In this case we offset down or up all the points\n            iter = tuplet->m_list.begin();\n            while (iter != tuplet->m_list.end()) {\n                 MusLayerElement *currentNote = dynamic_cast<MusLayerElement*>(*iter);\n                \n                if (direction) {\n                    // The note is more than the avg, adjust to y the difference\n                    // from this note to the avg\n                    if (currentNote->m_stem_end.y + TUPLET_OFFSET > y) {\n                        int offset = y - (currentNote->m_stem_end.y + TUPLET_OFFSET);\n                        y -= offset;\n                        end->y -= offset;\n                        start->y -= offset;\n                    }\n                } else {\n                    if (currentNote->m_stem_end.y - TUPLET_OFFSET < y) {\n                        int offset = y - (currentNote->m_stem_end.y - TUPLET_OFFSET);\n                        y -= offset;\n                        end->y -= offset;\n                        start->y -= offset;\n                    }\n                }\n                \n                ++iter;\n            }\n            \n            \n        } else { // two directional beams\n            // this case is similar to the above, but the bracket is only orizontal\n            // y is 0 because the final y pos is above the tallest stem\n            y = 0;\n            \n            // Find the tallest stem and set y to it (with the offset distance)\n            iter = tuplet->m_list.begin();\n            while (iter != tuplet->m_list.end()) {\n                MusLayerElement *currentNote = dynamic_cast<MusLayerElement*>(*iter);\n                \n                if (currentNote->m_drawn_stem_dir == direction) {\n                                        \n                    if (direction) {\n                        if (y == 0 || currentNote->m_stem_end.y + TUPLET_OFFSET >= y)\n                            y = currentNote->m_stem_end.y + TUPLET_OFFSET;\n                    } else {\n                        if (y == 0 || currentNote->m_stem_end.y - TUPLET_OFFSET <= y)\n                            y = currentNote->m_stem_end.y - TUPLET_OFFSET;\n                    }\n                        \n                } else {\n                    // do none for now\n                    // but if a notehead with a reversed stem is taller that the last\n                    // calculated y, we need to offset\n                }\n                \n                ++iter;\n            }\n            \n            // end and start are on the same line (and so il center when set later)\n            end->y = start->y = y;\n        }\n    }\n        \n    \n    center->x = x;\n    center->y = y;\n    return direction;\n}\n\n\nvoid MusRC::DrawTuplet( MusDC *dc, MusTuplet *tuplet, MusLayer *layer, MusStaff *staff)\n{\n    assert(layer); // Pointer to layer cannot be NULL\"\n    assert(staff); // Pointer to staff cannot be NULL\"\n    \n    tuplet->ResetList(tuplet);\n    \n    int txt_lenght, txt_height;\n    \n    std::string notes = IntToObliqueFigures((unsigned int)tuplet->GetNoteCount());\n    \n    dc->GetTextExtent(notes, &txt_lenght, &txt_height);\n    \n    MusPoint start, end, center;\n    bool direction = GetTupletCoordinates(tuplet, layer, &start, &end, &center);\n        \n    // Calculate position for number 0x82\n    // since the number is slanted, move the center left\n    // by 4 pixels so it seems more centered to the eye\n    int txt_x = center.x - (txt_lenght / 2) - 4;\n    //DrawLeipzigFont ( dc, txt_x,  center.y, notes + 0x82, staff, false);\n    \n    putstring(dc, txt_x, center.y, notes, 0);\n    \n    //dc->SetPen(AxBLACK);\n    dc->SetPen(AxBLACK, 2, AxSOLID);\n    \n    // Start is 0 when no line is necessary (i.e. beamed notes)\n    if (start.x > 0) {\n        // Draw the bracket, interrupt where the number is\n        \n        // get the slope\n        double m = (double)(start.y - end.y) / (double)(start.x - end.x);\n        \n        // x = 10 pixels before the number\n        double x = txt_x - 4;\n        // xa = just after, the number is abundant so I do not add anything\n        double xa = txt_x + txt_lenght + 2;\n        \n        // calculate the y coords in the slope\n        double y1 = (double)start.y + m * (x - (double)start.x);\n        double y2 = (double)start.y + m * (xa - (double)start.x);\n        \n        // first line\n        dc->DrawLine(start.x, ToRendererY(start.y), (int)x, ToRendererY((int)y1));\n        // second line after gap\n        dc->DrawLine((int)xa, ToRendererY((int)y2), end.x, ToRendererY(end.y));\n        \n        // vertical bracket lines\n        if (direction) {\n            dc->DrawLine(start.x, ToRendererY(start.y), start.x, ToRendererY(start.y - 10));\n            dc->DrawLine(end.x, ToRendererY(end.y), end.x, ToRendererY(end.y - 10));\n        } else {\n            dc->DrawLine(start.x, ToRendererY(start.y), start.x, ToRendererY(start.y + 10));\n            dc->DrawLine(end.x, ToRendererY(end.y), end.x, ToRendererY(end.y + 10));\n        }\n                \n    }\n    \n    //rz dc->EndGraphic(element, this );\n}","/////////////////////////////////////////////////////////////////////////////\n// Name:        musrest.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musrest.h\"\n\n//----------------------------------------------------------------------------\n// MusRest\n//----------------------------------------------------------------------------\n\nMusRest::MusRest():\n\tMusLayerElement(\"rest-\"), MusDurationInterface(), MusPositionInterface()\n{\n    // by default set automatic height\n    m_pname = REST_AUTO;\n}\n\nMusRest::~MusRest()\n{\n}\n\nbool MusRest::operator==( MusObject& other )\n{\n    MusRest *otherRest = dynamic_cast<MusRest*>( &other );\n    if ( !otherRest ) {\n        return false;\n    }\n    if ( !this->HasIdenticalPositionInterface( otherRest ) ) {\n        return false;\n    }\n    if ( !this->HasIdenticalDurationInterface( otherRest ) ) {\n        return false;\n    }\n    return true;\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musscoredef.cpp\n// Author:      Laurent Pugin\n// Created:     2013/11/08\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musscoredef.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n#include <typeinfo>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musclef.h\"\n#include \"musio.h\"\n#include \"muskeysig.h\"\n#include \"musmensur.h\"\n\n/**\n * Define the maximum levels of staffGrp within a scoreDef\n */\n#define MAX_STAFFGRP_DEPTH 5\n\n//----------------------------------------------------------------------------\n// MusScoreOrStaffDefAttrInterface\n//----------------------------------------------------------------------------\n\nMusScoreOrStaffDefAttrInterface::MusScoreOrStaffDefAttrInterface()\n{\n    m_clef = NULL;\n    m_keySig = NULL;\n    m_mensur = NULL;\n}\n\nMusScoreOrStaffDefAttrInterface::~MusScoreOrStaffDefAttrInterface()\n{\n    if (m_clef) {\n        delete m_clef;\n    }\n    if (m_keySig) {\n        delete m_keySig;\n    }\n    if (m_mensur) {\n        delete m_mensur;\n    }\n}\n\nMusScoreOrStaffDefAttrInterface::MusScoreOrStaffDefAttrInterface( const MusScoreOrStaffDefAttrInterface& interface )\n{\n    m_clef = NULL;\n    m_keySig = NULL;\n    m_mensur = NULL;\n    this->ReplaceClef( interface.m_clef );\n    this->ReplaceKeySig( interface.m_keySig );\n    this->ReplaceMensur( interface.m_mensur );\n}\n\nMusScoreOrStaffDefAttrInterface& MusScoreOrStaffDefAttrInterface::operator=( const MusScoreOrStaffDefAttrInterface& interface )\n{\n\tif ( this != &interface ) // not self assignement\n\t{\n        m_clef = NULL;\n        m_keySig = NULL;\n        m_mensur = NULL;\n        this->ReplaceClef( interface.m_clef );\n        this->ReplaceKeySig( interface.m_keySig );\n        this->ReplaceMensur( interface.m_mensur );\n\t}\n\treturn *this;\n}\n\nvoid MusScoreOrStaffDefAttrInterface::ReplaceClef( MusClef *newClef )\n{\n    if ( newClef ) {\n        if (m_clef) {\n            delete m_clef;\n        }\n        m_clef = new MusClef( *newClef );\n    }\n}\n\nvoid MusScoreOrStaffDefAttrInterface::ReplaceKeySig( MusKeySig *newKeySig )\n{\n    if ( newKeySig ) {\n        if (m_keySig) {\n            delete m_keySig;\n        }\n        m_keySig = new MusKeySig( *newKeySig );\n    }\n}\n\nvoid MusScoreOrStaffDefAttrInterface::ReplaceMensur( MusMensur *newMensur )\n{\n    if ( newMensur ) {\n        if (m_mensur) {\n            delete m_mensur;\n        }\n        m_mensur = new MusMensur( *newMensur );\n    }\n}\n\n//----------------------------------------------------------------------------\n// MusScoreDef\n//----------------------------------------------------------------------------\n\nMusScoreDef::MusScoreDef() :\n\tMusObject(\"scoredef-\"), MusScoreOrStaffDefAttrInterface(), MusObjectListInterface()\n{\n}\n\nMusScoreDef::~MusScoreDef()\n{\n    \n}\n\nvoid MusScoreDef::Clear()\n{\n    ReplaceClef(NULL);\n    ReplaceKeySig(NULL);\n    ReplaceMensur(NULL);\n    ClearChildren();\n}\n\nvoid MusScoreDef::AddStaffGrp( MusStaffGrp *staffGrp )\n{\n    assert( m_children.empty() );\n\tstaffGrp->SetParent( this );\n\tm_children.push_back( staffGrp );\n    Modify();\n}\n\nvoid MusScoreDef::Replace( MusScoreDef *newScoreDef )\n{\n    ReplaceClef( newScoreDef->m_clef );\n    ReplaceKeySig( newScoreDef->m_keySig );\n    ReplaceMensur( newScoreDef->m_mensur );\n    \n    ArrayPtrVoid params;\n\tparams.push_back( this );\n    MusFunctor replaceStaffDefsInScoreDef( &MusObject::ReplaceStaffDefsInScoreDef );\n    newScoreDef->Process( &replaceStaffDefsInScoreDef, params );\n}\n\nvoid MusScoreDef::Replace( MusStaffDef *newStaffDef )\n{\n    // first find the staffDef with the same @n\n    MusStaffDef *staffDef = this->GetStaffDef( newStaffDef->GetStaffNo() );\n    \n    // if found, replace attributes\n    if (staffDef) {\n        staffDef->ReplaceClef( newStaffDef->GetClefAttr() );\n        staffDef->ReplaceKeySig( newStaffDef->GetKeySigAttr() );\n        staffDef->ReplaceMensur( newStaffDef->GetMensurAttr() );\n    }\n}\n\nvoid MusScoreDef::FilterList()\n{\n    // We want to keep only staffDef\n    ListOfMusObjects::iterator iter = m_list.begin();\n    \n    while ( iter != m_list.end()) {\n        MusStaffDef *currentStaffDef = dynamic_cast<MusStaffDef*>(*iter);\n        if ( !currentStaffDef )\n        {\n            iter = m_list.erase( iter );\n        } else {\n            iter++;\n        }\n    }\n}\n\n\nMusStaffDef *MusScoreDef::GetStaffDef( int n )\n{\n    MusStaffDef *staffDef = NULL;\n    \n    this->ResetList( this );\n    ListOfMusObjects::iterator iter;\n    int i;\n    for (iter = m_list.begin(), i = 0; iter != m_list.end(); ++iter, i++)\n    {\n        staffDef = dynamic_cast<MusStaffDef*>(*iter);\n        if (staffDef && (staffDef->GetStaffNo() == n) ) {\n            return staffDef;\n        }\n    }\n    \n    return staffDef;\n}\n\n\nvoid MusScoreDef::SetRedraw( bool clef, bool keysig, bool mensur )\n{\n    ArrayPtrVoid params;\n\tparams.push_back( &clef );\n    params.push_back( &keysig );\n\tparams.push_back( &mensur );\n    MusFunctor setStaffDefDraw( &MusObject::SetStaffDefDraw );\n    this->Process( &setStaffDefDraw, params );\n}\n\n//----------------------------------------------------------------------------\n// MusStaffGrp\n//----------------------------------------------------------------------------\n\nMusStaffGrp::MusStaffGrp() :\n    MusObject(), MusObjectListInterface()\n{\n    m_symbol = STAFFGRP_NONE;\n    m_barthru = false;\n}\n\nMusStaffGrp::~MusStaffGrp()\n{\n}\n\nvoid MusStaffGrp::AddStaffDef( MusStaffDef *staffDef )\n{\n\tstaffDef->SetParent( this );\n\tm_children.push_back( staffDef );\n    Modify();\n}\n\nvoid MusStaffGrp::AddStaffGrp( MusStaffGrp *staffGrp )\n{\n\tstaffGrp->SetParent( this );\n\tm_children.push_back( staffGrp );\n    Modify();\n}\n\nint MusStaffGrp::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];\n    if (!output->WriteStaffGrp( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n    \n}\n\n\nvoid MusStaffGrp::FilterList()\n{\n    // We want to keep only staffDef\n    ListOfMusObjects::iterator iter = m_list.begin();\n    \n    while ( iter != m_list.end()) {\n        MusStaffDef *currentStaffDef = dynamic_cast<MusStaffDef*>(*iter);\n        if ( !currentStaffDef )\n        {\n            iter = m_list.erase( iter );\n        } else {\n            iter++;\n        }\n    }\n}\n\n//----------------------------------------------------------------------------\n// MusStaffDef\n//----------------------------------------------------------------------------\n\nMusStaffDef::MusStaffDef() :\n    MusObject(), MusScoreOrStaffDefAttrInterface()\n{\n}\n\nMusStaffDef::~MusStaffDef()\n{\n}\n\nint MusStaffDef::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];\n    if (!output->WriteStaffDef( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n    \n}\n\n//----------------------------------------------------------------------------\n// MusStaffDef functor methods\n//----------------------------------------------------------------------------\n\nint MusStaffDef::ReplaceStaffDefsInScoreDef( ArrayPtrVoid params )\n{\n    // param 0: the scoreDef\n    MusScoreDef *scoreDef = (MusScoreDef*)params[0];\n    \n    scoreDef->Replace( this );\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusStaffDef::SetStaffDefDraw( ArrayPtrVoid params )\n{\n    // param 0: bool clef flag\n    // param 1: bool keysig flag\n    // param 2: bool the mensur flag\n    bool *clef = (bool*)params[0];\n    bool *keysig = (bool*)params[1];\n    bool *mensur = (bool*)params[2];\n    \n    if ( (*clef) ) {\n        this->SetDrawClef( true );\n    }\n    if ( (*keysig) ) {\n        this->SetDrawKeySig( true );\n    }\n    if ( (*mensur) ) {\n        this->SetDrawMensur( true );\n    }\n    \n    return FUNCTOR_CONTINUE;\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        musstaff.cpp\n// Author:      Laurent Pugin\n// Created:     2005\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"musstaff.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musaligner.h\"\n#include \"musdef.h\"\n#include \"musio.h\"\n#include \"muslayer.h\"\n#include \"mussystem.h\"\n\n//----------------------------------------------------------------------------\n// MusStaff\n//----------------------------------------------------------------------------\n\nMusStaff::MusStaff( int n ):\n\tMusDocObject(\"staff-\")\n{\n\tClear( );\n    //wxASSERT ( n > 0 );\n    m_n = n;\n}\n\nMusStaff::MusStaff( const MusStaff& staff )\n{\n    m_parent = NULL;\n\ttotGrp = staff.totGrp;\n\t//noLigne = staff.noLigne;\n\tarmTyp = staff.armTyp;\n\tarmNbr = staff.armNbr;\n\tnotAnc = staff.notAnc;\n\tgrise = staff.grise;\n\tinvisible = staff.invisible;\n\tvertBarre = staff.vertBarre;\n\tbrace = staff.brace;\n\tstaffSize = staff.staffSize;\n\tportNbLine = staff.portNbLine;\n\taccol = staff.accol;\n\taccessoire = staff.accessoire;\n\tm_yAbs = staff.m_yAbs;\n\tm_yDrawing = staff.m_yDrawing;\n    m_staffAlignment = NULL;\n\n    int i;\n\tfor (i = 0; i < staff.GetLayerCount(); i++)\n\t{\n        MusLayer *nlayer = new MusLayer( *(MusLayer*)staff.m_children[i] );\n        this->AddLayer( nlayer );\n\t}\n    \n    this->ResetUuid();\n}\n\nMusStaff::~MusStaff()\n{\n    \n}\n\nvoid MusStaff::Clear()\n{\n\tClearChildren();\n    m_parent = NULL;\n\tnoGrp = 0;\n\ttotGrp = 0;\n\t//noLigne = 0; // ax2\n\tarmTyp = 0;\n\tarmNbr = 0;\n\tnotAnc = false; // LP we want modern notation :))\n\tgrise = false;\n\tinvisible = false;\n\tvertBarre = 0;\n\tbrace = 0;\n\tstaffSize = 0; \n\tportNbLine = 5;\n\taccol = 0;\n\taccessoire = 0;\n\tm_yAbs = AX_UNSET;\n\tm_yDrawing = 0;\n    m_staffAlignment = NULL;\n}\n\nint MusStaff::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];         \n    if (!output->WriteStaff( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n\n}\n\nvoid MusStaff::AddLayer( MusLayer *layer )\n{\n\tlayer->SetParent( this );\n\tm_children.push_back( layer );\n    \n    if ( layer->GetLayerNo() == -1 ) {\n        layer->SetLayerNo( this->GetLayerCount() );\n    }\n}\n\nvoid MusStaff::CopyAttributes( MusStaff *nstaff )\n{\n\tif ( !nstaff )\n\t\treturn;\n\n\tnstaff->Clear();\n\tnstaff->noGrp = noGrp;\n\tnstaff->totGrp = totGrp;\n\t//nstaff->noLigne = noLigne;\n\tnstaff->armTyp = armTyp;\n\tnstaff->armNbr = armNbr;\n\tnstaff->notAnc = notAnc;\n\tnstaff->grise = grise;\n\tnstaff->invisible = invisible;\n\tnstaff->vertBarre = vertBarre;\n\tnstaff->brace = brace;\n\tnstaff->staffSize = staffSize;\n\tnstaff->portNbLine = portNbLine;\n\tnstaff->accol = accol;\n\tnstaff->accessoire = accessoire;\n\tnstaff->m_yAbs = m_yAbs;\n\tnstaff->m_yDrawing = m_yDrawing;\n}\n\nMusLayer *MusStaff::GetFirst( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\treturn (MusLayer*)m_children[0];\n}\n\nMusLayer *MusStaff::GetLast( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\tint i = GetLayerCount() - 1;\n\treturn (MusLayer*)m_children[i];\n}\n\nMusLayer *MusStaff::GetNext( MusLayer *layer )\n{\t\n    if ( !layer || m_children.empty())\n        return NULL;\n        \n\tint i = GetChildIndex( layer );\n\n\tif ((i == -1 ) || ( i >= GetLayerCount() - 1 ))\n\t\treturn NULL;\n\n\treturn (MusLayer*)m_children[i + 1];\n}\n\nMusLayer *MusStaff::GetPrevious( MusLayer *layer )\n{\n    if ( !layer || m_children.empty())\n        return NULL;\n        \n\tint i = GetChildIndex( layer );\n\n\tif ((i == -1 ) || ( i <= 0 ))\n        return NULL;\n\t\n    return (MusLayer*)m_children[i - 1];\n}\n\n\nMusLayer *MusStaff::GetLayerWithIdx( int LayerIdx )\n{\n    if ( LayerIdx > (int)m_children.size() - 1 )\n        return NULL;\n\t\n\treturn (MusLayer*)m_children[LayerIdx];\n}\n\n\nint MusStaff::GetVerticalSpacing()\n{\n    return 160; // arbitrary generic value\n}\n\nbool MusStaff::GetPosOnPage( ArrayPtrVoid params )\n{\n    // param 0: the MusStaff we are looking for\n    // param 1: the position on the page (int)\n    // param 2; the success flag (bool)\n    MusStaff *staff = (MusStaff*)params[0];\n\tint *position = (int*)params[1];\n    bool *success = (bool*)params[2];\n    \n    if ( (*success) ) {\n        return true;\n    } \n    (*position)++;\n    if ( this == staff ) {\n        (*success) = true;\n        return true;\n    }\n    // to be verified\n    return false;\n}\n\n\nint MusStaff::GetYRel()\n{\n    if (m_staffAlignment) {\n        return m_staffAlignment->GetYRel();\n    }\n    return 0;\n}\n\n//----------------------------------------------------------------------------\n// MusStaff functor methods\n//----------------------------------------------------------------------------\n\n\nint MusStaff::Align( ArrayPtrVoid params )\n{\n    // param 0: the measureAligner (unused)\n    // param 1: the time (unused)\n    // param 2: the systemAligner\n    // param 3: the staffNb\n    MusSystemAligner **systemAligner = (MusSystemAligner**)params[2];\n\tint *staffNb = (int*)params[3];\n    \n    // this gets (or creates) the measureAligner for the measure\n    MusStaffAlignment *alignment = (*systemAligner)->GetStaffAlignment( *staffNb );\n    \n    assert( alignment );\n    \n    // Set the pointer of the m_alignment\n    m_staffAlignment = alignment;\n    \n    // for next staff\n    (*staffNb)++;\n    \n    return FUNCTOR_CONTINUE;\n}\n\n/*\nint MusStaff::LayOutSystemAndStaffYPos( ArrayPtrVoid params )\n{\n    // param 0: the current y system shift\n    // param 1: the current y staff shift\n\tint *current_y_system_shift = (int*)params[0];\n\tint *current_y_staff_shift = (int*)params[1];\n    \n    // This is the value that need to be added to fit everything\n    int negative_offset = this->m_staffAlignment->GetXRel() - this->m_contentBB_y2;\n    \n    // reset the x position if we are starting a new system\n    if ( this->m_parent->GetChildIndex( this ) == 0 ) {\n        MusSystem *system = dynamic_cast<MusSystem*>( this->m_parent );\n        // The parent is a MusSystem, we need to reset the y staff shift\n        if ( system ) {\n            // the staff position is the same as the one of the system\n            (*current_y_staff_shift) = 0;\n            this->m_yRel = 0;\n            // move the system down to fit the content\n            system->m_yRel = (*current_y_system_shift)  + negative_offset;\n            // spacing for the next system\n            (*current_y_system_shift) -= system->GetVerticalSpacing();\n        }\n    }\n    else\n    {\n        // just more the staff down\n        this->m_yRel = (*current_y_staff_shift)  + negative_offset;\n    }\n    \n    int shift = (this->m_contentBB_y2 - this->m_contentBB_y1) + this->GetVerticalSpacing();\n    (*current_y_staff_shift) -= shift;\n    (*current_y_system_shift) -= shift;\n    // do not go further down the tree in this case\n    return FUNCTOR_SIBLINGS;\n}\n*/\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mussvgdc.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"mussvgdc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <fstream>\n\n//----------------------------------------------------------------------------\n\n#include \"musdef.h\"\n#include \"musdoc.h\"\n#include \"musleipzigbbox.h\"\n#include \"musrc.h\"\n\n//----------------------------------------------------------------------------\n\n#include <math.h>\n\n\n#define space \" \"\n#define semicolon \";\"\n \n//#include \"app/axapp.h\"\n\nextern \"C\" {\nstatic inline double DegToRad(double deg) { return (deg * M_PI) / 180.0; }\nstatic inline double RadToDeg(double deg) { return (deg * 180.0) / M_PI; }\n}\n\n//----------------------------------------------------------------------------\n// MusSvgDC\n//----------------------------------------------------------------------------\n\n\nMusSvgDC::MusSvgDC(int width, int height):\n    MusDC()\n{\t\n\t\n    m_correctMusicAscent = false; // do not correct the ascent in the Leipzig font\n\n    m_width = width;\n    m_height = height;\n    \n    m_userScaleX = 1.0;\n    m_userScaleY = 1.0;\n    m_originX = 0;\n    m_originY = 0;\n    \n    SetBrush( AxBLACK, AxSOLID );\n    SetPen( AxBLACK, 1, AxSOLID );\n\n    m_graphics = 0;\n    m_indents = 1;\n    \n    m_leipzig_glyphs.clear();\n    \n    m_committed = false;\n    \n    m_svg.str(\"\");\n    m_svg.clear();\n    \n    m_outdata.clear();\n}\n\n\nMusSvgDC::~MusSvgDC ( )\n{\n}\n\n\nbool MusSvgDC::CopyFileToStream(const std::string& filename, std::ostream& dest)\n{\n    std::ifstream source( filename.c_str(), std::ios::binary );\n    dest << source.rdbuf();\n    source.close();\n    return true;\n}\n\n\n\n\nvoid MusSvgDC::Commit( bool xml_tag ) {\n\n    if (m_committed) {\n        return;\n    }\n    \n    int i;\n    // close unclosed graphics, just in case\n    for (i = m_graphics; i < 0; m_graphics-- ) {\n        WriteLine(\"/*- MusSvgDC::Flush - Unclosed graphic */\");\n        WriteLine(\"</g>\");\n        m_indents--;\n    }\n    m_indents = 0;\n    WriteLine(\"</svg>\\n\") ;\n\n    // header\n    std::string s;\n    if ( xml_tag ) {\n        s = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\";\n    }\n    \n    s += Mus::StringFormat ( \"<svg width=\\\"%dpx\\\" height=\\\"%dpx\\\"\", (int)((double)m_width * m_userScaleX), (int)((double)m_height * m_userScaleY));\n    s += \" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\"  xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">\\n\";\n    \n    m_outdata << s;\n    \n    if (m_leipzig_glyphs.size() > 0)\n    {\n        m_outdata << \"\\t<defs>\\n\";\n        \n        std::vector<std::string>::const_iterator it;\n        for(it = m_leipzig_glyphs.begin(); it != m_leipzig_glyphs.end(); ++it)\n        {\n            m_outdata << \"\\t\\t\";\n            CopyFileToStream( Mus::GetResourcesPath() + \"/svg/\" + (*it) + \".xml\", m_outdata );\n        }\n        m_outdata << \"\\t</defs>\\n\";\n    }\n    // finally concatenate the svg\n    m_outdata << m_svg.str();\n    m_committed = true;\n}\n\n\nvoid MusSvgDC::WriteLine( std::string string )\n{\n    std::string output;\n    output.append( m_indents, '\\t' );\n    output += string + \"\\n\"; \n    m_svg << output;\n}\n\n\nvoid MusSvgDC::StartGraphic( MusDocObject *object, std::string gClass, std::string gId )\n{\n    WriteLine(Mus::StringFormat(\"<g class=\\\"%s\\\" id=\\\"%s\\\" style=\\\"%s %s %s %s\\\">\", gClass.c_str(), gId.c_str(), m_penColour.c_str(), m_penStyle.c_str(),\n        m_brushColour.c_str(), m_brushStyle.c_str() ) );\n    m_graphics++;\n    m_indents++;\n}\n  \n      \nvoid MusSvgDC::EndGraphic(MusDocObject *object, MusRC *rc ) \n{\n    m_graphics--;\n    m_indents--;\n    WriteLine(\"</g>\");\n}\n\n\nvoid MusSvgDC::StartPage( )\n{\n    WriteLine(Mus::StringFormat(\"<g class=\\\"page\\\" transform=\\\"translate(%d, %d)  scale(%f, %f)\\\">\", \n        (int)((double)m_originX * m_userScaleX), (int)((double)m_originY * m_userScaleY), m_userScaleX, m_userScaleY ) );\n    m_graphics++;\n    m_indents++;\n}\n \n       \nvoid MusSvgDC::EndPage() \n{\n    m_graphics--;\n    m_indents--;\n    WriteLine(\"</g>\");\n}\n\n        \nvoid MusSvgDC::SetBrush( int colour, int style )\n{\n    m_brushColour = \"fill:#\" + GetColour(colour) + semicolon;\n    switch ( style )\n    {\n        case AxSOLID :\n            m_brushStyle = \"fill-opacity:1.0; \";\n            break ;\n        case AxTRANSPARENT:\n            m_brushStyle = \"fill-opacity:0.0; \";\n            break ;\n        default :\n            m_brushStyle = \"fill-opacity:1.0; \"; // solid brush as default\n    }\n}\n        \nvoid MusSvgDC::SetBackground( int colour, int style )\n{\n    // nothing to do, we do not handle Background\n}\n\nvoid MusSvgDC::SetBackgroundImage( void *image, double opacity )\n{\n\n}\n        \nvoid MusSvgDC::SetBackgroundMode( int mode )\n{\n    // nothing to do, we do not handle Background Mode\n}\n        \nvoid MusSvgDC::SetPen( int colour, int width, int style )\n{\n    m_penColour = \"stroke:#\" + GetColour(colour)  + semicolon;\n    m_penWidth = \"stroke-width:\" + Mus::StringFormat(\"%d\", width) + semicolon;\n    switch ( style )\n    {\n        case AxSOLID :\n            m_penStyle = \"stroke-opacity:1.0; \";\n            break ;\n        case AxTRANSPARENT:\n            m_penStyle = \"stroke-opacity:0.0; \";\n            break ;\n        default :\n            m_penStyle = \"stroke-opacity:1.0; \"; // solid brush as default\n    }\n}\n        \nvoid MusSvgDC::SetFont( MusFontInfo *font_info )\n{\n    m_font = *font_info;\n    //wxFont font( font_info->pointSize, (wxFontFamily)font_info->family, font_info->style,\n    //    (wxFontWeight)font_info->weight, font_info->underlined, font_info->faceName,\n    //    (wxFontEncoding)font_info->encoding );\n    //m_dc->SetFont( font );\n}\n            \n\nvoid MusSvgDC::SetTextForeground( int colour )\n{\n    m_brushColour = \"fill:#\" + GetColour(colour); // we use the brush colour for text\n}\n        \nvoid MusSvgDC::SetTextBackground( int colour )\n{\n    // nothing to do, we do not handle Text Background Mode\n}\n       \nvoid MusSvgDC::ResetBrush( )\n{\n    SetBrush( AxBLACK, AxSOLID );\n}\n        \nvoid MusSvgDC::ResetPen( )\n{\n    SetPen( AxBLACK, 1, AxSOLID );\n} \n\nvoid MusSvgDC::SetLogicalOrigin( int x, int y ) \n{\n    m_originX = -x;\n    m_originY = -y;\n} \n\nvoid MusSvgDC::SetUserScale( double xScale, double yScale ) \n{\n    m_userScaleX = xScale;\n    m_userScaleY = yScale;\n}       \n\n// Copied from bBoxDc, TODO find another more generic solution\nvoid MusSvgDC::GetTextExtent( const std::string& string, int *w, int *h )\n{\n    int x, y, partial_w, partial_h;\n    \n    *w = 0;\n    *h = 0;\n    \n    for (unsigned int i = 0; i < string.length(); i++) {\n        \n        MusLeipzigBBox::GetCharBounds(string.c_str()[i], &x, &y, &partial_w, &partial_h);\n        \n        partial_w *= ((m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM));\n        partial_h *= ((m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM));\n        \n        *w += partial_w;\n        *h += partial_h;\n    }\n}\n       \n\nMusPoint MusSvgDC::GetLogicalOrigin( ) \n{\n    return MusPoint( m_originX, m_originY );\n}\n\n\n\n// Drawing mething\nvoid MusSvgDC::DrawComplexBezierPath(int x, int y, int bezier1_coord[6], int bezier2_coord[6])\n{\n    WriteLine( Mus::StringFormat(\"<path d=\\\"M%d,%d C%d,%d %d,%d %d,%d C%d,%d %d,%d %d,%d\\\" style=\\\"fill:#000; fill-opacity:1.0; stroke:#000000; stroke-linecap:round; stroke-linejoin:round; stroke-opacity:1.0; stroke-width:0\\\" />\", \n                                x, y, // M command\n                                bezier1_coord[0], bezier1_coord[1], bezier1_coord[2], bezier1_coord[3], bezier1_coord[4], bezier1_coord[5], // First bezier\n                                bezier2_coord[0], bezier2_coord[1], bezier2_coord[2], bezier2_coord[3], bezier2_coord[4], bezier2_coord[5] // Second Bezier\n                                ) );\n}\n\nvoid MusSvgDC::DrawCircle(int x, int y, int radius)\n{\n    DrawEllipse(x - radius, y - radius, 2*radius, 2*radius);\n}\n\n\nvoid MusSvgDC::DrawEllipse(int x, int y, int width, int height)\n{\n    int rh = height / 2;\n    int rw = width  / 2;\n\n    WriteLine(Mus::StringFormat(\"<ellipse cx=\\\"%d\\\" cy=\\\"%d\\\" rx=\\\"%d\\\" ry=\\\"%d\\\" />\", x+rw,y+rh, rw, rh ));\n}\n\n        \nvoid MusSvgDC::DrawEllipticArc(int x, int y, int width, int height, double start, double end)\n{\n    /*\n    Draws an arc of an ellipse. The current pen is used for drawing the arc\n    and the current brush is used for drawing the pie. This function is\n    currently only available for X window and PostScript device contexts.\n\n    x and y specify the x and y coordinates of the upper-left corner of the\n    rectangle that contains the ellipse.\n\n    width and height specify the width and height of the rectangle that\n    contains the ellipse.\n\n    start and end specify the start and end of the arc relative to the\n    three-o'clock position from the center of the rectangle. Angles are\n    specified in degrees (360 is a complete circle). Positive values mean\n    counter-clockwise motion. If start is equal to end, a complete ellipse\n    will be drawn. */\n\n    //known bug: SVG draws with the current pen along the radii, but this does not happen in wxMSW\n\n    std::string s ;\n    //radius\n    double rx = width / 2 ;\n    double ry = height / 2 ;\n    // center\n    double xc = x + rx ;\n    double yc = y + ry ;\n\n    double xs, ys, xe, ye ;\n    xs = xc + rx * cos (DegToRad(start)) ;\n    xe = xc + rx * cos (DegToRad(end)) ;\n    ys = yc - ry * sin (DegToRad(start)) ;\n    ye = yc - ry * sin (DegToRad(end)) ;\n\n    ///now same as circle arc...\n\n    double theta1 = atan2(ys-yc, xs-xc);\n    double theta2 = atan2(ye-yc, xe-xc);\n\n    int fArc  ;                  // flag for large or small arc 0 means less than 180 degrees\n    if ( (theta2 - theta1) > 0 ) fArc = 1; else fArc = 0 ;\n\n    int fSweep ;\n    if ( fabs(theta2 - theta1) > M_PI) fSweep = 1; else fSweep = 0 ;\n\n    // this version closes the arc\n    //s.Printf ( \"<path d=\\\"M%d %d A%d %d 0.0 %d %d  %d %d L %d %d z \",\n    //    int(xs), int(ys), int(rx), int(ry),\n    //    fArc, fSweep, int(xe), int(ye), int(xc), int(yc)  );\n\n    WriteLine( Mus::StringFormat(\"<path d=\\\"M%d %d A%d %d 0.0 %d %d  %d %d \\\" />\",\n        int(xs), int(ys), abs(int(rx)), abs(int(ry)),\n        fArc, fSweep, int(xe), int(ye) ) );\n}\n  \n              \nvoid MusSvgDC::DrawLine(int x1, int y1, int x2, int y2)\n{\n    WriteLine( Mus::StringFormat(\"<path d=\\\"M%d %d L%d %d\\\" style=\\\"%s\\\" />\", x1,y1,x2,y2, m_penWidth.c_str()) );\n}\n \n               \nvoid MusSvgDC::DrawPolygon(int n, MusPoint points[], int xoffset, int yoffset, int fill_style)\n{\n\n    std::string s ;\n    s = \"<polygon style=\\\"\";\n    //if ( fillStyle == wxODDEVEN_RULE )\n    //    s = s + \"fill-rule:evenodd; \";\n    //else\n    s += \"fill-rule:nonzero; \";\n\n    s += \"\\\" points=\\\"\" ;\n\n    for (int i = 0; i < n;  i++)\n    {\n        s += Mus::StringFormat(\"%d,%d \", points [i].x+xoffset, points[i].y+yoffset );\n        //CalcBoundingBox ( points [i].x+xoffset, points[i].y+yoffset);\n    }\n    s += \"\\\" /> \" ;\n    WriteLine(s);\n}\n    \n            \nvoid MusSvgDC::DrawRectangle(int x, int y, int width, int height)\n{\n    DrawRoundedRectangle( x, y, width, height, 0 );\n}\n\n\nvoid MusSvgDC::DrawRoundedRectangle(int x, int y, int width, int height, double radius)\n{\n\n    std::string s ;\n    \n    // negative heights or widths are not allowed in SVG\n    if ( height < 0 ) {\n        height = -height;\n        y -= height;\n    }\n     if ( width < 0 ) {\n        width = -width;\n        x -= width;\n    }   \n\n    WriteLine ( Mus::StringFormat(\" <rect x=\\\"%d\\\" y=\\\"%d\\\" width=\\\"%d\\\" height=\\\"%d\\\" rx=\\\"%.2g\\\" />\", x, y, width, height, radius ) );\n\n}\n\n        \nvoid MusSvgDC::DrawText(const std::string& text, int x, int y)\n{\n    //DrawRotatedText( text, x, y, 0.0 );\n    DrawMusicText(text, x, y);\n}\n\n\n\nvoid MusSvgDC::DrawRotatedText(const std::string& text, int x, int y, double angle)\n{\n    //known bug; if the font is drawn in a scaled DC, it will not behave exactly as wxMSW\n\n    std::string s;\n\n    // calculate bounding box\n    int w, h, desc;\n    //DoGetTextExtent(sText, &w, &h, &desc);\n    w = h = desc = 0;\n\n    //double rad = DegToRad(angle);\n\n    \n    //if (m_backgroundMode == AxSOLID)\n    {\n        WriteLine(\"/*- MusSVGFileDC::DrawRotatedText - Backgound not implemented */\") ;\n    }\n    /*\n    s = Mus::StringFormat(\" <text x=\\\"%d\\\" y=\\\"%d\\\" dx=\\\"%d\\\" dy=\\\"%d\\\" \", x, y, 1, 1) ;\n\n    // For some reason, some browsers (e.g., Chrome) do not like spaces or dots in font names...\n    sTmp.Replace(\" \", \"\");\n    sTmp.Replace(\".\", \"\");\n    if (sTmp.Len () > 0)  s = s + \"style=\\\"font-family: '\" + sTmp + \"'; \";\n    else s = s + \"style=\\\" \" ;\n\n    std::string fontweights [3] = { \"normal\", \"lighter\", \"bold\" };\n    s = s + \"font-weight:\" + fontweights[m_font.GetWeight() - wxNORMAL] + semicolon + space;\n\n    std::string fontstyles [5] = { \"normal\", \"style error\", \"style error\", \"italic\", \"oblique\" };\n    s = s + \"font-style:\" + fontstyles[m_font.GetStyle() - wxNORMAL] + semicolon  + space;\n\n    sTmp.Printf (\"font-size:%dpt; \", (int)((double)m_font.GetPointSize() * 1) );\n    s = s + sTmp ;\n    // remove the color information because normaly already in the graphic element\n    //s = s + \"fill:#\" + wxColStr (m_textForegroundColour) + \"; stroke:#\" + wxColStr (m_textForegroundColour) + \"; \" ;\n    sTmp.Printf ( \"stroke-width:0;\\\"  transform=\\\"rotate( %.2g %d %d )  \\\" >\",  -angle, x,y ) ;\n    s = s + sTmp + sText + \"</text> \" + newline ;\n\n    write(s);\n    */\n}\n\nstd::string FilenameLookup(unsigned char c) {\n    std::string glyph;\n    switch (c) {\n            /* figures */\n        case 48: glyph = \"figure_0\"; break;\n        case 49: glyph = \"figure_1\"; break;\n        case 50: glyph = \"figure_2\"; break;\n        case 51: glyph = \"figure_3\"; break;\n        case 52: glyph = \"figure_4\"; break;\n        case 53: glyph = \"figure_5\"; break;\n        case 54: glyph = \"figure_6\"; break;\n        case 55: glyph = \"figure_7\"; break;\n        case 56: glyph = \"figure_8\"; break;\n        case 57: glyph = \"figure_9\"; break;\n            /* oblique figures */\n        case 0x82: glyph = \"oblique_figure_0\"; break;\n        case 0x83: glyph = \"oblique_figure_1\"; break;\n        case 0x84: glyph = \"oblique_figure_2\"; break;\n        case 0x85: glyph = \"oblique_figure_3\"; break;\n        case 0x86: glyph = \"oblique_figure_4\"; break;\n        case 0x87: glyph = \"oblique_figure_5\"; break;\n        case 0x88: glyph = \"oblique_figure_6\"; break;\n        case 0x89: glyph = \"oblique_figure_7\"; break;\n        case 0x8A: glyph = \"oblique_figure_8\"; break;\n        case 0x8B: glyph = \"oblique_figure_9\"; break;\n            /* fermatas */\n        case LEIPZIG_FERMATA_UP: glyph = \"fermata_up\"; break;\n        case LEIPZIG_FERMATA_DOWN: glyph = \"fermata_down\"; break;          \n            /* clef */\n        case LEIPZIG_CLEF_G: glyph = \"clef_G\"; break;\n        case LEIPZIG_CLEF_F: glyph = \"clef_F\"; break;\n        case LEIPZIG_CLEF_C: glyph = \"clef_C\"; break;\n        case LEIPZIG_CLEF_8va: glyph = \"clef_G8\"; break;\n        case LEIPZIG_CLEF_G + LEIPZIG_OFFSET_MENSURAL: glyph = \"clef_G_mensural\"; break;\n        case LEIPZIG_CLEF_F + LEIPZIG_OFFSET_MENSURAL: glyph = \"clef_F_mensural\"; break;\n        case LEIPZIG_CLEF_C + LEIPZIG_OFFSET_MENSURAL: glyph = \"clef_C_mensural\"; break;\n        case LEIPZIG_CLEF_8va + LEIPZIG_OFFSET_MENSURAL: glyph = \"clef_G_chiavette\"; break;\n            /* meter */\n        case LEIPZIG_METER_SYMB_COMMON: glyph = \"meter_symb_common\"; break;\n        case LEIPZIG_METER_SYMB_CUT: glyph = \"meter_symb_cut\"; break;\n        case LEIPZIG_METER_SYMB_2_CUT: glyph = \"meter_symb_2_cut\"; break;\n        case LEIPZIG_METER_SYMB_3_CUT: glyph = \"meter_symb_3_cut\"; break;\n            /* alterations */\n        case LEIPZIG_ACCID_SHARP: glyph = \"alt_sharp\"; break;\n        case LEIPZIG_ACCID_NATURAL: glyph = \"alt_natural\"; break;\n        case LEIPZIG_ACCID_FLAT: glyph = \"alt_flat\"; break;\n        case LEIPZIG_ACCID_DOUBLE_SHARP: glyph = \"alt_double_sharp\"; break;\n        case LEIPZIG_ACCID_SHARP + LEIPZIG_OFFSET_MENSURAL: glyph = \"alt_sharp_mensural\"; break;\n        case LEIPZIG_ACCID_NATURAL + LEIPZIG_OFFSET_MENSURAL: glyph = \"alt_natural_mensural\"; break;\n        case LEIPZIG_ACCID_FLAT + LEIPZIG_OFFSET_MENSURAL: glyph = \"alt_flat_mensural\"; break;\n        case LEIPZIG_ACCID_DOUBLE_SHARP + LEIPZIG_OFFSET_MENSURAL: glyph = \"alt_double_sharp_mensural\"; break;\n            /* rests */\n        case LEIPZIG_REST_QUARTER: glyph = \"rest_4\"; break;\n        case LEIPZIG_REST_QUARTER + 1: glyph = \"rest_8\"; break;\n        case LEIPZIG_REST_QUARTER + 2: glyph = \"rest_16\"; break;\n        case LEIPZIG_REST_QUARTER + 3: glyph = \"rest_32\"; break;\n        case LEIPZIG_REST_QUARTER + 4: glyph = \"rest_64\"; break;\n        case LEIPZIG_REST_QUARTER + 5: glyph = \"rest_128\"; break;\n        case LEIPZIG_REST_QUARTER + LEIPZIG_OFFSET_MENSURAL: glyph = \"rest_4_mensural\"; break;\n        case LEIPZIG_REST_QUARTER + 1 + LEIPZIG_OFFSET_MENSURAL: glyph = \"rest_8_mensural\"; break;\n        case LEIPZIG_REST_QUARTER + 2 + LEIPZIG_OFFSET_MENSURAL: glyph = \"rest_16_mensural\"; break;\n        case LEIPZIG_REST_QUARTER + 3 + LEIPZIG_OFFSET_MENSURAL: glyph = \"rest_32_mensural\"; break;\n        case LEIPZIG_REST_QUARTER + 4 + LEIPZIG_OFFSET_MENSURAL: glyph = \"rest_64_mensural\"; break;\n        case LEIPZIG_REST_QUARTER + 5 + LEIPZIG_OFFSET_MENSURAL: glyph = \"rest_128_mensural\"; break;\n            /* note heads */\n        case LEIPZIG_HEAD_WHOLE: glyph = \"head_whole\"; break;\n        case LEIPZIG_HEAD_WHOLE_FILLED: glyph = \"head_whole_fill\"; break;\n        case LEIPZIG_HEAD_HALF: glyph = \"head_half\"; break;\n        case LEIPZIG_HEAD_QUARTER: glyph = \"head_quarter\"; break;\n        case LEIPZIG_HEAD_WHOLE + LEIPZIG_OFFSET_MENSURAL: glyph = \"head_whole_diamond\"; break;\n        case LEIPZIG_HEAD_WHOLE_FILLED + LEIPZIG_OFFSET_MENSURAL: glyph = \"head_whole_filldiamond\"; break;\n        case LEIPZIG_HEAD_HALF + LEIPZIG_OFFSET_MENSURAL: glyph = \"head_half_diamond\"; break;\n        case LEIPZIG_HEAD_QUARTER + LEIPZIG_OFFSET_MENSURAL: glyph = \"head_quarter_filldiamond\"; break;\n            /* slashes */\n        case LEIPZIG_STEM_FLAG_UP: glyph = \"slash_up\"; break;\n        case LEIPZIG_STEM_FLAG_DOWN: glyph = \"slash_down\"; break;\n        case LEIPZIG_STEM_FLAG_UP + LEIPZIG_OFFSET_MENSURAL: glyph = \"slash_up_mensural\"; break;\n        case LEIPZIG_STEM_FLAG_DOWN + LEIPZIG_OFFSET_MENSURAL: glyph = \"slash_down_mensural\"; break;\n            /* ornaments */\n        case 35: glyph = \"orn_mordent\"; break;\n        case LEIPZIG_EMB_TRILL: glyph = \"orn_trill\"; break;\n            /* todo */\n        default: glyph = \"clef_G_chiavette\";\n    }\n\n    return glyph;\n}\n\nvoid MusSvgDC::DrawMusicText(const std::string& text, int x, int y)\n{\n\n    int w, h, gx, gy;\n        \n    // print chars one by one\n    for (unsigned int i = 0; i < text.length(); i++) {\n        unsigned char c = (unsigned char)text[i];\n        \n        std::string glyph = FilenameLookup(c);\n        \n        // Add the glyph to the array for the <defs>\n        std::vector<std::string>::const_iterator it = std::find(m_leipzig_glyphs.begin(), m_leipzig_glyphs.end(), glyph);\n        if (it == m_leipzig_glyphs.end())\n        {\n            m_leipzig_glyphs.push_back( glyph );\n        }\n        \n        // Write the char in the SVG\n        WriteLine ( Mus::StringFormat(\"<use xlink:href=\\\"#%s\\\" transform=\\\"translate(%d, %d) scale(%f, %f)\\\"/>\",\n                                     glyph.c_str(), x, y, ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)),\n                                     ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)) ) );\n        \n        // Get the bounds of the char\n        MusLeipzigBBox::GetCharBounds(c, &gx, &gy, &w, &h);\n        // Sum it to x so we move it to the start of the next char\n        x += (w * ((double)(m_font.GetPointSize() / LEIPZIG_UNITS_PER_EM)));\n    }\n    \n\n    \n\n}\n\n\nvoid MusSvgDC::DrawSpline(int n, MusPoint points[])\n{\n    //m_dc->DrawSpline( n, (wxPoint*)points );\n}\n\nvoid MusSvgDC::DrawBackgroundImage( int x, int y )\n{\n   \n}\n\n\nstd::string MusSvgDC::GetColour( int colour )\n{\n    std::stringstream ss;\n    ss << std::hex;\n\n    switch ( colour )\n    {\n    case (AxBLACK): return \"000000\";\n    case (AxWHITE): return \"FFFFFF\";\n    case (AxRED): return \"FF0000\";\n    case (AxGREEN): return \"00FF00\";\n    case (AxBLUE): return \"0000FF\";\n    case (AxCYAN): return \"00FFFF\";\n    case (AxLIGHT_GREY): return \"777777\";\n    default:\n        int blue =  (colour & 255);\n        int green = (colour >> 8) & 255;\n        int red = (colour >> 16) & 255;\n        ss << red << green << blue;\n        //std::strin = wxDecToHex(char(red)) + wxDecToHex(char(green)) + wxDecToHex(char(blue)) ;  // ax3\n        return ss.str();\n    }\n}\n\nstd::string MusSvgDC::GetStringSVG( bool xml_tag )\n{\n    if (!m_committed)\n        Commit( xml_tag );\n    \n    return m_outdata.str();\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mussymbol.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"mussymbol.h\"\n\n//----------------------------------------------------------------------------\n// MusSymbol\n//----------------------------------------------------------------------------\n\nMusSymbol::MusSymbol():\n\tMusLayerElement(\"symb-none-\"), MusPositionInterface()\n{\n    Init( SYMBOL_UNDEFINED );\n}\n\nMusSymbol::MusSymbol( SymbolType type ):\n\tMusLayerElement(\"symb-\"), MusPositionInterface()\n{\n    Init( type );\n}\n\nMusSymbol::~MusSymbol()\n{\n}\n\nbool MusSymbol::operator==( MusObject& other )\n{\n    MusSymbol *otherSymbol = dynamic_cast<MusSymbol*>( &other );\n    if ( !otherSymbol ) {\n        return false;\n    }\n    if ( this->m_type != otherSymbol->m_type ) {\n        return false;\n    }\n    if ( this->m_dot != otherSymbol->m_dot ) {\n        return false;\n    }\n    if ( this->m_accid != otherSymbol->m_accid ) {\n        return false;\n    }\n    if ( !this->HasIdenticalPositionInterface( otherSymbol ) ) {\n        return false;\n    }\n    return true;\n}\n\nvoid MusSymbol::Init( SymbolType type )\n{\n    m_type = type; \n    // DOT\n    m_dot = 0;\n    // ACCID\n    m_accid = 0;\n}\n\n\nvoid MusSymbol::SetValue( int value, int flag ) \n{\n    Init( SYMBOL_UNDEFINED );\n    if ( flag & 1 ) // control is down - alteration, double sharp or double flat\n    {\n\t\tswitch (value)\n        {\n            case ('S'): value = 'X'; break;\n            case ('F'): value = 'D'; break;\n        }\n    }\n    \n    switch (value)\n    {\n            \n\t\tcase ('S'): this->m_type = SYMBOL_ACCID; this->m_accid = ACCID_SHARP; break;\n\t\tcase ('F'): this->m_type = SYMBOL_ACCID; this->m_accid = ACCID_FLAT; break;\n\t\tcase ('N'): this->m_type = SYMBOL_ACCID; this->m_accid = ACCID_NATURAL; break;\n\t\tcase ('X'): this->m_type = SYMBOL_ACCID; this->m_accid = ACCID_DOUBLE_SHARP; break;\n\t\tcase ('D'): this->m_type = SYMBOL_ACCID; this->m_accid = ACCID_DOUBLE_FLAT; break;\n            \n\t\tcase ('.'): this->m_type = SYMBOL_DOT; this->m_dot = 0; break;\n            \n        case ('C'): this->m_type = SYMBOL_CUSTOS; break;\n    }\n}\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mussystem.cpp\n// Author:      Laurent Pugin\n// Created:     2011\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"mussystem.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n\n#include \"mus.h\"\n#include \"musio.h\"\n#include \"musmeasure.h\"\n#include \"muspage.h\"\n\n//----------------------------------------------------------------------------\n// MusSystem\n//----------------------------------------------------------------------------\n\nMusSystem::MusSystem() :\n\tMusDocObject(\"system-\")\n{\n\tClear( );\n}\n\nMusSystem::MusSystem( const MusSystem& system )\n{\n    int i;\n\n\tm_systemLeftMar = system.m_systemLeftMar;\n\tm_systemRightMar = system.m_systemRightMar;\n\tm_xAbs = system.m_xAbs;\n\tm_xRel = system.m_xRel;\n\tm_xDrawing = system.m_xDrawing;\n\tm_yAbs = system.m_yAbs;\n\tm_yRel = system.m_yRel;\n\tm_yDrawing = system.m_yDrawing;\n    \n\tfor (i = 0; i < this->GetMeasureCount(); i++)\n\t{\n        MusMeasure *nmeasure = new MusMeasure( *(MusMeasure*)system.m_children[i] );\n        this->AddMeasure( nmeasure );\n\t}\n}\n\nMusSystem::~MusSystem()\n{\n}\n\nvoid MusSystem::Clear( )\n{\n\tClearChildren();\n\tm_systemLeftMar = 50;\n\tm_systemRightMar = 50;\n\tm_xAbs = AX_UNSET;\n    m_xRel = 0;\n\tm_xDrawing = 0;\n\tm_yAbs = AX_UNSET;\n    m_yRel = 0;\n\tm_yDrawing = 0;\n    m_totalDrawingWidth = 0;\n}\n\n\nint MusSystem::Save( ArrayPtrVoid params )\n{\n    // param 0: output stream\n    MusFileOutputStream *output = (MusFileOutputStream*)params[0];       \n    if (!output->WriteSystem( this )) {\n        return FUNCTOR_STOP;\n    }\n    return FUNCTOR_CONTINUE;\n\n}\n\nvoid MusSystem::AddMeasure( MusMeasure *measure )\n{\n\tmeasure->SetParent( this );\n\tm_children.push_back( measure );\n    Modify();\n}\n\nint MusSystem::GetVerticalSpacing()\n{\n    return 0; // arbitrary generic value\n}\n\nMusMeasure *MusSystem::GetFirst( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\treturn (MusMeasure*)m_children[0];\n}\n\nMusMeasure *MusSystem::GetLast( )\n{\n\tif ( m_children.empty() )\n\t\treturn NULL;\n\tint i = (int)m_children.size() - 1;\n\treturn (MusMeasure*)m_children[i];\n}\n\nMusMeasure *MusSystem::GetNext( MusMeasure *measure )\n{\n    if ( !measure || m_children.empty())\n        return NULL;\n        \n\tint i = GetChildIndex( measure );\n    \n\tif ((i == -1 ) || ( i >= GetMeasureCount() - 1 ))\n\t\treturn NULL;\n\t\n\treturn (MusMeasure*)m_children[i + 1];\n\t\n}\n\nMusMeasure *MusSystem::GetPrevious( MusMeasure *measure  )\n{\n    if ( !measure || m_children.empty() )\n        return NULL;\n        \n\tint i = GetChildIndex( measure );\n\n\tif ((i == -1 ) || ( i <= 0 ))\n        return NULL;\n\t\n    return (MusMeasure*)m_children[i - 1];\n}\n\n\nMusMeasure *MusSystem::GetAtPos( int x )\n{\n\t//y += ( STAFF_OFFSET / 2 );\n\tMusMeasure *measure = this->GetFirst();\n\tif ( !measure )\n\t\treturn NULL;\n\t\n    \n    MusMeasure *next = NULL;\n\twhile ( (next = this->GetNext(measure) ) )\n\t{\n\t\tif ( (int)measure->m_xDrawing < x )\n\t\t{\n\t\t\treturn measure;\n\t\t}\n\t\tmeasure = next;\n\t}\n\n\treturn measure;\n}\n\nvoid MusSystem::SetValues( int type )\n{\n    /*\n    int i;\n    std::string values;\n    for (i = 0; i < GetStaffCount(); i++) \n\t{\n        switch ( type ) {\n            case PAGE_VALUES_VOICES: values += Mus::StringFormat(\"%d;\", (m_children[i])->voix ); break;\n            case PAGE_VALUES_INDENT: values += Mus::StringFormat(\"%d;\", (m_children[i])->indent ); break;\n        }\n\t}\n    values = wxGetTextFromUser( \"Enter values for the pages\", \"\", values );\n    if (values.Length() == 0 ) {\n        return;\n    }\n    wxArrayString values_arr = wxStringTokenize(values, \";\");\n    for (i = 0; (i < GetStaffCount()) && (i < (int)values_arr.GetCount()) ; i++) \n\t{\n        switch ( type ) {\n            case PAGE_VALUES_VOICES: (m_children[i])->voix = atoi( values_arr[i].c_str() ); break;\n            case PAGE_VALUES_INDENT: (m_children[i])->indent = atoi( values_arr[i].c_str() ); break;\n        }\t\n\t}\n    */\n    Mus::LogDebug(\"TODO\");\n    return;\n}\n\n//----------------------------------------------------------------------------\n// MusSystem functor methods\n//----------------------------------------------------------------------------\n\nint MusSystem::TrimSystem( ArrayPtrVoid params )\n{\n    if ( !m_parent || !dynamic_cast<MusPage*>(m_parent) ) {\n        return FUNCTOR_CONTINUE;\n    }\n    MusPage *page = dynamic_cast<MusPage*>(m_parent);\n    \n    int system_length = (this->m_contentBB_x2 - this->m_contentBB_x1) + page->m_pageRightMar;\n    if ( page->m_pageWidth < system_length ) {\n        page->m_pageWidth = system_length;\n    }\n    return FUNCTOR_SIBLINGS;\n}\n\nint MusSystem::Align( ArrayPtrVoid params )\n{\n    // param 0: the measureAligner (unused)\n    // param 1: the time (unused)\n    // param 2: the systemAligner\n    // param 3: the staffNb (unused)\n    MusSystemAligner **systemAligner = (MusSystemAligner**)params[2];\n    \n    // When calculating the alignment, the position has to be 0\n    m_xRel = 0;\n    m_systemAligner.Reset();\n    (*systemAligner) = &m_systemAligner;\n    \n    return FUNCTOR_CONTINUE;\n}\n\n\nint MusSystem::SetAligmentYPos( ArrayPtrVoid params )\n{\n    // param 0: the previous staff height\n    // param 1: the staff margin (unused)\n    // param 2: the staff interline sizes (int[2]) (unused)\n    // param 2: the functor to be redirected to MusSystemAligner\n    int *previousStaffHeight = (int*)params[0];\n    MusFunctor *setAligmnentPosY = (MusFunctor*)params[3];\n    \n    (*previousStaffHeight) = 0;\n    \n    m_systemAligner.Process( setAligmnentPosY, params);\n    \n    return FUNCTOR_SIBLINGS;\n}\n\n\nint MusSystem::IntegrateBoundingBoxYShift( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    // param 1: the functor to be redirected to MusSystemAligner\n    int *shift = (int*)params[0];\n    MusFunctor *integrateBoundingBoxYShift = (MusFunctor*)params[1];\n    \n    m_xRel = this->m_systemLeftMar;\n    (*shift) = 0;\n    m_systemAligner.Process( integrateBoundingBoxYShift, params);\n    \n    return FUNCTOR_SIBLINGS;\n}\n\nint MusSystem::AlignMeasures( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    int *shift = (int*)params[0];\n    \n    (*shift) = 0;\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusSystem::AlignMeasuresEnd( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    int *shift = (int*)params[0];\n    \n    m_totalDrawingWidth = (*shift);\n    \n    return FUNCTOR_CONTINUE;\n}\n\nint MusSystem::AlignSystems( ArrayPtrVoid params )\n{\n    // param 0: the cumulated shift\n    // param 1: the system margin\n    int *shift = (int*)params[0];\n    int *systemMargin = (int*)params[1];\n    \n    this->m_yRel = (*shift);\n    \n    assert( m_systemAligner.GetBottomAlignment() );\n    \n    (*shift) += m_systemAligner.GetBottomAlignment()->GetYRel() - (*systemMargin);\n    \n    return FUNCTOR_SIBLINGS;\n}\n\n\nint MusSystem::JustifyX( ArrayPtrVoid params )\n{\n    // param 0: the justification ratio (unused)\n    // param 1: the system full width (without system margins)\n    // param 2: the functor to be redirected to the MusMeasureAligner (unused)\n    double *ratio = (double*)params[0];\n    int *systemFullWidth = (int*)params[1];\n    \n    (*ratio) = (double)((*systemFullWidth) - this->m_systemLeftMar - this->m_systemRightMar) / (double)m_totalDrawingWidth;\n    \n    if ((*ratio) < 0.8 ) {\n        // Arbitrary value for avoiding over-compressed justification\n        Mus::LogWarning(\"Justification stop because of a ratio smaller the 0.8\");\n        return FUNCTOR_SIBLINGS;\n    }\n    \n    return FUNCTOR_CONTINUE;\n}\n\n","/////////////////////////////////////////////////////////////////////////////\n// Name:        mustie.cpp\n// Author:      Rodolfo Zitellini\n// Created:     26/06/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"mustie.h\"\n\n//----------------------------------------------------------------------------\n\n#include <assert.h>\n\n//----------------------------------------------------------------------------\n// MusTie\n//----------------------------------------------------------------------------\n\nMusTie::MusTie():\nMusLayerElement(\"tie-\")\n{\n    m_first = NULL;\n    m_second = NULL;\n}\n\n\nMusTie::~MusTie()\n{\n    if (m_first && m_first->GetTieAttrTerminal() == this) {\n        m_first->ResetTieAttrInitial();\n    }\n    if (m_second && m_second->GetTieAttrTerminal() == this) {\n        m_second->ResetTieAttrTerminal();\n    }\n}\n\nvoid MusTie::SetFirstNote( MusNote *note )\n{\n    assert( !m_first );\n    m_first = note;\n}\n\nvoid MusTie::SetSecondNote( MusNote *note )\n{\n    assert( !m_second );\n    m_second = note;\n}","/////////////////////////////////////////////////////////////////////////////\n// Name:        musslur.cpp\n// Author:      Rodolfo Zitellini\n// Created:     26/06/2012\n// Copyright (c) Authors and others. All rights reserved.\n/////////////////////////////////////////////////////////////////////////////\n\n\n#include \"mustuplet.h\"\n\n//----------------------------------------------------------------------------\n// MusTuplet\n//----------------------------------------------------------------------------\n\nMusTuplet::MusTuplet():\nMusLayerElement(\"tuplet-\"), MusObjectListInterface()\n{\n    m_num = 1;\n    m_numbase = 1;\n}\n\n\nMusTuplet::~MusTuplet()\n{\n}\n\nvoid MusTuplet::AddElement(MusLayerElement *element) {\n    \n    //if (!element->HasDurationInterface()) {\n    //    return;\n    //}\n    \n    element->SetParent( this );\n    m_children.push_back(element);\n    Modify();\n}\n\nvoid MusTuplet::FilterList()\n{\n    // We want to keep only notes and rest\n    // Eventually, we also need to filter out grace notes properly (e.g., with sub-beams)\n    ListOfMusObjects::iterator iter = m_list.begin();\n    \n    while ( iter != m_list.end()) {\n        MusLayerElement *currentElement = dynamic_cast<MusLayerElement*>(*iter);\n        if ( currentElement && !currentElement->HasDurationInterface() )\n        {\n            iter = m_list.erase( iter );\n        } else {\n            iter++;\n        }\n    }\n    \n}","/*\nwww.sourceforge.net/projects/tinyxml\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n\n#ifndef TIXML_USE_STL\n\n#include \"tinystr.h\"\n\n// Error value for find primitive\nconst TiXmlString::size_type TiXmlString::npos = static_cast< TiXmlString::size_type >(-1);\n\n\n// Null rep.\nTiXmlString::Rep TiXmlString::nullrep_ = { 0, 0, { '\\0' } };\n\n\nvoid TiXmlString::reserve (size_type cap)\n{\n\tif (cap > capacity())\n\t{\n\t\tTiXmlString tmp;\n\t\ttmp.init(length(), cap);\n\t\tmemcpy(tmp.start(), data(), length());\n\t\tswap(tmp);\n\t}\n}\n\n\nTiXmlString& TiXmlString::assign(const char* str, size_type len)\n{\n\tsize_type cap = capacity();\n\tif (len > cap || cap > 3*(len + 8))\n\t{\n\t\tTiXmlString tmp;\n\t\ttmp.init(len);\n\t\tmemcpy(tmp.start(), str, len);\n\t\tswap(tmp);\n\t}\n\telse\n\t{\n\t\tmemmove(start(), str, len);\n\t\tset_size(len);\n\t}\n\treturn *this;\n}\n\n\nTiXmlString& TiXmlString::append(const char* str, size_type len)\n{\n\tsize_type newsize = length() + len;\n\tif (newsize > capacity())\n\t{\n\t\treserve (newsize + capacity());\n\t}\n\tmemmove(finish(), str, len);\n\tset_size(newsize);\n\treturn *this;\n}\n\n\nTiXmlString operator + (const TiXmlString & a, const TiXmlString & b)\n{\n\tTiXmlString tmp;\n\ttmp.reserve(a.length() + b.length());\n\ttmp += a;\n\ttmp += b;\n\treturn tmp;\n}\n\nTiXmlString operator + (const TiXmlString & a, const char* b)\n{\n\tTiXmlString tmp;\n\tTiXmlString::size_type b_len = static_cast<TiXmlString::size_type>( strlen(b) );\n\ttmp.reserve(a.length() + b_len);\n\ttmp += a;\n\ttmp.append(b, b_len);\n\treturn tmp;\n}\n\nTiXmlString operator + (const char* a, const TiXmlString & b)\n{\n\tTiXmlString tmp;\n\tTiXmlString::size_type a_len = static_cast<TiXmlString::size_type>( strlen(a) );\n\ttmp.reserve(a_len + b.length());\n\ttmp.append(a, a_len);\n\ttmp += b;\n\treturn tmp;\n}\n\n\n#endif\t// TIXML_USE_STL\n","/*\nwww.sourceforge.net/projects/tinyxml\nOriginal code by Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n#include <ctype.h>\n\n#ifdef TIXML_USE_STL\n#include <sstream>\n#include <iostream>\n#endif\n\n#include \"tinyxml.h\"\n\nFILE* TiXmlFOpen( const char* filename, const char* mode );\n\nbool TiXmlBase::condenseWhiteSpace = true;\n\n// Microsoft compiler security\nFILE* TiXmlFOpen( const char* filename, const char* mode )\n{\n\t#if defined(_MSC_VER) && (_MSC_VER >= 1400 )\n\t\tFILE* fp = 0;\n\t\terrno_t err = fopen_s( &fp, filename, mode );\n\t\tif ( !err && fp )\n\t\t\treturn fp;\n\t\treturn 0;\n\t#else\n\t\treturn fopen( filename, mode );\n\t#endif\n}\n\nvoid TiXmlBase::EncodeString( const TIXML_STRING& str, TIXML_STRING* outString )\n{\n\tint i=0;\n\n\twhile( i<(int)str.length() )\n\t{\n\t\tunsigned char c = (unsigned char) str[i];\n\n\t\tif (    c == '&' \n\t\t     && i < ( (int)str.length() - 2 )\n\t\t\t && str[i+1] == '#'\n\t\t\t && str[i+2] == 'x' )\n\t\t{\n\t\t\t// Hexadecimal character reference.\n\t\t\t// Pass through unchanged.\n\t\t\t// &#xA9;\t-- copyright symbol, for example.\n\t\t\t//\n\t\t\t// The -1 is a bug fix from Rob Laveaux. It keeps\n\t\t\t// an overflow from happening if there is no ';'.\n\t\t\t// There are actually 2 ways to exit this loop -\n\t\t\t// while fails (error case) and break (semicolon found).\n\t\t\t// However, there is no mechanism (currently) for\n\t\t\t// this function to return an error.\n\t\t\twhile ( i<(int)str.length()-1 )\n\t\t\t{\n\t\t\t\toutString->append( str.c_str() + i, 1 );\n\t\t\t\t++i;\n\t\t\t\tif ( str[i] == ';' )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if ( c == '&' )\n\t\t{\n\t\t\toutString->append( entity[0].str, entity[0].strLength );\n\t\t\t++i;\n\t\t}\n\t\telse if ( c == '<' )\n\t\t{\n\t\t\toutString->append( entity[1].str, entity[1].strLength );\n\t\t\t++i;\n\t\t}\n\t\telse if ( c == '>' )\n\t\t{\n\t\t\toutString->append( entity[2].str, entity[2].strLength );\n\t\t\t++i;\n\t\t}\n\t\telse if ( c == '\\\"' )\n\t\t{\n\t\t\toutString->append( entity[3].str, entity[3].strLength );\n\t\t\t++i;\n\t\t}\n\t\telse if ( c == '\\'' )\n\t\t{\n\t\t\toutString->append( entity[4].str, entity[4].strLength );\n\t\t\t++i;\n\t\t}\n\t\telse if ( c < 32 )\n\t\t{\n\t\t\t// Easy pass at non-alpha/numeric/symbol\n\t\t\t// Below 32 is symbolic.\n\t\t\tchar buf[ 32 ];\n\t\t\t\n\t\t\t#if defined(TIXML_SNPRINTF)\t\t\n\t\t\t\tTIXML_SNPRINTF( buf, sizeof(buf), \"&#x%02X;\", (unsigned) ( c & 0xff ) );\n\t\t\t#else\n\t\t\t\tsprintf( buf, \"&#x%02X;\", (unsigned) ( c & 0xff ) );\n\t\t\t#endif\t\t\n\n\t\t\t//*ME:\twarning C4267: convert 'size_t' to 'int'\n\t\t\t//*ME:\tInt-Cast to make compiler happy ...\n\t\t\toutString->append( buf, (int)strlen( buf ) );\n\t\t\t++i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//char realc = (char) c;\n\t\t\t//outString->append( &realc, 1 );\n\t\t\t*outString += (char) c;\t// somewhat more efficient function call.\n\t\t\t++i;\n\t\t}\n\t}\n}\n\n\nTiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()\n{\n\tparent = 0;\n\ttype = _type;\n\tfirstChild = 0;\n\tlastChild = 0;\n\tprev = 0;\n\tnext = 0;\n}\n\n\nTiXmlNode::~TiXmlNode()\n{\n\tTiXmlNode* node = firstChild;\n\tTiXmlNode* temp = 0;\n\n\twhile ( node )\n\t{\n\t\ttemp = node;\n\t\tnode = node->next;\n\t\tdelete temp;\n\t}\t\n}\n\n\nvoid TiXmlNode::CopyTo( TiXmlNode* target ) const\n{\n\ttarget->SetValue (value.c_str() );\n\ttarget->userData = userData; \n\ttarget->location = location;\n}\n\n\nvoid TiXmlNode::Clear()\n{\n\tTiXmlNode* node = firstChild;\n\tTiXmlNode* temp = 0;\n\n\twhile ( node )\n\t{\n\t\ttemp = node;\n\t\tnode = node->next;\n\t\tdelete temp;\n\t}\t\n\n\tfirstChild = 0;\n\tlastChild = 0;\n}\n\n\nTiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )\n{\n\tassert( node->parent == 0 || node->parent == this );\n\tassert( node->GetDocument() == 0 || node->GetDocument() == this->GetDocument() );\n\n\tif ( node->Type() == TiXmlNode::TINYXML_DOCUMENT )\n\t{\n\t\tdelete node;\n\t\tif ( GetDocument() ) \n\t\t\tGetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn 0;\n\t}\n\n\tnode->parent = this;\n\n\tnode->prev = lastChild;\n\tnode->next = 0;\n\n\tif ( lastChild )\n\t\tlastChild->next = node;\n\telse\n\t\tfirstChild = node;\t\t\t// it was an empty list.\n\n\tlastChild = node;\n\treturn node;\n}\n\n\nTiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )\n{\n\tif ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )\n\t{\n\t\tif ( GetDocument() ) \n\t\t\tGetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn 0;\n\t}\n\tTiXmlNode* node = addThis.Clone();\n\tif ( !node )\n\t\treturn 0;\n\n\treturn LinkEndChild( node );\n}\n\n\nTiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )\n{\t\n\tif ( !beforeThis || beforeThis->parent != this ) {\n\t\treturn 0;\n\t}\n\tif ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )\n\t{\n\t\tif ( GetDocument() ) \n\t\t\tGetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn 0;\n\t}\n\n\tTiXmlNode* node = addThis.Clone();\n\tif ( !node )\n\t\treturn 0;\n\tnode->parent = this;\n\n\tnode->next = beforeThis;\n\tnode->prev = beforeThis->prev;\n\tif ( beforeThis->prev )\n\t{\n\t\tbeforeThis->prev->next = node;\n\t}\n\telse\n\t{\n\t\tassert( firstChild == beforeThis );\n\t\tfirstChild = node;\n\t}\n\tbeforeThis->prev = node;\n\treturn node;\n}\n\n\nTiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )\n{\n\tif ( !afterThis || afterThis->parent != this ) {\n\t\treturn 0;\n\t}\n\tif ( addThis.Type() == TiXmlNode::TINYXML_DOCUMENT )\n\t{\n\t\tif ( GetDocument() ) \n\t\t\tGetDocument()->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn 0;\n\t}\n\n\tTiXmlNode* node = addThis.Clone();\n\tif ( !node )\n\t\treturn 0;\n\tnode->parent = this;\n\n\tnode->prev = afterThis;\n\tnode->next = afterThis->next;\n\tif ( afterThis->next )\n\t{\n\t\tafterThis->next->prev = node;\n\t}\n\telse\n\t{\n\t\tassert( lastChild == afterThis );\n\t\tlastChild = node;\n\t}\n\tafterThis->next = node;\n\treturn node;\n}\n\n\nTiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )\n{\n\tif ( !replaceThis )\n\t\treturn 0;\n\n\tif ( replaceThis->parent != this )\n\t\treturn 0;\n\n\tif ( withThis.ToDocument() ) {\n\t\t// A document can never be a child.\tThanks to Noam.\n\t\tTiXmlDocument* document = GetDocument();\n\t\tif ( document ) \n\t\t\tdocument->SetError( TIXML_ERROR_DOCUMENT_TOP_ONLY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn 0;\n\t}\n\n\tTiXmlNode* node = withThis.Clone();\n\tif ( !node )\n\t\treturn 0;\n\n\tnode->next = replaceThis->next;\n\tnode->prev = replaceThis->prev;\n\n\tif ( replaceThis->next )\n\t\treplaceThis->next->prev = node;\n\telse\n\t\tlastChild = node;\n\n\tif ( replaceThis->prev )\n\t\treplaceThis->prev->next = node;\n\telse\n\t\tfirstChild = node;\n\n\tdelete replaceThis;\n\tnode->parent = this;\n\treturn node;\n}\n\n\nbool TiXmlNode::RemoveChild( TiXmlNode* removeThis )\n{\n\tif ( !removeThis ) {\n\t\treturn false;\n\t}\n\n\tif ( removeThis->parent != this )\n\t{\t\n\t\tassert( 0 );\n\t\treturn false;\n\t}\n\n\tif ( removeThis->next )\n\t\tremoveThis->next->prev = removeThis->prev;\n\telse\n\t\tlastChild = removeThis->prev;\n\n\tif ( removeThis->prev )\n\t\tremoveThis->prev->next = removeThis->next;\n\telse\n\t\tfirstChild = removeThis->next;\n\n\tdelete removeThis;\n\treturn true;\n}\n\nconst TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const\n{\n\tconst TiXmlNode* node;\n\tfor ( node = firstChild; node; node = node->next )\n\t{\n\t\tif ( strcmp( node->Value(), _value ) == 0 )\n\t\t\treturn node;\n\t}\n\treturn 0;\n}\n\n\nconst TiXmlNode* TiXmlNode::LastChild( const char * _value ) const\n{\n\tconst TiXmlNode* node;\n\tfor ( node = lastChild; node; node = node->prev )\n\t{\n\t\tif ( strcmp( node->Value(), _value ) == 0 )\n\t\t\treturn node;\n\t}\n\treturn 0;\n}\n\n\nconst TiXmlNode* TiXmlNode::IterateChildren( const TiXmlNode* previous ) const\n{\n\tif ( !previous )\n\t{\n\t\treturn FirstChild();\n\t}\n\telse\n\t{\n\t\tassert( previous->parent == this );\n\t\treturn previous->NextSibling();\n\t}\n}\n\n\nconst TiXmlNode* TiXmlNode::IterateChildren( const char * val, const TiXmlNode* previous ) const\n{\n\tif ( !previous )\n\t{\n\t\treturn FirstChild( val );\n\t}\n\telse\n\t{\n\t\tassert( previous->parent == this );\n\t\treturn previous->NextSibling( val );\n\t}\n}\n\n\nconst TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const \n{\n\tconst TiXmlNode* node;\n\tfor ( node = next; node; node = node->next )\n\t{\n\t\tif ( strcmp( node->Value(), _value ) == 0 )\n\t\t\treturn node;\n\t}\n\treturn 0;\n}\n\n\nconst TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const\n{\n\tconst TiXmlNode* node;\n\tfor ( node = prev; node; node = node->prev )\n\t{\n\t\tif ( strcmp( node->Value(), _value ) == 0 )\n\t\t\treturn node;\n\t}\n\treturn 0;\n}\n\n\nvoid TiXmlElement::RemoveAttribute( const char * name )\n{\n    #ifdef TIXML_USE_STL\n\tTIXML_STRING str( name );\n\tTiXmlAttribute* node = attributeSet.Find( str );\n\t#else\n\tTiXmlAttribute* node = attributeSet.Find( name );\n\t#endif\n\tif ( node )\n\t{\n\t\tattributeSet.Remove( node );\n\t\tdelete node;\n\t}\n}\n\nconst TiXmlElement* TiXmlNode::FirstChildElement() const\n{\n\tconst TiXmlNode* node;\n\n\tfor (\tnode = FirstChild();\n\t\t\tnode;\n\t\t\tnode = node->NextSibling() )\n\t{\n\t\tif ( node->ToElement() )\n\t\t\treturn node->ToElement();\n\t}\n\treturn 0;\n}\n\n\nconst TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const\n{\n\tconst TiXmlNode* node;\n\n\tfor (\tnode = FirstChild( _value );\n\t\t\tnode;\n\t\t\tnode = node->NextSibling( _value ) )\n\t{\n\t\tif ( node->ToElement() )\n\t\t\treturn node->ToElement();\n\t}\n\treturn 0;\n}\n\n\nconst TiXmlElement* TiXmlNode::NextSiblingElement() const\n{\n\tconst TiXmlNode* node;\n\n\tfor (\tnode = NextSibling();\n\t\t\tnode;\n\t\t\tnode = node->NextSibling() )\n\t{\n\t\tif ( node->ToElement() )\n\t\t\treturn node->ToElement();\n\t}\n\treturn 0;\n}\n\n\nconst TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const\n{\n\tconst TiXmlNode* node;\n\n\tfor (\tnode = NextSibling( _value );\n\t\t\tnode;\n\t\t\tnode = node->NextSibling( _value ) )\n\t{\n\t\tif ( node->ToElement() )\n\t\t\treturn node->ToElement();\n\t}\n\treturn 0;\n}\n\n\nconst TiXmlDocument* TiXmlNode::GetDocument() const\n{\n\tconst TiXmlNode* node;\n\n\tfor( node = this; node; node = node->parent )\n\t{\n\t\tif ( node->ToDocument() )\n\t\t\treturn node->ToDocument();\n\t}\n\treturn 0;\n}\n\n\nTiXmlElement::TiXmlElement (const char * _value)\n\t: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )\n{\n\tfirstChild = lastChild = 0;\n\tvalue = _value;\n}\n\n\n#ifdef TIXML_USE_STL\nTiXmlElement::TiXmlElement( const wxString& _value ) \n\t: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )\n{\n\tfirstChild = lastChild = 0;\n\tvalue = _value;\n}\n#endif\n\n\nTiXmlElement::TiXmlElement( const TiXmlElement& copy)\n\t: TiXmlNode( TiXmlNode::TINYXML_ELEMENT )\n{\n\tfirstChild = lastChild = 0;\n\tcopy.CopyTo( this );\t\n}\n\n\nTiXmlElement& TiXmlElement::operator=( const TiXmlElement& base )\n{\n\tClearThis();\n\tbase.CopyTo( this );\n\treturn *this;\n}\n\n\nTiXmlElement::~TiXmlElement()\n{\n\tClearThis();\n}\n\n\nvoid TiXmlElement::ClearThis()\n{\n\tClear();\n\twhile( attributeSet.First() )\n\t{\n\t\tTiXmlAttribute* node = attributeSet.First();\n\t\tattributeSet.Remove( node );\n\t\tdelete node;\n\t}\n}\n\n\nconst char* TiXmlElement::Attribute( const char* name ) const\n{\n\tconst TiXmlAttribute* node = attributeSet.Find( name );\n\tif ( node )\n\t\treturn node->Value();\n\treturn 0;\n}\n\n\n#ifdef TIXML_USE_STL\nconst wxString* TiXmlElement::Attribute( const wxString& name ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tif ( attrib )\n\t\treturn &attrib->ValueStr();\n\treturn 0;\n}\n#endif\n\n\nconst char* TiXmlElement::Attribute( const char* name, int* i ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tconst char* result = 0;\n\n\tif ( attrib ) {\n\t\tresult = attrib->Value();\n\t\tif ( i ) {\n\t\t\tattrib->QueryIntValue( i );\n\t\t}\n\t}\n\treturn result;\n}\n\n\n#ifdef TIXML_USE_STL\nconst wxString* TiXmlElement::Attribute( const wxString& name, int* i ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tconst wxString* result = 0;\n\n\tif ( attrib ) {\n\t\tresult = &attrib->ValueStr();\n\t\tif ( i ) {\n\t\t\tattrib->QueryIntValue( i );\n\t\t}\n\t}\n\treturn result;\n}\n#endif\n\n\nconst char* TiXmlElement::Attribute( const char* name, double* d ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tconst char* result = 0;\n\n\tif ( attrib ) {\n\t\tresult = attrib->Value();\n\t\tif ( d ) {\n\t\t\tattrib->QueryDoubleValue( d );\n\t\t}\n\t}\n\treturn result;\n}\n\n\n#ifdef TIXML_USE_STL\nconst wxString* TiXmlElement::Attribute( const wxString& name, double* d ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tconst wxString* result = 0;\n\n\tif ( attrib ) {\n\t\tresult = &attrib->ValueStr();\n\t\tif ( d ) {\n\t\t\tattrib->QueryDoubleValue( d );\n\t\t}\n\t}\n\treturn result;\n}\n#endif\n\n\nint TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tif ( !attrib )\n\t\treturn TIXML_NO_ATTRIBUTE;\n\treturn attrib->QueryIntValue( ival );\n}\n\n\nint TiXmlElement::QueryUnsignedAttribute( const char* name, unsigned* value ) const\n{\n\tconst TiXmlAttribute* node = attributeSet.Find( name );\n\tif ( !node )\n\t\treturn TIXML_NO_ATTRIBUTE;\n\n\tint ival = 0;\n\tint result = node->QueryIntValue( &ival );\n\t*value = (unsigned)ival;\n\treturn result;\n}\n\n\nint TiXmlElement::QueryBoolAttribute( const char* name, bool* bval ) const\n{\n\tconst TiXmlAttribute* node = attributeSet.Find( name );\n\tif ( !node )\n\t\treturn TIXML_NO_ATTRIBUTE;\n\t\n\tint result = TIXML_WRONG_TYPE;\n\tif (    StringEqual( node->Value(), \"true\", true, TIXML_ENCODING_UNKNOWN ) \n\t\t || StringEqual( node->Value(), \"yes\", true, TIXML_ENCODING_UNKNOWN ) \n\t\t || StringEqual( node->Value(), \"1\", true, TIXML_ENCODING_UNKNOWN ) ) \n\t{\n\t\t*bval = true;\n\t\tresult = TIXML_SUCCESS;\n\t}\n\telse if (    StringEqual( node->Value(), \"false\", true, TIXML_ENCODING_UNKNOWN ) \n\t\t\t  || StringEqual( node->Value(), \"no\", true, TIXML_ENCODING_UNKNOWN ) \n\t\t\t  || StringEqual( node->Value(), \"0\", true, TIXML_ENCODING_UNKNOWN ) ) \n\t{\n\t\t*bval = false;\n\t\tresult = TIXML_SUCCESS;\n\t}\n\treturn result;\n}\n\n\n\n#ifdef TIXML_USE_STL\nint TiXmlElement::QueryIntAttribute( const wxString& name, int* ival ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tif ( !attrib )\n\t\treturn TIXML_NO_ATTRIBUTE;\n\treturn attrib->QueryIntValue( ival );\n}\n#endif\n\n\nint TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tif ( !attrib )\n\t\treturn TIXML_NO_ATTRIBUTE;\n\treturn attrib->QueryDoubleValue( dval );\n}\n\n\n#ifdef TIXML_USE_STL\nint TiXmlElement::QueryDoubleAttribute( const wxString& name, double* dval ) const\n{\n\tconst TiXmlAttribute* attrib = attributeSet.Find( name );\n\tif ( !attrib )\n\t\treturn TIXML_NO_ATTRIBUTE;\n\treturn attrib->QueryDoubleValue( dval );\n}\n#endif\n\n\nvoid TiXmlElement::SetAttribute( const char * name, int val )\n{\t\n\tTiXmlAttribute* attrib = attributeSet.FindOrCreate( name );\n\tif ( attrib ) {\n\t\tattrib->SetIntValue( val );\n\t}\n}\n\n\n#ifdef TIXML_USE_STL\nvoid TiXmlElement::SetAttribute( const wxString& name, int val )\n{\t\n\tTiXmlAttribute* attrib = attributeSet.FindOrCreate( name );\n\tif ( attrib ) {\n\t\tattrib->SetIntValue( val );\n\t}\n}\n#endif\n\n\nvoid TiXmlElement::SetDoubleAttribute( const char * name, double val )\n{\t\n\tTiXmlAttribute* attrib = attributeSet.FindOrCreate( name );\n\tif ( attrib ) {\n\t\tattrib->SetDoubleValue( val );\n\t}\n}\n\n\n#ifdef TIXML_USE_STL\nvoid TiXmlElement::SetDoubleAttribute( const wxString& name, double val )\n{\t\n\tTiXmlAttribute* attrib = attributeSet.FindOrCreate( name );\n\tif ( attrib ) {\n\t\tattrib->SetDoubleValue( val );\n\t}\n}\n#endif \n\n\nvoid TiXmlElement::SetAttribute( const char * cname, const char * cvalue )\n{\n\tTiXmlAttribute* attrib = attributeSet.FindOrCreate( cname );\n\tif ( attrib ) {\n\t\tattrib->SetValue( cvalue );\n\t}\n}\n\n\n#ifdef TIXML_USE_STL\nvoid TiXmlElement::SetAttribute( const wxString& _name, const wxString& _value )\n{\n\tTiXmlAttribute* attrib = attributeSet.FindOrCreate( _name );\n\tif ( attrib ) {\n\t\tattrib->SetValue( _value );\n\t}\n}\n#endif\n\n\nvoid TiXmlElement::Print( FILE* cfile, int depth ) const\n{\n\tint i;\n\tassert( cfile );\n\tfor ( i=0; i<depth; i++ ) {\n\t\tfprintf( cfile, \"    \" );\n\t}\n\n\tfprintf( cfile, \"<%s\", value.c_str() );\n\n\tconst TiXmlAttribute* attrib;\n\tfor ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )\n\t{\n\t\tfprintf( cfile, \" \" );\n\t\tattrib->Print( cfile, depth );\n\t}\n\n\t// There are 3 different formatting approaches:\n\t// 1) An element without children is printed as a <foo /> node\n\t// 2) An element with only a text child is printed as <foo> text </foo>\n\t// 3) An element with children is printed on multiple lines.\n\tTiXmlNode* node;\n\tif ( !firstChild )\n\t{\n\t\tfprintf( cfile, \" />\" );\n\t}\n\telse if ( firstChild == lastChild && firstChild->ToText() )\n\t{\n\t\tfprintf( cfile, \">\" );\n\t\tfirstChild->Print( cfile, depth + 1 );\n\t\tfprintf( cfile, \"</%s>\", value.c_str() );\n\t}\n\telse\n\t{\n\t\tfprintf( cfile, \">\" );\n\n\t\tfor ( node = firstChild; node; node=node->NextSibling() )\n\t\t{\n\t\t\tif ( !node->ToText() )\n\t\t\t{\n\t\t\t\tfprintf( cfile, \"\\n\" );\n\t\t\t}\n\t\t\tnode->Print( cfile, depth+1 );\n\t\t}\n\t\tfprintf( cfile, \"\\n\" );\n\t\tfor( i=0; i<depth; ++i ) {\n\t\t\tfprintf( cfile, \"    \" );\n\t\t}\n\t\tfprintf( cfile, \"</%s>\", value.c_str() );\n\t}\n}\n\n\nvoid TiXmlElement::CopyTo( TiXmlElement* target ) const\n{\n\t// superclass:\n\tTiXmlNode::CopyTo( target );\n\n\t// Element class: \n\t// Clone the attributes, then clone the children.\n\tconst TiXmlAttribute* attribute = 0;\n\tfor(\tattribute = attributeSet.First();\n\tattribute;\n\tattribute = attribute->Next() )\n\t{\n\t\ttarget->SetAttribute( attribute->Name(), attribute->Value() );\n\t}\n\n\tTiXmlNode* node = 0;\n\tfor ( node = firstChild; node; node = node->NextSibling() )\n\t{\n\t\ttarget->LinkEndChild( node->Clone() );\n\t}\n}\n\nbool TiXmlElement::Accept( TiXmlVisitor* visitor ) const\n{\n\tif ( visitor->VisitEnter( *this, attributeSet.First() ) ) \n\t{\n\t\tfor ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )\n\t\t{\n\t\t\tif ( !node->Accept( visitor ) )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn visitor->VisitExit( *this );\n}\n\n\nTiXmlNode* TiXmlElement::Clone() const\n{\n\tTiXmlElement* clone = new TiXmlElement( Value() );\n\tif ( !clone )\n\t\treturn 0;\n\n\tCopyTo( clone );\n\treturn clone;\n}\n\n\nconst char* TiXmlElement::GetText() const\n{\n\tconst TiXmlNode* child = this->FirstChild();\n\tif ( child ) {\n\t\tconst TiXmlText* childText = child->ToText();\n\t\tif ( childText ) {\n\t\t\treturn childText->Value();\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nTiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )\n{\n\ttabsize = 4;\n\tuseMicrosoftBOM = false;\n\tClearError();\n}\n\nTiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )\n{\n\ttabsize = 4;\n\tuseMicrosoftBOM = false;\n\tvalue = documentName;\n\tClearError();\n}\n\n\n#ifdef TIXML_USE_STL\nTiXmlDocument::TiXmlDocument( const wxString& documentName ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )\n{\n\ttabsize = 4;\n\tuseMicrosoftBOM = false;\n    value = documentName;\n\tClearError();\n}\n#endif\n\n\nTiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::TINYXML_DOCUMENT )\n{\n\tcopy.CopyTo( this );\n}\n\n\nTiXmlDocument& TiXmlDocument::operator=( const TiXmlDocument& copy )\n{\n\tClear();\n\tcopy.CopyTo( this );\n\treturn *this;\n}\n\n\nbool TiXmlDocument::LoadFile( TiXmlEncoding encoding )\n{\n\treturn LoadFile( Value(), encoding );\n}\n\n\nbool TiXmlDocument::SaveFile() const\n{\n\treturn SaveFile( Value() );\n}\n\nbool TiXmlDocument::LoadFile( const char* _filename, TiXmlEncoding encoding )\n{\n\tTIXML_STRING filename( _filename );\n\tvalue = filename;\n\n\t// reading in binary mode so that tinyxml can normalize the EOL\n\tFILE* file = TiXmlFOpen( value.c_str (), \"rb\" );\t\n\n\tif ( file )\n\t{\n\t\tbool result = LoadFile( file, encoding );\n\t\tfclose( file );\n\t\treturn result;\n\t}\n\telse\n\t{\n\t\tSetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn false;\n\t}\n}\n\nbool TiXmlDocument::LoadFile( FILE* file, TiXmlEncoding encoding )\n{\n\tif ( !file ) \n\t{\n\t\tSetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn false;\n\t}\n\n\t// Delete the existing data:\n\tClear();\n\tlocation.Clear();\n\n\t// Get the file size, so we can pre-allocate the string. HUGE speed impact.\n\tlong length = 0;\n\tfseek( file, 0, SEEK_END );\n\tlength = ftell( file );\n\tfseek( file, 0, SEEK_SET );\n\n\t// Strange case, but good to handle up front.\n\tif ( length <= 0 )\n\t{\n\t\tSetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn false;\n\t}\n\n\t// Subtle bug here. TinyXml did use fgets. But from the XML spec:\n\t// 2.11 End-of-Line Handling\n\t// <snip>\n\t// <quote>\n\t// ...the XML processor MUST behave as if it normalized all line breaks in external \n\t// parsed entities (including the document entity) on input, before parsing, by translating \n\t// both the two-character sequence #xD #xA and any #xD that is not followed by #xA to \n\t// a single #xA character.\n\t// </quote>\n\t//\n\t// It is not clear fgets does that, and certainly isn't clear it works cross platform. \n\t// Generally, you expect fgets to translate from the convention of the OS to the c/unix\n\t// convention, and not work generally.\n\n\t/*\n\twhile( fgets( buf, sizeof(buf), file ) )\n\t{\n\t\tdata += buf;\n\t}\n\t*/\n\n\tchar* buf = new char[ length+1 ];\n\tbuf[0] = 0;\n\n\tif ( fread( buf, length, 1, file ) != 1 ) {\n\t\tdelete [] buf;\n\t\tSetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn false;\n\t}\n\n\t// Process the buffer in place to normalize new lines. (See comment above.)\n\t// Copies from the 'p' to 'q' pointer, where p can advance faster if\n\t// a newline-carriage return is hit.\n\t//\n\t// Wikipedia:\n\t// Systems based on ASCII or a compatible character set use either LF  (Line feed, '\\n', 0x0A, 10 in decimal) or \n\t// CR (Carriage return, '\\r', 0x0D, 13 in decimal) individually, or CR followed by LF (CR+LF, 0x0D 0x0A)...\n\t//\t\t* LF:    Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS, Amiga, RISC OS, and others\n    //\t\t* CR+LF: DEC RT-11 and most other early non-Unix, non-IBM OSes, CP/M, MP/M, DOS, OS/2, Microsoft Windows, Symbian OS\n    //\t\t* CR:    Commodore 8-bit machines, Apple II family, Mac OS up to version 9 and OS-9\n\n\tconst char* p = buf;\t// the read head\n\tchar* q = buf;\t\t\t// the write head\n\tconst char CR = 0x0d;\n\tconst char LF = 0x0a;\n\n\tbuf[length] = 0;\n\twhile( *p ) {\n\t\tassert( p < (buf+length) );\n\t\tassert( q <= (buf+length) );\n\t\tassert( q <= p );\n\n\t\tif ( *p == CR ) {\n\t\t\t*q++ = LF;\n\t\t\tp++;\n\t\t\tif ( *p == LF ) {\t\t// check for CR+LF (and skip LF)\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t*q++ = *p++;\n\t\t}\n\t}\n\tassert( q <= (buf+length) );\n\t*q = 0;\n\n\tParse( buf, 0, encoding );\n\n\tdelete [] buf;\n\treturn !Error();\n}\n\n\nbool TiXmlDocument::SaveFile( const char * filename ) const\n{\n\t// The old c stuff lives on...\n\tFILE* fp = TiXmlFOpen( filename, \"w\" );\n\tif ( fp )\n\t{\n\t\tbool result = SaveFile( fp );\n\t\tfclose( fp );\n\t\treturn result;\n\t}\n\treturn false;\n}\n\n\nbool TiXmlDocument::SaveFile( FILE* fp ) const\n{\n\tif ( useMicrosoftBOM ) \n\t{\n\t\tconst unsigned char TIXML_UTF_LEAD_0 = 0xefU;\n\t\tconst unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\n\t\tconst unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\n\n\t\tfputc( TIXML_UTF_LEAD_0, fp );\n\t\tfputc( TIXML_UTF_LEAD_1, fp );\n\t\tfputc( TIXML_UTF_LEAD_2, fp );\n\t}\n\tPrint( fp, 0 );\n\treturn (ferror(fp) == 0);\n}\n\n\nvoid TiXmlDocument::CopyTo( TiXmlDocument* target ) const\n{\n\tTiXmlNode::CopyTo( target );\n\n\ttarget->error = error;\n\ttarget->errorId = errorId;\n\ttarget->errorDesc = errorDesc;\n\ttarget->tabsize = tabsize;\n\ttarget->errorLocation = errorLocation;\n\ttarget->useMicrosoftBOM = useMicrosoftBOM;\n\n\tTiXmlNode* node = 0;\n\tfor ( node = firstChild; node; node = node->NextSibling() )\n\t{\n\t\ttarget->LinkEndChild( node->Clone() );\n\t}\t\n}\n\n\nTiXmlNode* TiXmlDocument::Clone() const\n{\n\tTiXmlDocument* clone = new TiXmlDocument();\n\tif ( !clone )\n\t\treturn 0;\n\n\tCopyTo( clone );\n\treturn clone;\n}\n\n\nvoid TiXmlDocument::Print( FILE* cfile, int depth ) const\n{\n\tassert( cfile );\n\tfor ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )\n\t{\n\t\tnode->Print( cfile, depth );\n\t\tfprintf( cfile, \"\\n\" );\n\t}\n}\n\n\nbool TiXmlDocument::Accept( TiXmlVisitor* visitor ) const\n{\n\tif ( visitor->VisitEnter( *this ) )\n\t{\n\t\tfor ( const TiXmlNode* node=FirstChild(); node; node=node->NextSibling() )\n\t\t{\n\t\t\tif ( !node->Accept( visitor ) )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn visitor->VisitExit( *this );\n}\n\n\nconst TiXmlAttribute* TiXmlAttribute::Next() const\n{\n\t// We are using knowledge of the sentinel. The sentinel\n\t// have a value or name.\n\tif ( next->value.empty() && next->name.empty() )\n\t\treturn 0;\n\treturn next;\n}\n\n/*\nTiXmlAttribute* TiXmlAttribute::Next()\n{\n\t// We are using knowledge of the sentinel. The sentinel\n\t// have a value or name.\n\tif ( next->value.empty() && next->name.empty() )\n\t\treturn 0;\n\treturn next;\n}\n*/\n\nconst TiXmlAttribute* TiXmlAttribute::Previous() const\n{\n\t// We are using knowledge of the sentinel. The sentinel\n\t// have a value or name.\n\tif ( prev->value.empty() && prev->name.empty() )\n\t\treturn 0;\n\treturn prev;\n}\n\n/*\nTiXmlAttribute* TiXmlAttribute::Previous()\n{\n\t// We are using knowledge of the sentinel. The sentinel\n\t// have a value or name.\n\tif ( prev->value.empty() && prev->name.empty() )\n\t\treturn 0;\n\treturn prev;\n}\n*/\n\nvoid TiXmlAttribute::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const\n{\n\tTIXML_STRING n, v;\n\n\tEncodeString( name, &n );\n\tEncodeString( value, &v );\n\n\tif (value.find ('\\\"') == TIXML_STRING::npos) {\n\t\tif ( cfile ) {\n\t\t\tfprintf (cfile, \"%s=\\\"%s\\\"\", n.c_str(), v.c_str() );\n\t\t}\n\t\tif ( str ) {\n\t\t\t(*str) += n; (*str) += \"=\\\"\"; (*str) += v; (*str) += \"\\\"\";\n\t\t}\n\t}\n\telse {\n\t\tif ( cfile ) {\n\t\t\tfprintf (cfile, \"%s='%s'\", n.c_str(), v.c_str() );\n\t\t}\n\t\tif ( str ) {\n\t\t\t(*str) += n; (*str) += \"='\"; (*str) += v; (*str) += \"'\";\n\t\t}\n\t}\n}\n\n\nint TiXmlAttribute::QueryIntValue( int* ival ) const\n{\n\tif ( TIXML_SSCANF( value.c_str(), \"%d\", ival ) == 1 )\n\t\treturn TIXML_SUCCESS;\n\treturn TIXML_WRONG_TYPE;\n}\n\nint TiXmlAttribute::QueryDoubleValue( double* dval ) const\n{\n\tif ( TIXML_SSCANF( value.c_str(), \"%lf\", dval ) == 1 )\n\t\treturn TIXML_SUCCESS;\n\treturn TIXML_WRONG_TYPE;\n}\n\nvoid TiXmlAttribute::SetIntValue( int _value )\n{\n\tchar buf [64];\n\t#if defined(TIXML_SNPRINTF)\t\t\n\t\tTIXML_SNPRINTF(buf, sizeof(buf), \"%d\", _value);\n\t#else\n\t\tsprintf (buf, \"%d\", _value);\n\t#endif\n\tSetValue (buf);\n}\n\nvoid TiXmlAttribute::SetDoubleValue( double _value )\n{\n\tchar buf [256];\n\t#if defined(TIXML_SNPRINTF)\t\t\n\t\tTIXML_SNPRINTF( buf, sizeof(buf), \"%g\", _value);\n\t#else\n\t\tsprintf (buf, \"%g\", _value);\n\t#endif\n\tSetValue (buf);\n}\n\nint TiXmlAttribute::IntValue() const\n{\n\treturn atoi (value.c_str ());\n}\n\ndouble  TiXmlAttribute::DoubleValue() const\n{\n\treturn atof (value.c_str ());\n}\n\n\nTiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::TINYXML_COMMENT )\n{\n\tcopy.CopyTo( this );\n}\n\n\nTiXmlComment& TiXmlComment::operator=( const TiXmlComment& base )\n{\n\tClear();\n\tbase.CopyTo( this );\n\treturn *this;\n}\n\n\nvoid TiXmlComment::Print( FILE* cfile, int depth ) const\n{\n\tassert( cfile );\n\tfor ( int i=0; i<depth; i++ )\n\t{\n\t\tfprintf( cfile,  \"    \" );\n\t}\n\tfprintf( cfile, \"<!--%s-->\", value.c_str() );\n}\n\n\nvoid TiXmlComment::CopyTo( TiXmlComment* target ) const\n{\n\tTiXmlNode::CopyTo( target );\n}\n\n\nbool TiXmlComment::Accept( TiXmlVisitor* visitor ) const\n{\n\treturn visitor->Visit( *this );\n}\n\n\nTiXmlNode* TiXmlComment::Clone() const\n{\n\tTiXmlComment* clone = new TiXmlComment();\n\n\tif ( !clone )\n\t\treturn 0;\n\n\tCopyTo( clone );\n\treturn clone;\n}\n\n\nvoid TiXmlText::Print( FILE* cfile, int depth ) const\n{\n\tassert( cfile );\n\tif ( cdata )\n\t{\n\t\tint i;\n\t\tfprintf( cfile, \"\\n\" );\n\t\tfor ( i=0; i<depth; i++ ) {\n\t\t\tfprintf( cfile, \"    \" );\n\t\t}\n\t\tfprintf( cfile, \"<![CDATA[%s]]>\\n\", value.c_str() );\t// unformatted output\n\t}\n\telse\n\t{\n\t\tTIXML_STRING buffer;\n\t\tEncodeString( value, &buffer );\n\t\tfprintf( cfile, \"%s\", buffer.c_str() );\n\t}\n}\n\n\nvoid TiXmlText::CopyTo( TiXmlText* target ) const\n{\n\tTiXmlNode::CopyTo( target );\n\ttarget->cdata = cdata;\n}\n\n\nbool TiXmlText::Accept( TiXmlVisitor* visitor ) const\n{\n\treturn visitor->Visit( *this );\n}\n\n\nTiXmlNode* TiXmlText::Clone() const\n{\t\n\tTiXmlText* clone = 0;\n\tclone = new TiXmlText( \"\" );\n\n\tif ( !clone )\n\t\treturn 0;\n\n\tCopyTo( clone );\n\treturn clone;\n}\n\n\nTiXmlDeclaration::TiXmlDeclaration( const char * _version,\n\t\t\t\t\t\t\t\t\tconst char * _encoding,\n\t\t\t\t\t\t\t\t\tconst char * _standalone )\n\t: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )\n{\n\tversion = _version;\n\tencoding = _encoding;\n\tstandalone = _standalone;\n}\n\n\n#ifdef TIXML_USE_STL\nTiXmlDeclaration::TiXmlDeclaration(\tconst wxString& _version,\n\t\t\t\t\t\t\t\t\tconst wxString& _encoding,\n\t\t\t\t\t\t\t\t\tconst wxString& _standalone )\n\t: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )\n{\n\tversion = _version;\n\tencoding = _encoding;\n\tstandalone = _standalone;\n}\n#endif\n\n\nTiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )\n\t: TiXmlNode( TiXmlNode::TINYXML_DECLARATION )\n{\n\tcopy.CopyTo( this );\t\n}\n\n\nTiXmlDeclaration& TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )\n{\n\tClear();\n\tcopy.CopyTo( this );\n\treturn *this;\n}\n\n\nvoid TiXmlDeclaration::Print( FILE* cfile, int /*depth*/, TIXML_STRING* str ) const\n{\n\tif ( cfile ) fprintf( cfile, \"<?xml \" );\n\tif ( str )\t (*str) += \"<?xml \";\n\n\tif ( !version.empty() ) {\n\t\tif ( cfile ) fprintf (cfile, \"version=\\\"%s\\\" \", version.c_str ());\n\t\tif ( str ) { (*str) += \"version=\\\"\"; (*str) += version; (*str) += \"\\\" \"; }\n\t}\n\tif ( !encoding.empty() ) {\n\t\tif ( cfile ) fprintf (cfile, \"encoding=\\\"%s\\\" \", encoding.c_str ());\n\t\tif ( str ) { (*str) += \"encoding=\\\"\"; (*str) += encoding; (*str) += \"\\\" \"; }\n\t}\n\tif ( !standalone.empty() ) {\n\t\tif ( cfile ) fprintf (cfile, \"standalone=\\\"%s\\\" \", standalone.c_str ());\n\t\tif ( str ) { (*str) += \"standalone=\\\"\"; (*str) += standalone; (*str) += \"\\\" \"; }\n\t}\n\tif ( cfile ) fprintf( cfile, \"?>\" );\n\tif ( str )\t (*str) += \"?>\";\n}\n\n\nvoid TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const\n{\n\tTiXmlNode::CopyTo( target );\n\n\ttarget->version = version;\n\ttarget->encoding = encoding;\n\ttarget->standalone = standalone;\n}\n\n\nbool TiXmlDeclaration::Accept( TiXmlVisitor* visitor ) const\n{\n\treturn visitor->Visit( *this );\n}\n\n\nTiXmlNode* TiXmlDeclaration::Clone() const\n{\t\n\tTiXmlDeclaration* clone = new TiXmlDeclaration();\n\n\tif ( !clone )\n\t\treturn 0;\n\n\tCopyTo( clone );\n\treturn clone;\n}\n\n\nvoid TiXmlUnknown::Print( FILE* cfile, int depth ) const\n{\n\tfor ( int i=0; i<depth; i++ )\n\t\tfprintf( cfile, \"    \" );\n\tfprintf( cfile, \"<%s>\", value.c_str() );\n}\n\n\nvoid TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const\n{\n\tTiXmlNode::CopyTo( target );\n}\n\n\nbool TiXmlUnknown::Accept( TiXmlVisitor* visitor ) const\n{\n\treturn visitor->Visit( *this );\n}\n\n\nTiXmlNode* TiXmlUnknown::Clone() const\n{\n\tTiXmlUnknown* clone = new TiXmlUnknown();\n\n\tif ( !clone )\n\t\treturn 0;\n\n\tCopyTo( clone );\n\treturn clone;\n}\n\n\nTiXmlAttributeSet::TiXmlAttributeSet()\n{\n\tsentinel.next = &sentinel;\n\tsentinel.prev = &sentinel;\n}\n\n\nTiXmlAttributeSet::~TiXmlAttributeSet()\n{\n\tassert( sentinel.next == &sentinel );\n\tassert( sentinel.prev == &sentinel );\n}\n\n\nvoid TiXmlAttributeSet::Add( TiXmlAttribute* addMe )\n{\n    #ifdef TIXML_USE_STL\n\tassert( !Find( TIXML_STRING( addMe->Name() ) ) );\t// Shouldn't be multiply adding to the set.\n\t#else\n\tassert( !Find( addMe->Name() ) );\t// Shouldn't be multiply adding to the set.\n\t#endif\n\n\taddMe->next = &sentinel;\n\taddMe->prev = sentinel.prev;\n\n\tsentinel.prev->next = addMe;\n\tsentinel.prev      = addMe;\n}\n\nvoid TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )\n{\n\tTiXmlAttribute* node;\n\n\tfor( node = sentinel.next; node != &sentinel; node = node->next )\n\t{\n\t\tif ( node == removeMe )\n\t\t{\n\t\t\tnode->prev->next = node->next;\n\t\t\tnode->next->prev = node->prev;\n\t\t\tnode->next = 0;\n\t\t\tnode->prev = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\tassert( 0 );\t\t// we tried to remove a non-linked attribute.\n}\n\n\n#ifdef TIXML_USE_STL\nTiXmlAttribute* TiXmlAttributeSet::Find( const wxString& name ) const\n{\n\tfor( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )\n\t{\n\t\tif ( node->name == name )\n\t\t\treturn node;\n\t}\n\treturn 0;\n}\n\nTiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const wxString& _name )\n{\n\tTiXmlAttribute* attrib = Find( _name );\n\tif ( !attrib ) {\n\t\tattrib = new TiXmlAttribute();\n\t\tAdd( attrib );\n\t\tattrib->SetName( _name );\n\t}\n\treturn attrib;\n}\n#endif\n\n\nTiXmlAttribute* TiXmlAttributeSet::Find( const char* name ) const\n{\n\tfor( TiXmlAttribute* node = sentinel.next; node != &sentinel; node = node->next )\n\t{\n\t\tif ( strcmp( node->name.c_str(), name ) == 0 )\n\t\t\treturn node;\n\t}\n\treturn 0;\n}\n\n\nTiXmlAttribute* TiXmlAttributeSet::FindOrCreate( const char* _name )\n{\n\tTiXmlAttribute* attrib = Find( _name );\n\tif ( !attrib ) {\n\t\tattrib = new TiXmlAttribute();\n\t\tAdd( attrib );\n\t\tattrib->SetName( _name );\n\t}\n\treturn attrib;\n}\n\n\n#ifdef TIXML_USE_STL\t\nstd::istream& operator>> (std::istream & in, TiXmlNode & base)\n{\n\tTIXML_STRING tag;\n\ttag.reserve( 8 * 1000 );\n\tbase.StreamIn( &in, &tag );\n\n\tbase.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );\n\treturn in;\n}\n#endif\n\n\n#ifdef TIXML_USE_STL\t\nstd::ostream& operator<< (std::ostream & out, const TiXmlNode & base)\n{\n\tTiXmlPrinter printer;\n\tprinter.SetStreamPrinting();\n\tbase.Accept( &printer );\n\tout << printer.Str();\n\n\treturn out;\n}\n\n\nwxString& operator<< (wxString& out, const TiXmlNode& base )\n{\n\tTiXmlPrinter printer;\n\tprinter.SetStreamPrinting();\n\tbase.Accept( &printer );\n\tout.append( printer.Str() );\n\n\treturn out;\n}\n#endif\n\n\nTiXmlHandle TiXmlHandle::FirstChild() const\n{\n\tif ( node )\n\t{\n\t\tTiXmlNode* child = node->FirstChild();\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nTiXmlHandle TiXmlHandle::FirstChild( const char * value ) const\n{\n\tif ( node )\n\t{\n\t\tTiXmlNode* child = node->FirstChild( value );\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nTiXmlHandle TiXmlHandle::FirstChildElement() const\n{\n\tif ( node )\n\t{\n\t\tTiXmlElement* child = node->FirstChildElement();\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nTiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const\n{\n\tif ( node )\n\t{\n\t\tTiXmlElement* child = node->FirstChildElement( value );\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nTiXmlHandle TiXmlHandle::Child( int count ) const\n{\n\tif ( node )\n\t{\n\t\tint i;\n\t\tTiXmlNode* child = node->FirstChild();\n\t\tfor (\ti=0;\n\t\t\t\tchild && i<count;\n\t\t\t\tchild = child->NextSibling(), ++i )\n\t\t{\n\t\t\t// nothing\n\t\t}\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nTiXmlHandle TiXmlHandle::Child( const char* value, int count ) const\n{\n\tif ( node )\n\t{\n\t\tint i;\n\t\tTiXmlNode* child = node->FirstChild( value );\n\t\tfor (\ti=0;\n\t\t\t\tchild && i<count;\n\t\t\t\tchild = child->NextSibling( value ), ++i )\n\t\t{\n\t\t\t// nothing\n\t\t}\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nTiXmlHandle TiXmlHandle::ChildElement( int count ) const\n{\n\tif ( node )\n\t{\n\t\tint i;\n\t\tTiXmlElement* child = node->FirstChildElement();\n\t\tfor (\ti=0;\n\t\t\t\tchild && i<count;\n\t\t\t\tchild = child->NextSiblingElement(), ++i )\n\t\t{\n\t\t\t// nothing\n\t\t}\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nTiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const\n{\n\tif ( node )\n\t{\n\t\tint i;\n\t\tTiXmlElement* child = node->FirstChildElement( value );\n\t\tfor (\ti=0;\n\t\t\t\tchild && i<count;\n\t\t\t\tchild = child->NextSiblingElement( value ), ++i )\n\t\t{\n\t\t\t// nothing\n\t\t}\n\t\tif ( child )\n\t\t\treturn TiXmlHandle( child );\n\t}\n\treturn TiXmlHandle( 0 );\n}\n\n\nbool TiXmlPrinter::VisitEnter( const TiXmlDocument& )\n{\n\treturn true;\n}\n\nbool TiXmlPrinter::VisitExit( const TiXmlDocument& )\n{\n\treturn true;\n}\n\nbool TiXmlPrinter::VisitEnter( const TiXmlElement& element, const TiXmlAttribute* firstAttribute )\n{\n\tDoIndent();\n\tbuffer += \"<\";\n\tbuffer += element.Value();\n\n\tfor( const TiXmlAttribute* attrib = firstAttribute; attrib; attrib = attrib->Next() )\n\t{\n\t\tbuffer += \" \";\n\t\tattrib->Print( 0, 0, &buffer );\n\t}\n\n\tif ( !element.FirstChild() ) \n\t{\n\t\tbuffer += \" />\";\n\t\tDoLineBreak();\n\t}\n\telse \n\t{\n\t\tbuffer += \">\";\n\t\tif (    element.FirstChild()->ToText()\n\t\t\t  && element.LastChild() == element.FirstChild()\n\t\t\t  && element.FirstChild()->ToText()->CDATA() == false )\n\t\t{\n\t\t\tsimpleTextPrint = true;\n\t\t\t// no DoLineBreak()!\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDoLineBreak();\n\t\t}\n\t}\n\t++depth;\t\n\treturn true;\n}\n\n\nbool TiXmlPrinter::VisitExit( const TiXmlElement& element )\n{\n\t--depth;\n\tif ( !element.FirstChild() ) \n\t{\n\t\t// nothing.\n\t}\n\telse \n\t{\n\t\tif ( simpleTextPrint )\n\t\t{\n\t\t\tsimpleTextPrint = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDoIndent();\n\t\t}\n\t\tbuffer += \"</\";\n\t\tbuffer += element.Value();\n\t\tbuffer += \">\";\n\t\tDoLineBreak();\n\t}\n\treturn true;\n}\n\n\nbool TiXmlPrinter::Visit( const TiXmlText& text )\n{\n\tif ( text.CDATA() )\n\t{\n\t\tDoIndent();\n\t\tbuffer += \"<![CDATA[\";\n\t\tbuffer += text.Value();\n\t\tbuffer += \"]]>\";\n\t\tDoLineBreak();\n\t}\n\telse if ( simpleTextPrint )\n\t{\n\t\tTIXML_STRING str;\n\t\tTiXmlBase::EncodeString( text.ValueTStr(), &str );\n\t\tbuffer += str;\n\t}\n\telse\n\t{\n\t\tDoIndent();\n\t\tTIXML_STRING str;\n\t\tTiXmlBase::EncodeString( text.ValueTStr(), &str );\n\t\tbuffer += str;\n\t\tDoLineBreak();\n\t}\n\treturn true;\n}\n\n\nbool TiXmlPrinter::Visit( const TiXmlDeclaration& declaration )\n{\n\tDoIndent();\n\tdeclaration.Print( 0, 0, &buffer );\n\tDoLineBreak();\n\treturn true;\n}\n\n\nbool TiXmlPrinter::Visit( const TiXmlComment& comment )\n{\n\tDoIndent();\n\tbuffer += \"<!--\";\n\tbuffer += comment.Value();\n\tbuffer += \"-->\";\n\tDoLineBreak();\n\treturn true;\n}\n\n\nbool TiXmlPrinter::Visit( const TiXmlUnknown& unknown )\n{\n\tDoIndent();\n\tbuffer += \"<\";\n\tbuffer += unknown.Value();\n\tbuffer += \">\";\n\tDoLineBreak();\n\treturn true;\n}\n\n","/*\nwww.sourceforge.net/projects/tinyxml\nOriginal code by Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied \nwarranty. In no event will the authors be held liable for any \ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any \npurpose, including commercial applications, and to alter it and \nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must \nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and \nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source \ndistribution.\n*/\n\n#include <ctype.h>\n#include <stddef.h>\n\n#include \"tinyxml.h\"\n\n//#define DEBUG_PARSER\n#if defined( DEBUG_PARSER )\n#\tif defined( DEBUG ) && defined( _MSC_VER )\n#\t\tinclude <windows.h>\n#\t\tdefine TIXML_LOG OutputDebugString\n#\telse\n#\t\tdefine TIXML_LOG printf\n#\tendif\n#endif\n\n// Note tha \"PutString\" hardcodes the same list. This\n// is less flexible than it appears. Changing the entries\n// or order will break putstring.\t\nTiXmlBase::Entity TiXmlBase::entity[ TiXmlBase::NUM_ENTITY ] = \n{\n\t{ \"&amp;\",  5, '&' },\n\t{ \"&lt;\",   4, '<' },\n\t{ \"&gt;\",   4, '>' },\n\t{ \"&quot;\", 6, '\\\"' },\n\t{ \"&apos;\", 6, '\\'' }\n};\n\n// Bunch of unicode info at:\n//\t\thttp://www.unicode.org/faq/utf_bom.html\n// Including the basic of this table, which determines the #bytes in the\n// sequence from the lead byte. 1 placed for invalid sequences --\n// although the result will be junk, pass it through as much as possible.\n// Beware of the non-characters in UTF-8:\t\n//\t\t\t\tef bb bf (Microsoft \"lead bytes\")\n//\t\t\t\tef bf be\n//\t\t\t\tef bf bf \n\nconst unsigned char TIXML_UTF_LEAD_0 = 0xefU;\nconst unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\nconst unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\n\nconst int TiXmlBase::utf8ByteTable[256] = \n{\n\t//\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\ta\tb\tc\td\te\tf\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x00\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x10\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x20\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x30\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x40\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x50\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x60\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x70\tEnd of ASCII range\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x80 0x80 to 0xc1 invalid\n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0x90 \n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0xa0 \n\t\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t// 0xb0 \n\t\t1,\t1,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t// 0xc0 0xc2 to 0xdf 2 byte\n\t\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t2,\t// 0xd0\n\t\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t3,\t// 0xe0 0xe0 to 0xef 3 byte\n\t\t4,\t4,\t4,\t4,\t4,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1,\t1\t// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid\n};\n\n\nvoid TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )\n{\n\tconst unsigned long BYTE_MASK = 0xBF;\n\tconst unsigned long BYTE_MARK = 0x80;\n\tconst unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n\n\tif (input < 0x80) \n\t\t*length = 1;\n\telse if ( input < 0x800 )\n\t\t*length = 2;\n\telse if ( input < 0x10000 )\n\t\t*length = 3;\n\telse if ( input < 0x200000 )\n\t\t*length = 4;\n\telse\n\t\t{ *length = 0; return; }\t// This code won't covert this correctly anyway.\n\n\toutput += *length;\n\n\t// Scary scary fall throughs.\n\tswitch (*length) \n\t{\n\t\tcase 4:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 3:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 2:\n\t\t\t--output; \n\t\t\t*output = (char)((input | BYTE_MARK) & BYTE_MASK); \n\t\t\tinput >>= 6;\n\t\tcase 1:\n\t\t\t--output; \n\t\t\t*output = (char)(input | FIRST_BYTE_MARK[*length]);\n\t}\n}\n\n\n/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding /*encoding*/ )\n{\n\t// This will only work for low-ascii, everything else is assumed to be a valid\n\t// letter. I'm not sure this is the best approach, but it is quite tricky trying\n\t// to figure out alhabetical vs. not across encoding. So take a very \n\t// conservative approach.\n\n//\tif ( encoding == TIXML_ENCODING_UTF8 )\n//\t{\n\t\tif ( anyByte < 127 )\n\t\t\treturn isalpha( anyByte );\n\t\telse\n\t\t\treturn 1;\t// What else to do? The unicode set is huge...get the english ones right.\n//\t}\n//\telse\n//\t{\n//\t\treturn isalpha( anyByte );\n//\t}\n}\n\n\n/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding /*encoding*/ )\n{\n\t// This will only work for low-ascii, everything else is assumed to be a valid\n\t// letter. I'm not sure this is the best approach, but it is quite tricky trying\n\t// to figure out alhabetical vs. not across encoding. So take a very \n\t// conservative approach.\n\n//\tif ( encoding == TIXML_ENCODING_UTF8 )\n//\t{\n\t\tif ( anyByte < 127 )\n\t\t\treturn isalnum( anyByte );\n\t\telse\n\t\t\treturn 1;\t// What else to do? The unicode set is huge...get the english ones right.\n//\t}\n//\telse\n//\t{\n//\t\treturn isalnum( anyByte );\n//\t}\n}\n\n\nclass TiXmlParsingData\n{\n\tfriend class TiXmlDocument;\n  public:\n\tvoid Stamp( const char* now, TiXmlEncoding encoding );\n\n\tconst TiXmlCursor& Cursor() const\t{ return cursor; }\n\n  private:\n\t// Only used by the document!\n\tTiXmlParsingData( const char* start, int _tabsize, int row, int col )\n\t{\n\t\tassert( start );\n\t\tstamp = start;\n\t\ttabsize = _tabsize;\n\t\tcursor.row = row;\n\t\tcursor.col = col;\n\t}\n\n\tTiXmlCursor\t\tcursor;\n\tconst char*\t\tstamp;\n\tint\t\t\t\ttabsize;\n};\n\n\nvoid TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )\n{\n\tassert( now );\n\n\t// Do nothing if the tabsize is 0.\n\tif ( tabsize < 1 )\n\t{\n\t\treturn;\n\t}\n\n\t// Get the current row, column.\n\tint row = cursor.row;\n\tint col = cursor.col;\n\tconst char* p = stamp;\n\tassert( p );\n\n\twhile ( p < now )\n\t{\n\t\t// Treat p as unsigned, so we have a happy compiler.\n\t\tconst unsigned char* pU = (const unsigned char*)p;\n\n\t\t// Code contributed by Fletcher Dunn: (modified by lee)\n\t\tswitch (*pU) {\n\t\t\tcase 0:\n\t\t\t\t// We *should* never get here, but in case we do, don't\n\t\t\t\t// advance past the terminating null character, ever\n\t\t\t\treturn;\n\n\t\t\tcase '\\r':\n\t\t\t\t// bump down to the next line\n\t\t\t\t++row;\n\t\t\t\tcol = 0;\t\t\t\t\n\t\t\t\t// Eat the character\n\t\t\t\t++p;\n\n\t\t\t\t// Check for \\r\\n sequence, and treat this as a single character\n\t\t\t\tif (*p == '\\n') {\n\t\t\t\t\t++p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\t\t// bump down to the next line\n\t\t\t\t++row;\n\t\t\t\tcol = 0;\n\n\t\t\t\t// Eat the character\n\t\t\t\t++p;\n\n\t\t\t\t// Check for \\n\\r sequence, and treat this as a single\n\t\t\t\t// character.  (Yes, this bizarre thing does occur still\n\t\t\t\t// on some arcane platforms...)\n\t\t\t\tif (*p == '\\r') {\n\t\t\t\t\t++p;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase '\\t':\n\t\t\t\t// Eat the character\n\t\t\t\t++p;\n\n\t\t\t\t// Skip to next tab stop\n\t\t\t\tcol = (col / tabsize + 1) * tabsize;\n\t\t\t\tbreak;\n\n\t\t\tcase TIXML_UTF_LEAD_0:\n\t\t\t\tif ( encoding == TIXML_ENCODING_UTF8 )\n\t\t\t\t{\n\t\t\t\t\tif ( *(p+1) && *(p+2) )\n\t\t\t\t\t{\n\t\t\t\t\t\t// In these cases, don't advance the column. These are\n\t\t\t\t\t\t// 0-width spaces.\n\t\t\t\t\t\tif ( *(pU+1)==TIXML_UTF_LEAD_1 && *(pU+2)==TIXML_UTF_LEAD_2 )\n\t\t\t\t\t\t\tp += 3;\t\n\t\t\t\t\t\telse if ( *(pU+1)==0xbfU && *(pU+2)==0xbeU )\n\t\t\t\t\t\t\tp += 3;\t\n\t\t\t\t\t\telse if ( *(pU+1)==0xbfU && *(pU+2)==0xbfU )\n\t\t\t\t\t\t\tp += 3;\t\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{ p +=3; ++col; }\t// A normal character.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++p;\n\t\t\t\t\t++col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif ( encoding == TIXML_ENCODING_UTF8 )\n\t\t\t\t{\n\t\t\t\t\t// Eat the 1 to 4 byte utf8 character.\n\t\t\t\t\tint step = TiXmlBase::utf8ByteTable[*((const unsigned char*)p)];\n\t\t\t\t\tif ( step == 0 )\n\t\t\t\t\t\tstep = 1;\t\t// Error case from bad encoding, but handle gracefully.\n\t\t\t\t\tp += step;\n\n\t\t\t\t\t// Just advance one column, of course.\n\t\t\t\t\t++col;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++p;\n\t\t\t\t\t++col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcursor.row = row;\n\tcursor.col = col;\n\tassert( cursor.row >= -1 );\n\tassert( cursor.col >= -1 );\n\tstamp = p;\n\tassert( stamp );\n}\n\n\nconst char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )\n{\n\tif ( !p || !*p )\n\t{\n\t\treturn 0;\n\t}\n\tif ( encoding == TIXML_ENCODING_UTF8 )\n\t{\n\t\twhile ( *p )\n\t\t{\n\t\t\tconst unsigned char* pU = (const unsigned char*)p;\n\t\t\t\n\t\t\t// Skip the stupid Microsoft UTF-8 Byte order marks\n\t\t\tif (\t*(pU+0)==TIXML_UTF_LEAD_0\n\t\t\t\t && *(pU+1)==TIXML_UTF_LEAD_1 \n\t\t\t\t && *(pU+2)==TIXML_UTF_LEAD_2 )\n\t\t\t{\n\t\t\t\tp += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(*(pU+0)==TIXML_UTF_LEAD_0\n\t\t\t\t && *(pU+1)==0xbfU\n\t\t\t\t && *(pU+2)==0xbeU )\n\t\t\t{\n\t\t\t\tp += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(*(pU+0)==TIXML_UTF_LEAD_0\n\t\t\t\t && *(pU+1)==0xbfU\n\t\t\t\t && *(pU+2)==0xbfU )\n\t\t\t{\n\t\t\t\tp += 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( IsWhiteSpace( *p ) )\t\t// Still using old rules for white space.\n\t\t\t\t++p;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile ( *p && IsWhiteSpace( *p ) )\n\t\t\t++p;\n\t}\n\n\treturn p;\n}\n\n#ifdef TIXML_USE_STL\n/*static*/ bool TiXmlBase::StreamWhiteSpace( std::istream * in, TIXML_STRING * tag )\n{\n\tfor( ;; )\n\t{\n\t\tif ( !in->good() ) return false;\n\n\t\tint c = in->peek();\n\t\t// At this scope, we can't get to a document. So fail silently.\n\t\tif ( !IsWhiteSpace( c ) || c <= 0 )\n\t\t\treturn true;\n\n\t\t*tag += (char) in->get();\n\t}\n}\n\n/*static*/ bool TiXmlBase::StreamTo( std::istream * in, int character, TIXML_STRING * tag )\n{\n\t//assert( character > 0 && character < 128 );\t// else it won't work in utf-8\n\twhile ( in->good() )\n\t{\n\t\tint c = in->peek();\n\t\tif ( c == character )\n\t\t\treturn true;\n\t\tif ( c <= 0 )\t\t// Silent failure: can't get document at this scope\n\t\t\treturn false;\n\n\t\tin->get();\n\t\t*tag += (char) c;\n\t}\n\treturn false;\n}\n#endif\n\n// One of TinyXML's more performance demanding functions. Try to keep the memory overhead down. The\n// \"assign\" optimization removes over 10% of the execution time.\n//\nconst char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )\n{\n\t// Oddly, not supported on some comilers,\n\t//name->clear();\n\t// So use this:\n\t*name = \"\";\n\tassert( p );\n\n\t// Names start with letters or underscores.\n\t// Of course, in unicode, tinyxml has no idea what a letter *is*. The\n\t// algorithm is generous.\n\t//\n\t// After that, they can be letters, underscores, numbers,\n\t// hyphens, or colons. (Colons are valid ony for namespaces,\n\t// but tinyxml can't tell namespaces from names.)\n\tif (    p && *p \n\t\t && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )\n\t{\n\t\tconst char* start = p;\n\t\twhile(\t\tp && *p\n\t\t\t\t&&\t(\t\tIsAlphaNum( (unsigned char ) *p, encoding ) \n\t\t\t\t\t\t || *p == '_'\n\t\t\t\t\t\t || *p == '-'\n\t\t\t\t\t\t || *p == '.'\n\t\t\t\t\t\t || *p == ':' ) )\n\t\t{\n\t\t\t//(*name) += *p; // expensive\n\t\t\t++p;\n\t\t}\n\t\tif ( p-start > 0 ) {\n\t\t\tname->assign( start, p-start );\n\t\t}\n\t\treturn p;\n\t}\n\treturn 0;\n}\n\nconst char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )\n{\n\t// Presume an entity, and pull it out.\n    TIXML_STRING ent;\n\tint i;\n\t*length = 0;\n\n\tif ( *(p+1) && *(p+1) == '#' && *(p+2) )\n\t{\n\t\tunsigned long ucs = 0;\n\t\tptrdiff_t delta = 0;\n\t\tunsigned mult = 1;\n\n\t\tif ( *(p+2) == 'x' )\n\t\t{\n\t\t\t// Hexadecimal.\n\t\t\tif ( !*(p+3) ) return 0;\n\n\t\t\tconst char* q = p+3;\n\t\t\tq = strchr( q, ';' );\n\n\t\t\tif ( !q || !*q ) return 0;\n\n\t\t\tdelta = q-p;\n\t\t\t--q;\n\n\t\t\twhile ( *q != 'x' )\n\t\t\t{\n\t\t\t\tif ( *q >= '0' && *q <= '9' )\n\t\t\t\t\tucs += mult * (*q - '0');\n\t\t\t\telse if ( *q >= 'a' && *q <= 'f' )\n\t\t\t\t\tucs += mult * (*q - 'a' + 10);\n\t\t\t\telse if ( *q >= 'A' && *q <= 'F' )\n\t\t\t\t\tucs += mult * (*q - 'A' + 10 );\n\t\t\t\telse \n\t\t\t\t\treturn 0;\n\t\t\t\tmult *= 16;\n\t\t\t\t--q;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Decimal.\n\t\t\tif ( !*(p+2) ) return 0;\n\n\t\t\tconst char* q = p+2;\n\t\t\tq = strchr( q, ';' );\n\n\t\t\tif ( !q || !*q ) return 0;\n\n\t\t\tdelta = q-p;\n\t\t\t--q;\n\n\t\t\twhile ( *q != '#' )\n\t\t\t{\n\t\t\t\tif ( *q >= '0' && *q <= '9' )\n\t\t\t\t\tucs += mult * (*q - '0');\n\t\t\t\telse \n\t\t\t\t\treturn 0;\n\t\t\t\tmult *= 10;\n\t\t\t\t--q;\n\t\t\t}\n\t\t}\n\t\tif ( encoding == TIXML_ENCODING_UTF8 )\n\t\t{\n\t\t\t// convert the UCS to UTF-8\n\t\t\tConvertUTF32ToUTF8( ucs, value, length );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*value = (char)ucs;\n\t\t\t*length = 1;\n\t\t}\n\t\treturn p + delta + 1;\n\t}\n\n\t// Now try to match it.\n\tfor( i=0; i<NUM_ENTITY; ++i )\n\t{\n\t\tif ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )\n\t\t{\n\t\t\tassert( strlen( entity[i].str ) == entity[i].strLength );\n\t\t\t*value = entity[i].chr;\n\t\t\t*length = 1;\n\t\t\treturn ( p + entity[i].strLength );\n\t\t}\n\t}\n\n\t// So it wasn't an entity, its unrecognized, or something like that.\n\t*value = *p;\t// Don't put back the last one, since we return it!\n\t//*length = 1;\t// Leave unrecognized entities - this doesn't really work.\n\t\t\t\t\t// Just writes strange XML.\n\treturn p+1;\n}\n\n\nbool TiXmlBase::StringEqual( const char* p,\n\t\t\t\t\t\t\t const char* tag,\n\t\t\t\t\t\t\t bool ignoreCase,\n\t\t\t\t\t\t\t TiXmlEncoding encoding )\n{\n\tassert( p );\n\tassert( tag );\n\tif ( !p || !*p )\n\t{\n\t\tassert( 0 );\n\t\treturn false;\n\t}\n\n\tconst char* q = p;\n\n\tif ( ignoreCase )\n\t{\n\t\twhile ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )\n\t\t{\n\t\t\t++q;\n\t\t\t++tag;\n\t\t}\n\n\t\tif ( *tag == 0 )\n\t\t\treturn true;\n\t}\n\telse\n\t{\n\t\twhile ( *q && *tag && *q == *tag )\n\t\t{\n\t\t\t++q;\n\t\t\t++tag;\n\t\t}\n\n\t\tif ( *tag == 0 )\t\t// Have we found the end of the tag, and everything equal?\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nconst char* TiXmlBase::ReadText(\tconst char* p, \n\t\t\t\t\t\t\t\t\tTIXML_STRING * text, \n\t\t\t\t\t\t\t\t\tbool trimWhiteSpace, \n\t\t\t\t\t\t\t\t\tconst char* endTag, \n\t\t\t\t\t\t\t\t\tbool caseInsensitive,\n\t\t\t\t\t\t\t\t\tTiXmlEncoding encoding )\n{\n    *text = \"\";\n\tif (    !trimWhiteSpace\t\t\t// certain tags always keep whitespace\n\t\t || !condenseWhiteSpace )\t// if true, whitespace is always kept\n\t{\n\t\t// Keep all the white space.\n\t\twhile (\t   p && *p\n\t\t\t\t&& !StringEqual( p, endTag, caseInsensitive, encoding )\n\t\t\t  )\n\t\t{\n\t\t\tint len;\n\t\t\tchar cArr[4] = { 0, 0, 0, 0 };\n\t\t\tp = GetChar( p, cArr, &len, encoding );\n\t\t\ttext->append( cArr, len );\n\t\t}\n\t}\n\telse\n\t{\n\t\tbool whitespace = false;\n\n\t\t// Remove leading white space:\n\t\tp = SkipWhiteSpace( p, encoding );\n\t\twhile (\t   p && *p\n\t\t\t\t&& !StringEqual( p, endTag, caseInsensitive, encoding ) )\n\t\t{\n\t\t\tif ( *p == '\\r' || *p == '\\n' )\n\t\t\t{\n\t\t\t\twhitespace = true;\n\t\t\t\t++p;\n\t\t\t}\n\t\t\telse if ( IsWhiteSpace( *p ) )\n\t\t\t{\n\t\t\t\twhitespace = true;\n\t\t\t\t++p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// If we've found whitespace, add it before the\n\t\t\t\t// new character. Any whitespace just becomes a space.\n\t\t\t\tif ( whitespace )\n\t\t\t\t{\n\t\t\t\t\t(*text) += ' ';\n\t\t\t\t\twhitespace = false;\n\t\t\t\t}\n\t\t\t\tint len;\n\t\t\t\tchar cArr[4] = { 0, 0, 0, 0 };\n\t\t\t\tp = GetChar( p, cArr, &len, encoding );\n\t\t\t\tif ( len == 1 )\n\t\t\t\t\t(*text) += cArr[0];\t// more efficient\n\t\t\t\telse\n\t\t\t\t\ttext->append( cArr, len );\n\t\t\t}\n\t\t}\n\t}\n\tif ( p && *p )\n\t\tp += strlen( endTag );\n\treturn ( p && *p ) ? p : 0;\n}\n\n#ifdef TIXML_USE_STL\n\nvoid TiXmlDocument::StreamIn( std::istream * in, TIXML_STRING * tag )\n{\n\t// The basic issue with a document is that we don't know what we're\n\t// streaming. Read something presumed to be a tag (and hope), then\n\t// identify it, and call the appropriate stream method on the tag.\n\t//\n\t// This \"pre-streaming\" will never read the closing \">\" so the\n\t// sub-tag can orient itself.\n\n\tif ( !StreamTo( in, '<', tag ) ) \n\t{\n\t\tSetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn;\n\t}\n\n\twhile ( in->good() )\n\t{\n\t\tint tagIndex = (int) tag->length();\n\t\twhile ( in->good() && in->peek() != '>' )\n\t\t{\n\t\t\tint c = in->get();\n\t\t\tif ( c <= 0 )\n\t\t\t{\n\t\t\t\tSetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*tag) += (char) c;\n\t\t}\n\n\t\tif ( in->good() )\n\t\t{\n\t\t\t// We now have something we presume to be a node of \n\t\t\t// some sort. Identify it, and call the node to\n\t\t\t// continue streaming.\n\t\t\tTiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );\n\n\t\t\tif ( node )\n\t\t\t{\n\t\t\t\tnode->StreamIn( in, tag );\n\t\t\t\tbool isElement = node->ToElement() != 0;\n\t\t\t\tdelete node;\n\t\t\t\tnode = 0;\n\n\t\t\t\t// If this is the root element, we're done. Parsing will be\n\t\t\t\t// done by the >> operator.\n\t\t\t\tif ( isElement )\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t// We should have returned sooner.\n\tSetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );\n}\n\n#endif\n\nconst char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )\n{\n\tClearError();\n\n\t// Parse away, at the document level. Since a document\n\t// contains nothing but other tags, most of what happens\n\t// here is skipping white space.\n\tif ( !p || !*p )\n\t{\n\t\tSetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn 0;\n\t}\n\n\t// Note that, for a document, this needs to come\n\t// before the while space skip, so that parsing\n\t// starts from the pointer we are given.\n\tlocation.Clear();\n\tif ( prevData )\n\t{\n\t\tlocation.row = prevData->cursor.row;\n\t\tlocation.col = prevData->cursor.col;\n\t}\n\telse\n\t{\n\t\tlocation.row = 0;\n\t\tlocation.col = 0;\n\t}\n\tTiXmlParsingData data( p, TabSize(), location.row, location.col );\n\tlocation = data.Cursor();\n\n\tif ( encoding == TIXML_ENCODING_UNKNOWN )\n\t{\n\t\t// Check for the Microsoft UTF-8 lead bytes.\n\t\tconst unsigned char* pU = (const unsigned char*)p;\n\t\tif (\t*(pU+0) && *(pU+0) == TIXML_UTF_LEAD_0\n\t\t\t && *(pU+1) && *(pU+1) == TIXML_UTF_LEAD_1\n\t\t\t && *(pU+2) && *(pU+2) == TIXML_UTF_LEAD_2 )\n\t\t{\n\t\t\tencoding = TIXML_ENCODING_UTF8;\n\t\t\tuseMicrosoftBOM = true;\n\t\t}\n\t}\n\n    p = SkipWhiteSpace( p, encoding );\n\tif ( !p )\n\t{\n\t\tSetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\treturn 0;\n\t}\n\n\twhile ( p && *p )\n\t{\n\t\tTiXmlNode* node = Identify( p, encoding );\n\t\tif ( node )\n\t\t{\n\t\t\tp = node->Parse( p, &data, encoding );\n\t\t\tLinkEndChild( node );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t// Did we get encoding info?\n\t\tif (    encoding == TIXML_ENCODING_UNKNOWN\n\t\t\t && node->ToDeclaration() )\n\t\t{\n\t\t\tTiXmlDeclaration* dec = node->ToDeclaration();\n\t\t\tconst char* enc = dec->Encoding();\n\t\t\tassert( enc );\n\n\t\t\tif ( *enc == 0 )\n\t\t\t\tencoding = TIXML_ENCODING_UTF8;\n\t\t\telse if ( StringEqual( enc, \"UTF-8\", true, TIXML_ENCODING_UNKNOWN ) )\n\t\t\t\tencoding = TIXML_ENCODING_UTF8;\n\t\t\telse if ( StringEqual( enc, \"UTF8\", true, TIXML_ENCODING_UNKNOWN ) )\n\t\t\t\tencoding = TIXML_ENCODING_UTF8;\t// incorrect, but be nice\n\t\t\telse \n\t\t\t\tencoding = TIXML_ENCODING_LEGACY;\n\t\t}\n\n\t\tp = SkipWhiteSpace( p, encoding );\n\t}\n\n\t// Was this empty?\n\tif ( !firstChild ) {\n\t\tSetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, encoding );\n\t\treturn 0;\n\t}\n\n\t// All is well.\n\treturn p;\n}\n\nvoid TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )\n{\t\n\t// The first error in a chain is more accurate - don't set again!\n\tif ( error )\n\t\treturn;\n\n\tassert( err > 0 && err < TIXML_ERROR_STRING_COUNT );\n\terror   = true;\n\terrorId = err;\n\terrorDesc = errorString[ errorId ];\n\n\terrorLocation.Clear();\n\tif ( pError && data )\n\t{\n\t\tdata->Stamp( pError, encoding );\n\t\terrorLocation = data->Cursor();\n\t}\n}\n\n\nTiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )\n{\n\tTiXmlNode* returnNode = 0;\n\n\tp = SkipWhiteSpace( p, encoding );\n\tif( !p || !*p || *p != '<' )\n\t{\n\t\treturn 0;\n\t}\n\n\tp = SkipWhiteSpace( p, encoding );\n\n\tif ( !p || !*p )\n\t{\n\t\treturn 0;\n\t}\n\n\t// What is this thing? \n\t// - Elements start with a letter or underscore, but xml is reserved.\n\t// - Comments: <!--\n\t// - Decleration: <?xml\n\t// - Everthing else is unknown to tinyxml.\n\t//\n\n\tconst char* xmlHeader = { \"<?xml\" };\n\tconst char* commentHeader = { \"<!--\" };\n\tconst char* dtdHeader = { \"<!\" };\n\tconst char* cdataHeader = { \"<![CDATA[\" };\n\n\tif ( StringEqual( p, xmlHeader, true, encoding ) )\n\t{\n\t\t#ifdef DEBUG_PARSER\n\t\t\tTIXML_LOG( \"XML parsing Declaration\\n\" );\n\t\t#endif\n\t\treturnNode = new TiXmlDeclaration();\n\t}\n\telse if ( StringEqual( p, commentHeader, false, encoding ) )\n\t{\n\t\t#ifdef DEBUG_PARSER\n\t\t\tTIXML_LOG( \"XML parsing Comment\\n\" );\n\t\t#endif\n\t\treturnNode = new TiXmlComment();\n\t}\n\telse if ( StringEqual( p, cdataHeader, false, encoding ) )\n\t{\n\t\t#ifdef DEBUG_PARSER\n\t\t\tTIXML_LOG( \"XML parsing CDATA\\n\" );\n\t\t#endif\n\t\tTiXmlText* text = new TiXmlText( \"\" );\n\t\ttext->SetCDATA( true );\n\t\treturnNode = text;\n\t}\n\telse if ( StringEqual( p, dtdHeader, false, encoding ) )\n\t{\n\t\t#ifdef DEBUG_PARSER\n\t\t\tTIXML_LOG( \"XML parsing Unknown(1)\\n\" );\n\t\t#endif\n\t\treturnNode = new TiXmlUnknown();\n\t}\n\telse if (    IsAlpha( *(p+1), encoding )\n\t\t\t  || *(p+1) == '_' )\n\t{\n\t\t#ifdef DEBUG_PARSER\n\t\t\tTIXML_LOG( \"XML parsing Element\\n\" );\n\t\t#endif\n\t\treturnNode = new TiXmlElement( \"\" );\n\t}\n\telse\n\t{\n\t\t#ifdef DEBUG_PARSER\n\t\t\tTIXML_LOG( \"XML parsing Unknown(2)\\n\" );\n\t\t#endif\n\t\treturnNode = new TiXmlUnknown();\n\t}\n\n\tif ( returnNode )\n\t{\n\t\t// Set the parent, so it can report errors\n\t\treturnNode->parent = this;\n\t}\n\treturn returnNode;\n}\n\n#ifdef TIXML_USE_STL\n\nvoid TiXmlElement::StreamIn (std::istream * in, TIXML_STRING * tag)\n{\n\t// We're called with some amount of pre-parsing. That is, some of \"this\"\n\t// element is in \"tag\". Go ahead and stream to the closing \">\"\n\twhile( in->good() )\n\t{\n\t\tint c = in->get();\n\t\tif ( c <= 0 )\n\t\t{\n\t\t\tTiXmlDocument* document = GetDocument();\n\t\t\tif ( document )\n\t\t\t\tdocument->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\treturn;\n\t\t}\n\t\t(*tag) += (char) c ;\n\t\t\n\t\tif ( c == '>' )\n\t\t\tbreak;\n\t}\n\n\tif ( tag->length() < 3 ) return;\n\n\t// Okay...if we are a \"/>\" tag, then we're done. We've read a complete tag.\n\t// If not, identify and stream.\n\n\tif (    tag->at( tag->length() - 1 ) == '>' \n\t\t && tag->at( tag->length() - 2 ) == '/' )\n\t{\n\t\t// All good!\n\t\treturn;\n\t}\n\telse if ( tag->at( tag->length() - 1 ) == '>' )\n\t{\n\t\t// There is more. Could be:\n\t\t//\t\ttext\n\t\t//\t\tcdata text (which looks like another node)\n\t\t//\t\tclosing tag\n\t\t//\t\tanother node.\n\t\tfor ( ;; )\n\t\t{\n\t\t\tStreamWhiteSpace( in, tag );\n\n\t\t\t// Do we have text?\n\t\t\tif ( in->good() && in->peek() != '<' ) \n\t\t\t{\n\t\t\t\t// Yep, text.\n\t\t\t\tTiXmlText text( \"\" );\n\t\t\t\ttext.StreamIn( in, tag );\n\n\t\t\t\t// What follows text is a closing tag or another node.\n\t\t\t\t// Go around again and figure it out.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// We now have either a closing tag...or another node.\n\t\t\t// We should be at a \"<\", regardless.\n\t\t\tif ( !in->good() ) return;\n\t\t\tassert( in->peek() == '<' );\n\t\t\tint tagIndex = (int) tag->length();\n\n\t\t\tbool closingTag = false;\n\t\t\tbool firstCharFound = false;\n\n\t\t\tfor( ;; )\n\t\t\t{\n\t\t\t\tif ( !in->good() )\n\t\t\t\t\treturn;\n\n\t\t\t\tint c = in->peek();\n\t\t\t\tif ( c <= 0 )\n\t\t\t\t{\n\t\t\t\t\tTiXmlDocument* document = GetDocument();\n\t\t\t\t\tif ( document )\n\t\t\t\t\t\tdocument->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( c == '>' )\n\t\t\t\t\tbreak;\n\n\t\t\t\t*tag += (char) c;\n\t\t\t\tin->get();\n\n\t\t\t\t// Early out if we find the CDATA id.\n\t\t\t\tif ( c == '[' && tag->size() >= 9 )\n\t\t\t\t{\n\t\t\t\t\tsize_t len = tag->size();\n\t\t\t\t\tconst char* start = tag->c_str() + len - 9;\n\t\t\t\t\tif ( strcmp( start, \"<![CDATA[\" ) == 0 ) {\n\t\t\t\t\t\tassert( !closingTag );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )\n\t\t\t\t{\n\t\t\t\t\tfirstCharFound = true;\n\t\t\t\t\tif ( c == '/' )\n\t\t\t\t\t\tclosingTag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If it was a closing tag, then read in the closing '>' to clean up the input stream.\n\t\t\t// If it was not, the streaming will be done by the tag.\n\t\t\tif ( closingTag )\n\t\t\t{\n\t\t\t\tif ( !in->good() )\n\t\t\t\t\treturn;\n\n\t\t\t\tint c = in->get();\n\t\t\t\tif ( c <= 0 )\n\t\t\t\t{\n\t\t\t\t\tTiXmlDocument* document = GetDocument();\n\t\t\t\t\tif ( document )\n\t\t\t\t\t\tdocument->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tassert( c == '>' );\n\t\t\t\t*tag += (char) c;\n\n\t\t\t\t// We are done, once we've found our closing tag.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// If not a closing tag, id it, and stream.\n\t\t\t\tconst char* tagloc = tag->c_str() + tagIndex;\n\t\t\t\tTiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );\n\t\t\t\tif ( !node )\n\t\t\t\t\treturn;\n\t\t\t\tnode->StreamIn( in, tag );\n\t\t\t\tdelete node;\n\t\t\t\tnode = 0;\n\n\t\t\t\t// No return: go around from the beginning: text, closing tag, or node.\n\t\t\t}\n\t\t}\n\t}\n}\n#endif\n\nconst char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )\n{\n\tp = SkipWhiteSpace( p, encoding );\n\tTiXmlDocument* document = GetDocument();\n\n\tif ( !p || !*p )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );\n\t\treturn 0;\n\t}\n\n\tif ( data )\n\t{\n\t\tdata->Stamp( p, encoding );\n\t\tlocation = data->Cursor();\n\t}\n\n\tif ( *p != '<' )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );\n\t\treturn 0;\n\t}\n\n\tp = SkipWhiteSpace( p+1, encoding );\n\n\t// Read the name.\n\tconst char* pErr = p;\n\n    p = ReadName( p, &value, encoding );\n\tif ( !p || !*p )\n\t{\n\t\tif ( document )\tdocument->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );\n\t\treturn 0;\n\t}\n\n    TIXML_STRING endTag (\"</\");\n\tendTag += value;\n\n\t// Check for and read attributes. Also look for an empty\n\t// tag or an end tag.\n\twhile ( p && *p )\n\t{\n\t\tpErr = p;\n\t\tp = SkipWhiteSpace( p, encoding );\n\t\tif ( !p || !*p )\n\t\t{\n\t\t\tif ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );\n\t\t\treturn 0;\n\t\t}\n\t\tif ( *p == '/' )\n\t\t{\n\t\t\t++p;\n\t\t\t// Empty tag.\n\t\t\tif ( *p  != '>' )\n\t\t\t{\n\t\t\t\tif ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn (p+1);\n\t\t}\n\t\telse if ( *p == '>' )\n\t\t{\n\t\t\t// Done with attributes (if there were any.)\n\t\t\t// Read the value -- which can include other\n\t\t\t// elements -- read the end tag, and return.\n\t\t\t++p;\n\t\t\tp = ReadValue( p, data, encoding );\t\t// Note this is an Element method, and will set the error if one happens.\n\t\t\tif ( !p || !*p ) {\n\t\t\t\t// We were looking for the end tag, but found nothing.\n\t\t\t\t// Fix for [ 1663758 ] Failure to report error on bad XML\n\t\t\t\tif ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// We should find the end tag now\n\t\t\t// note that:\n\t\t\t// </foo > and\n\t\t\t// </foo> \n\t\t\t// are both valid end tags.\n\t\t\tif ( StringEqual( p, endTag.c_str(), false, encoding ) )\n\t\t\t{\n\t\t\t\tp += endTag.length();\n\t\t\t\tp = SkipWhiteSpace( p, encoding );\n\t\t\t\tif ( p && *p && *p == '>' ) {\n\t\t\t\t\t++p;\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\t\t\t\tif ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Try to read an attribute:\n\t\t\tTiXmlAttribute* attrib = new TiXmlAttribute();\n\t\t\tif ( !attrib )\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tattrib->SetDocument( document );\n\t\t\tpErr = p;\n\t\t\tp = attrib->Parse( p, data, encoding );\n\n\t\t\tif ( !p || !*p )\n\t\t\t{\n\t\t\t\tif ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );\n\t\t\t\tdelete attrib;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Handle the strange case of double attributes:\n\t\t\t#ifdef TIXML_USE_STL\n\t\t\tTiXmlAttribute* node = attributeSet.Find( attrib->NameTStr() );\n\t\t\t#else\n\t\t\tTiXmlAttribute* node = attributeSet.Find( attrib->Name() );\n\t\t\t#endif\n\t\t\tif ( node )\n\t\t\t{\n\t\t\t\tif ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );\n\t\t\t\tdelete attrib;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tattributeSet.Add( attrib );\n\t\t}\n\t}\n\treturn p;\n}\n\n\nconst char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )\n{\n\tTiXmlDocument* document = GetDocument();\n\n\t// Read in text and elements in any order.\n\tconst char* pWithWhiteSpace = p;\n\tp = SkipWhiteSpace( p, encoding );\n\n\twhile ( p && *p )\n\t{\n\t\tif ( *p != '<' )\n\t\t{\n\t\t\t// Take what we have, make a text element.\n\t\t\tTiXmlText* textNode = new TiXmlText( \"\" );\n\n\t\t\tif ( !textNode )\n\t\t\t{\n\t\t\t    return 0;\n\t\t\t}\n\n\t\t\tif ( TiXmlBase::IsWhiteSpaceCondensed() )\n\t\t\t{\n\t\t\t\tp = textNode->Parse( p, data, encoding );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Special case: we want to keep the white space\n\t\t\t\t// so that leading spaces aren't removed.\n\t\t\t\tp = textNode->Parse( pWithWhiteSpace, data, encoding );\n\t\t\t}\n\n\t\t\tif ( !textNode->Blank() )\n\t\t\t\tLinkEndChild( textNode );\n\t\t\telse\n\t\t\t\tdelete textNode;\n\t\t} \n\t\telse \n\t\t{\n\t\t\t// We hit a '<'\n\t\t\t// Have we hit a new element or an end tag? This could also be\n\t\t\t// a TiXmlText in the \"CDATA\" style.\n\t\t\tif ( StringEqual( p, \"</\", false, encoding ) )\n\t\t\t{\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTiXmlNode* node = Identify( p, encoding );\n\t\t\t\tif ( node )\n\t\t\t\t{\n\t\t\t\t\tp = node->Parse( p, data, encoding );\n\t\t\t\t\tLinkEndChild( node );\n\t\t\t\t}\t\t\t\t\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpWithWhiteSpace = p;\n\t\tp = SkipWhiteSpace( p, encoding );\n\t}\n\n\tif ( !p )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );\n\t}\t\n\treturn p;\n}\n\n\n#ifdef TIXML_USE_STL\nvoid TiXmlUnknown::StreamIn( std::istream * in, TIXML_STRING * tag )\n{\n\twhile ( in->good() )\n\t{\n\t\tint c = in->get();\t\n\t\tif ( c <= 0 )\n\t\t{\n\t\t\tTiXmlDocument* document = GetDocument();\n\t\t\tif ( document )\n\t\t\t\tdocument->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\treturn;\n\t\t}\n\t\t(*tag) += (char) c;\n\n\t\tif ( c == '>' )\n\t\t{\n\t\t\t// All is well.\n\t\t\treturn;\t\t\n\t\t}\n\t}\n}\n#endif\n\n\nconst char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )\n{\n\tTiXmlDocument* document = GetDocument();\n\tp = SkipWhiteSpace( p, encoding );\n\n\tif ( data )\n\t{\n\t\tdata->Stamp( p, encoding );\n\t\tlocation = data->Cursor();\n\t}\n\tif ( !p || !*p || *p != '<' )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );\n\t\treturn 0;\n\t}\n\t++p;\n    value = \"\";\n\n\twhile ( p && *p && *p != '>' )\n\t{\n\t\tvalue += *p;\n\t\t++p;\n\t}\n\n\tif ( !p )\n\t{\n\t\tif ( document )\t\n\t\t\tdocument->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );\n\t}\n\tif ( p && *p == '>' )\n\t\treturn p+1;\n\treturn p;\n}\n\n#ifdef TIXML_USE_STL\nvoid TiXmlComment::StreamIn( std::istream * in, TIXML_STRING * tag )\n{\n\twhile ( in->good() )\n\t{\n\t\tint c = in->get();\t\n\t\tif ( c <= 0 )\n\t\t{\n\t\t\tTiXmlDocument* document = GetDocument();\n\t\t\tif ( document )\n\t\t\t\tdocument->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\treturn;\n\t\t}\n\n\t\t(*tag) += (char) c;\n\n\t\tif ( c == '>' \n\t\t\t && tag->at( tag->length() - 2 ) == '-'\n\t\t\t && tag->at( tag->length() - 3 ) == '-' )\n\t\t{\n\t\t\t// All is well.\n\t\t\treturn;\t\t\n\t\t}\n\t}\n}\n#endif\n\n\nconst char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )\n{\n\tTiXmlDocument* document = GetDocument();\n\tvalue = \"\";\n\n\tp = SkipWhiteSpace( p, encoding );\n\n\tif ( data )\n\t{\n\t\tdata->Stamp( p, encoding );\n\t\tlocation = data->Cursor();\n\t}\n\tconst char* startTag = \"<!--\";\n\tconst char* endTag   = \"-->\";\n\n\tif ( !StringEqual( p, startTag, false, encoding ) )\n\t{\n\t\tif ( document )\n\t\t\tdocument->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );\n\t\treturn 0;\n\t}\n\tp += strlen( startTag );\n\n\t// [ 1475201 ] TinyXML parses entities in comments\n\t// Oops - ReadText doesn't work, because we don't want to parse the entities.\n\t// p = ReadText( p, &value, false, endTag, false, encoding );\n\t//\n\t// from the XML spec:\n\t/*\n\t [Definition: Comments may appear anywhere in a document outside other markup; in addition, \n\t              they may appear within the document type declaration at places allowed by the grammar. \n\t\t\t\t  They are not part of the document's character data; an XML processor MAY, but need not, \n\t\t\t\t  make it possible for an application to retrieve the text of comments. For compatibility, \n\t\t\t\t  the string \"--\" (double-hyphen) MUST NOT occur within comments.] Parameter entity \n\t\t\t\t  references MUST NOT be recognized within comments.\n\n\t\t\t\t  An example of a comment:\n\n\t\t\t\t  <!-- declarations for <head> & <body> -->\n\t*/\n\n    value = \"\";\n\t// Keep all the white space.\n\twhile (\tp && *p && !StringEqual( p, endTag, false, encoding ) )\n\t{\n\t\tvalue.append( p, 1 );\n\t\t++p;\n\t}\n\tif ( p && *p ) \n\t\tp += strlen( endTag );\n\n\treturn p;\n}\n\n\nconst char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )\n{\n\tp = SkipWhiteSpace( p, encoding );\n\tif ( !p || !*p ) return 0;\n\n\tif ( data )\n\t{\n\t\tdata->Stamp( p, encoding );\n\t\tlocation = data->Cursor();\n\t}\n\t// Read the name, the '=' and the value.\n\tconst char* pErr = p;\n\tp = ReadName( p, &name, encoding );\n\tif ( !p || !*p )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );\n\t\treturn 0;\n\t}\n\tp = SkipWhiteSpace( p, encoding );\n\tif ( !p || !*p || *p != '=' )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );\n\t\treturn 0;\n\t}\n\n\t++p;\t// skip '='\n\tp = SkipWhiteSpace( p, encoding );\n\tif ( !p || !*p )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );\n\t\treturn 0;\n\t}\n\t\n\tconst char* end;\n\tconst char SINGLE_QUOTE = '\\'';\n\tconst char DOUBLE_QUOTE = '\\\"';\n\n\tif ( *p == SINGLE_QUOTE )\n\t{\n\t\t++p;\n\t\tend = \"\\'\";\t\t// single quote in string\n\t\tp = ReadText( p, &value, false, end, false, encoding );\n\t}\n\telse if ( *p == DOUBLE_QUOTE )\n\t{\n\t\t++p;\n\t\tend = \"\\\"\";\t\t// double quote in string\n\t\tp = ReadText( p, &value, false, end, false, encoding );\n\t}\n\telse\n\t{\n\t\t// All attribute values should be in single or double quotes.\n\t\t// But this is such a common error that the parser will try\n\t\t// its best, even without them.\n\t\tvalue = \"\";\n\t\twhile (    p && *p\t\t\t\t\t\t\t\t\t\t\t// existence\n\t\t\t\t&& !IsWhiteSpace( *p )\t\t\t\t\t\t\t\t// whitespace\n\t\t\t\t&& *p != '/' && *p != '>' )\t\t\t\t\t\t\t// tag end\n\t\t{\n\t\t\tif ( *p == SINGLE_QUOTE || *p == DOUBLE_QUOTE ) {\n\t\t\t\t// [ 1451649 ] Attribute values with trailing quotes not handled correctly\n\t\t\t\t// We did not have an opening quote but seem to have a \n\t\t\t\t// closing one. Give up and throw an error.\n\t\t\t\tif ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvalue += *p;\n\t\t\t++p;\n\t\t}\n\t}\n\treturn p;\n}\n\n#ifdef TIXML_USE_STL\nvoid TiXmlText::StreamIn( std::istream * in, TIXML_STRING * tag )\n{\n\twhile ( in->good() )\n\t{\n\t\tint c = in->peek();\t\n\t\tif ( !cdata && (c == '<' ) ) \n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif ( c <= 0 )\n\t\t{\n\t\t\tTiXmlDocument* document = GetDocument();\n\t\t\tif ( document )\n\t\t\t\tdocument->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\treturn;\n\t\t}\n\n\t\t(*tag) += (char) c;\n\t\tin->get();\t// \"commits\" the peek made above\n\n\t\tif ( cdata && c == '>' && tag->size() >= 3 ) {\n\t\t\tsize_t len = tag->size();\n\t\t\tif ( (*tag)[len-2] == ']' && (*tag)[len-3] == ']' ) {\n\t\t\t\t// terminator of cdata.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}    \n\t}\n}\n#endif\n\nconst char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )\n{\n\tvalue = \"\";\n\tTiXmlDocument* document = GetDocument();\n\n\tif ( data )\n\t{\n\t\tdata->Stamp( p, encoding );\n\t\tlocation = data->Cursor();\n\t}\n\n\tconst char* const startTag = \"<![CDATA[\";\n\tconst char* const endTag   = \"]]>\";\n\n\tif ( cdata || StringEqual( p, startTag, false, encoding ) )\n\t{\n\t\tcdata = true;\n\n\t\tif ( !StringEqual( p, startTag, false, encoding ) )\n\t\t{\n\t\t\tif ( document )\n\t\t\t\tdocument->SetError( TIXML_ERROR_PARSING_CDATA, p, data, encoding );\n\t\t\treturn 0;\n\t\t}\n\t\tp += strlen( startTag );\n\n\t\t// Keep all the white space, ignore the encoding, etc.\n\t\twhile (\t   p && *p\n\t\t\t\t&& !StringEqual( p, endTag, false, encoding )\n\t\t\t  )\n\t\t{\n\t\t\tvalue += *p;\n\t\t\t++p;\n\t\t}\n\n\t\tTIXML_STRING dummy; \n\t\tp = ReadText( p, &dummy, false, endTag, false, encoding );\n\t\treturn p;\n\t}\n\telse\n\t{\n\t\tbool ignoreWhite = true;\n\n\t\tconst char* end = \"<\";\n\t\tp = ReadText( p, &value, ignoreWhite, end, false, encoding );\n\t\tif ( p && *p )\n\t\t\treturn p-1;\t// don't truncate the '<'\n\t\treturn 0;\n\t}\n}\n\n#ifdef TIXML_USE_STL\nvoid TiXmlDeclaration::StreamIn( std::istream * in, TIXML_STRING * tag )\n{\n\twhile ( in->good() )\n\t{\n\t\tint c = in->get();\n\t\tif ( c <= 0 )\n\t\t{\n\t\t\tTiXmlDocument* document = GetDocument();\n\t\t\tif ( document )\n\t\t\t\tdocument->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );\n\t\t\treturn;\n\t\t}\n\t\t(*tag) += (char) c;\n\n\t\tif ( c == '>' )\n\t\t{\n\t\t\t// All is well.\n\t\t\treturn;\n\t\t}\n\t}\n}\n#endif\n\nconst char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )\n{\n\tp = SkipWhiteSpace( p, _encoding );\n\t// Find the beginning, find the end, and look for\n\t// the stuff in-between.\n\tTiXmlDocument* document = GetDocument();\n\tif ( !p || !*p || !StringEqual( p, \"<?xml\", true, _encoding ) )\n\t{\n\t\tif ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );\n\t\treturn 0;\n\t}\n\tif ( data )\n\t{\n\t\tdata->Stamp( p, _encoding );\n\t\tlocation = data->Cursor();\n\t}\n\tp += 5;\n\n\tversion = \"\";\n\tencoding = \"\";\n\tstandalone = \"\";\n\n\twhile ( p && *p )\n\t{\n\t\tif ( *p == '>' )\n\t\t{\n\t\t\t++p;\n\t\t\treturn p;\n\t\t}\n\n\t\tp = SkipWhiteSpace( p, _encoding );\n\t\tif ( StringEqual( p, \"version\", true, _encoding ) )\n\t\t{\n\t\t\tTiXmlAttribute attrib;\n\t\t\tp = attrib.Parse( p, data, _encoding );\t\t\n\t\t\tversion = attrib.Value();\n\t\t}\n\t\telse if ( StringEqual( p, \"encoding\", true, _encoding ) )\n\t\t{\n\t\t\tTiXmlAttribute attrib;\n\t\t\tp = attrib.Parse( p, data, _encoding );\t\t\n\t\t\tencoding = attrib.Value();\n\t\t}\n\t\telse if ( StringEqual( p, \"standalone\", true, _encoding ) )\n\t\t{\n\t\t\tTiXmlAttribute attrib;\n\t\t\tp = attrib.Parse( p, data, _encoding );\t\t\n\t\t\tstandalone = attrib.Value();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Read over whatever it is.\n\t\t\twhile( p && *p && *p != '>' && !IsWhiteSpace( *p ) )\n\t\t\t\t++p;\n\t\t}\n\t}\n\treturn 0;\n}\n\nbool TiXmlText::Blank() const\n{\n\tfor ( unsigned i=0; i<value.length(); i++ )\n\t\tif ( !IsWhiteSpace( value[i] ) )\n\t\t\treturn false;\n\treturn true;\n}\n\n","// -*- mode: c++; c-basic-offset: 4; -*-\n\n// Author: Hong Jiang <hong@hjiang.net>\n// Contributors:\n//   Sean Middleditch <sean@middleditch.us>\n//   rlyeh <https://github.com/r-lyeh>\n\n#include \"jsonxx.h\"\n\n#include <cctype>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <limits>\n\n// Snippet that creates an assertion function that works both in DEBUG & RELEASE mode.\n// JSONXX_ASSERT(...) macro will redirect to this. assert() macro is kept untouched.\n#if defined(NDEBUG) || defined(_NDEBUG)\n#   define JSONXX_REENABLE_NDEBUG\n#   undef  NDEBUG\n#   undef _NDEBUG\n#endif\n#include <stdio.h>\n#include <cassert>\nvoid jsonxx::assertion( const char *file, int line, const char *expression, bool result ) {\n    if( !result ) {\n        fprintf( stderr, \"[JSONXX] expression '%s' failed at %s:%d -> \", expression, file, line );\n        assert( 0 );\n    }\n}\n#if defined(JSONXX_REENABLE_NDEBUG)\n#   define  NDEBUG\n#   define _NDEBUG\n#endif\n#include <cassert>\n\nnamespace jsonxx {\n\n//static_assert( sizeof(unsigned long long) < sizeof(long double), \"'long double' cannot hold 64bit values in this compiler :(\");\n\nbool match(const char* pattern, std::istream& input);\nbool parse_array(std::istream& input, Array& array);\nbool parse_bool(std::istream& input, Boolean& value);\nbool parse_comment(std::istream &input);\nbool parse_null(std::istream& input);\nbool parse_number(std::istream& input, Number& value);\nbool parse_object(std::istream& input, Object& object);\nbool parse_string(std::istream& input, String& value);\nbool parse_value(std::istream& input, Value& value);\n\n// Try to consume characters from the input stream and match the\n// pattern string.\nbool match(const char* pattern, std::istream& input) {\n    input >> std::ws;\n    const char* cur(pattern);\n    char ch(0);\n    while(input && !input.eof() && *cur != 0) {\n        input.get(ch);\n        if (ch != *cur) {\n            input.putback(ch);\n            if( parse_comment(input) )\n                continue;\n            while (cur > pattern) {\n                cur--;\n                input.putback(*cur);\n            }\n            return false;\n        } else {\n            cur++;\n        }\n    }\n    return *cur == 0;\n}\n\nbool parse_string(std::istream& input, String& value) {\n    char ch = '\\0', delimiter = '\"';\n    if (!match(\"\\\"\", input))  {\n        if (Parser == Strict) {\n            return false;\n        }\n        delimiter = '\\'';\n        if (input.peek() != delimiter) {\n            return false;\n        }\n        input.get(ch);\n    }\n    while(!input.eof() && input.good()) {\n        input.get(ch);\n        if (ch == delimiter) {\n            break;\n        }\n        if (ch == '\\\\') {\n            input.get(ch);\n            switch(ch) {\n                case '\\\\':\n                case '/':\n                    value.push_back(ch);\n                    break;\n                case 'b':\n                    value.push_back('\\b');\n                    break;\n                case 'f':\n                    value.push_back('\\f');\n                    break;\n                case 'n':\n                    value.push_back('\\n');\n                    break;\n                case 'r':\n                    value.push_back('\\r');\n                    break;\n                case 't':\n                    value.push_back('\\t');\n                    break;\n                case 'u': {\n                        int i;\n                        std::stringstream ss;\n                        for( i = 0; (!input.eof() && input.good()) && i < 4; ++i ) {\n                            input.get(ch);\n                            ss << ch;\n                        }\n                        if( input.good() && (ss >> i) )\n                            value.push_back(i);\n                    }\n                    break;\n                default:\n                    if (ch != delimiter) {\n                        value.push_back('\\\\');\n                        value.push_back(ch);\n                    } else value.push_back(ch);\n                    break;\n            }\n        } else {\n            value.push_back(ch);\n        }\n    }\n    if (input && ch == delimiter) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool parse_number(std::istream& input, Number& value) {\n    input >> std::ws;\n    input >> value;\n    if (input.fail()) {\n        input.clear();\n        return false;\n    }\n    return true;\n}\n\nbool parse_bool(std::istream& input, Boolean& value) {\n    if (match(\"true\", input))  {\n        value = true;\n        return true;\n    }\n    if (match(\"false\", input)) {\n        value = false;\n        return true;\n    }\n    return false;\n}\n\nbool parse_null(std::istream& input) {\n    if (match(\"null\", input))  {\n        return true;\n    }\n    if (Parser == Strict) {\n        return false;\n    }\n    return (input.peek()==',');\n}\n\nbool parse_array(std::istream& input, Array& array) {\n    return array.parse(input);\n}\n\nbool parse_object(std::istream& input, Object& object) {\n    return object.parse(input);\n}\n\nbool parse_comment(std::istream &input) {\n    if( Parser == Permissive )\n    if( !input.eof() )\n    {\n        char ch0(0);\n        input.get(ch0);\n\n        if( !input.eof() )\n        {\n            char ch1(0);\n            input.get(ch1);\n\n            if( ch0 == '/' && ch1 == '/' )\n            {\n                // trim chars till \\r or \\n\n                for( char ch(0); !input.eof() && (input.peek() != '\\r' && input.peek() != '\\n'); )\n                    input.get(ch);\n\n                // consume spaces, tabs, \\r or \\n, in case no eof is found\n                if( !input.eof() )\n                    input >> std::ws;\n                return true;\n            }\n\n            input.unget();\n            input.clear();\n        }\n\n        input.unget();\n        input.clear();\n    }\n\n    return false;\n}\n\nbool parse_value(std::istream& input, Value& value) {\n    return value.parse(input);\n}\n\n\nObject::Object() : value_map_() {}\n\nObject::~Object() {\n    reset();\n}\n\nbool Object::parse(std::istream& input, Object& object) {\n    object.reset();\n\n    if (!match(\"{\", input)) {\n        return false;\n    }\n    if (match(\"}\", input)) {\n        return true;\n    }\n\n    do {\n        std::string key;\n        if (!parse_string(input, key)) {\n            if (Parser == Permissive) {\n                if (input.peek() == '}')\n                    break;\n            }\n            return false;\n        }\n        if (!match(\":\", input)) {\n            return false;\n        }\n        Value* v = new Value();\n        if (!parse_value(input, *v)) {\n            delete v;\n            break;\n        }\n        object.value_map_[key] = v;\n    } while (match(\",\", input));\n\n\n    if (!match(\"}\", input)) {\n        return false;\n    }\n\n    return true;\n}\n\nValue::Value() : type_(INVALID_) {}\n\nvoid Value::reset() {\n    if (type_ == STRING_) {\n        delete string_value_;\n        string_value_ = 0;\n    }\n    else if (type_ == OBJECT_) {\n        delete object_value_;\n        object_value_ = 0;\n    }\n    else if (type_ == ARRAY_) {\n        delete array_value_;\n        array_value_ = 0;\n    }\n}\n\nbool Value::parse(std::istream& input, Value& value) {\n    value.reset();\n\n    std::string string_value;\n    if (parse_string(input, string_value)) {\n        value.string_value_ = new std::string();\n        value.string_value_->swap(string_value);\n        value.type_ = STRING_;\n        return true;\n    }\n    if (parse_number(input, value.number_value_)) {\n        value.type_ = NUMBER_;\n        return true;\n    }\n\n    if (parse_bool(input, value.bool_value_)) {\n        value.type_ = BOOL_;\n        return true;\n    }\n    if (parse_null(input)) {\n        value.type_ = NULL_;\n        return true;\n    }\n    if (input.peek() == '[') {\n        value.array_value_ = new Array();\n        if (parse_array(input, *value.array_value_)) {\n            value.type_ = ARRAY_;\n            return true;\n        }\n        delete value.array_value_;\n    }\n    value.object_value_ = new Object();\n    if (parse_object(input, *value.object_value_)) {\n        value.type_ = OBJECT_;\n        return true;\n    }\n    delete value.object_value_;\n    return false;\n}\n\nArray::Array() : values_() {}\n\nArray::~Array() {\n    reset();\n}\n\nbool Array::parse(std::istream& input, Array& array) {\n    array.reset();\n\n    if (!match(\"[\", input)) {\n        return false;\n    }\n\n    do {\n        Value* v = new Value();\n        if (!parse_value(input, *v)) {\n            delete v;\n            break;\n        }\n        array.values_.push_back(v);\n    } while (match(\",\", input));\n\n    if (!match(\"]\", input)) {\n        return false;\n    }\n    return true;\n}\n\nstatic std::ostream& stream_string(std::ostream& stream,\n                                   const std::string& string) {\n    stream << '\"';\n    for (std::string::const_iterator i = string.begin(),\n                 e = string.end(); i != e; ++i) {\n        switch (*i) {\n            case '\"':\n                stream << \"\\\\\\\"\";\n                break;\n            case '\\\\':\n                stream << \"\\\\\\\\\";\n                break;\n            case '/':\n                stream << \"\\\\/\";\n                break;\n            case '\\b':\n                stream << \"\\\\b\";\n                break;\n            case '\\f':\n                stream << \"\\\\f\";\n                break;\n            case '\\n':\n                stream << \"\\\\n\";\n                break;\n            case '\\r':\n                stream << \"\\\\r\";\n                break;\n            case '\\t':\n                stream << \"\\\\t\";\n                break;\n            default:\n                if (*i < 32) {\n                    stream << \"\\\\u\" << std::hex << std::setw(4) <<\n                            std::setfill('0') << static_cast<int>(*i) << std::dec <<\n                            std::setw(0);\n                } else {\n                    stream << *i;\n                }\n        }\n    }\n    stream << '\"';\n    return stream;\n}\n\n}  // namespace jsonxx\n\nstd::ostream& operator<<(std::ostream& stream, const jsonxx::Value& v) {\n    using namespace jsonxx;\n    if (v.is<Number>()) {\n        return stream << v.get<Number>();\n    } else if (v.is<String>()) {\n        return stream_string(stream, v.get<std::string>());\n    } else if (v.is<Boolean>()) {\n        if (v.get<Boolean>()) {\n            return stream << \"true\";\n        } else {\n            return stream << \"false\";\n        }\n    } else if (v.is<Null>()) {\n        return stream << \"null\";\n    } else if (v.is<Object>()) {\n        return stream << v.get<Object>();\n    } else if (v.is<Array>()){\n        return stream << v.get<Array>();\n    }\n    // Shouldn't reach here.\n    return stream;\n}\n\nstd::ostream& operator<<(std::ostream& stream, const jsonxx::Array& v) {\n    stream << \"[\";\n    jsonxx::Array::container::const_iterator\n        it = v.values().begin(),\n        end = v.values().end();\n    while (it != end) {\n        stream << *(*it);\n        ++it;\n        if (it != end) {\n            stream << \", \";\n        }\n    }\n    return stream << \"]\";\n}\n\nstd::ostream& operator<<(std::ostream& stream, const jsonxx::Object& v) {\n    stream << \"{\";\n    jsonxx::Object::container::const_iterator\n        it = v.kv_map().begin(),\n        end = v.kv_map().end();\n    while (it != end) {\n        jsonxx::stream_string(stream, it->first);\n        stream << \": \" << *(it->second);\n        ++it;\n        if (it != end) {\n            stream << \", \";\n        }\n    }\n    return stream << \"}\";\n}\n\n\nnamespace jsonxx {\nnamespace {\n\ntypedef unsigned char byte;\n\n//template<bool quote>\nstd::string escape_string( const std::string &input, const bool quote = false ) {\n    static std::string map[256], *once = 0;\n    if( !once ) {\n        // base\n        for( int i = 0; i < 256; ++i ) {\n            map[ i ] = std::string() + char(i);\n        }\n        // non-printable\n        for( int i = 0; i < 32; ++i ) {\n            std::stringstream str;\n            str << \"\\\\u\" << std::hex << std::setw(4) << std::setfill('0') << i;\n            map[ i ] = str.str();\n        }\n        // exceptions\n        map[ byte('\"') ] = \"\\\\\\\"\";\n        map[ byte('\\\\') ] = \"\\\\\\\\\";\n        map[ byte('/') ] = \"\\\\/\";\n        map[ byte('\\b') ] = \"\\\\b\";\n        map[ byte('\\f') ] = \"\\\\f\";\n        map[ byte('\\n') ] = \"\\\\n\";\n        map[ byte('\\r') ] = \"\\\\r\";\n        map[ byte('\\t') ] = \"\\\\t\";\n\n        once = map;\n    }\n    std::string output;\n    output.reserve( input.size() * 2 + 2 ); // worst scenario\n    if( quote ) output += '\"';\n    for( std::string::const_iterator it = input.begin(), end = input.end(); it != end; ++it )\n        output += map[ byte(*it) ];\n    if( quote ) output += '\"';\n    return output;\n}\n\n\nnamespace json {\n\n    std::string remove_last_comma( const std::string &_input ) {\n        std::string input( _input );\n        size_t size = input.size();\n        if( size > 2 )\n            if( input[ size - 2 ] == ',' )\n                input[ size - 2 ] = ' ';\n        return input;\n    }\n\n    std::string tag( unsigned format, unsigned depth, const std::string &name, const jsonxx::Value &t) {\n        std::stringstream ss;\n        const std::string tab(depth, '\\t');\n\n        if( !name.empty() )\n            ss << tab << '\\\"' << escape_string( name ) << '\\\"' << ':' << ' ';\n        else\n            ss << tab;\n\n        switch( t.type_ )\n        {\n            default:\n            case jsonxx::Value::NULL_:\n                ss << \"null\";\n                return ss.str() + \",\\n\";\n\n            case jsonxx::Value::BOOL_:\n                ss << ( t.bool_value_ ? \"true\" : \"false\" );\n                return ss.str() + \",\\n\";\n\n            case jsonxx::Value::ARRAY_:\n                ss << \"[\\n\";\n                for(Array::container::const_iterator it = t.array_value_->values().begin(),\n                    end = t.array_value_->values().end(); it != end; ++it )\n                  ss << tag( format, depth+1, std::string(), **it );\n                return remove_last_comma( ss.str() ) + tab + \"]\" \",\\n\";\n\n            case jsonxx::Value::STRING_:\n                ss << '\\\"' << escape_string( *t.string_value_ ) << '\\\"';\n                return ss.str() + \",\\n\";\n\n            case jsonxx::Value::OBJECT_:\n                ss << \"{\\n\";\n                for(Object::container::const_iterator it=t.object_value_->kv_map().begin(),\n                    end = t.object_value_->kv_map().end(); it != end ; ++it)\n                  ss << tag( format, depth+1, it->first, *it->second );\n                return remove_last_comma( ss.str() ) + tab + \"}\" \",\\n\";\n\n            case jsonxx::Value::NUMBER_:\n                // max precision\n                ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1);\n                ss << t.number_value_;\n                return ss.str() + \",\\n\";\n        }\n    }\n} // namespace jsonxx::anon::json\n\nnamespace xml {\n\nstd::string escape_attrib( const std::string &input ) {\n    static std::string map[256], *once = 0;\n    if( !once ) {\n        for( int i = 0; i < 256; ++i )\n            map[ i ] = \"_\";\n        for( int i = int('a'); i < int('z'); ++i )\n            map[ i ] = std::string() + char(i);\n        for( int i = int('A'); i < int('Z'); ++i )\n            map[ i ] = std::string() + char(i);\n        for( int i = int('0'); i < int('9'); ++i )\n            map[ i ] = std::string() + char(i);\n        once = map;\n    }\n    std::string output;\n    output.reserve( input.size() ); // worst scenario\n    for( std::string::const_iterator it = input.begin(), end = input.end(); it != end; ++it )\n        output += map[ byte(*it) ];\n    return output;\n}\n\nstd::string escape_tag( const std::string &input, unsigned format ) {\n    static std::string map[256], *once = 0;\n    if( !once ) {\n        for( int i = 0; i < 256; ++i )\n            map[ i ] = std::string() + char(i);\n        map[ byte('<') ] = \"&lt;\";\n        map[ byte('>') ] = \"&gt;\";\n\n        switch( format )\n        {\n            default:\n                break;\n\n            case jsonxx::JXML:\n            case jsonxx::JXMLex:\n            case jsonxx::JSONx:\n            case jsonxx::TaggedXML:\n                map[ byte('&') ] = \"&amp;\";\n                break;\n        }\n\n        once = map;\n    }\n    std::string output;\n    output.reserve( input.size() * 5 ); // worst scenario\n    for( std::string::const_iterator it = input.begin(), end = input.end(); it != end; ++it )\n        output += map[ byte(*it) ];\n    return output;\n}\n\nstd::string open_tag( unsigned format, char type, const std::string &name, const std::string &attr = std::string(), const std::string &text = std::string() ) {\n    std::string tagname;\n    switch( format )\n    {\n        default:\n            return std::string();\n\n        case jsonxx::JXML:\n            if( name.empty() )\n                tagname = std::string(\"j son=\\\"\") + type + '\\\"';\n            else\n                tagname = std::string(\"j son=\\\"\") + type + ':' + escape_string(name) + '\\\"';\n            break;\n\n        case jsonxx::JXMLex:\n            if( name.empty() )\n                tagname = std::string(\"j son=\\\"\") + type + '\\\"';\n            else\n                tagname = std::string(\"j son=\\\"\") + type + ':' + escape_string(name) + \"\\\" \" + escape_attrib(name) + \"=\\\"\" + escape_string(text) + \"\\\"\";\n            break;\n\n        case jsonxx::JSONx:\n            if( !name.empty() )\n                tagname = std::string(\" name=\\\"\") + escape_string(name) + \"\\\"\";\n            switch( type ) {\n                default:\n                case '0': tagname = \"json:null\" + tagname; break;\n                case 'b': tagname = \"json:boolean\" + tagname; break;\n                case 'a': tagname = \"json:array\" + tagname; break;\n                case 's': tagname = \"json:string\" + tagname; break;\n                case 'o': tagname = \"json:object\" + tagname; break;\n                case 'n': tagname = \"json:number\" + tagname; break;\n            }\n            break;\n\n        case jsonxx::TaggedXML: // @TheMadButcher\n            if( !name.empty() )\n                tagname = escape_attrib(name);\n            else\n                tagname = \"JsonItem\";\n            switch( type ) {\n                default:\n                case '0': tagname += \" type=\\\"json:null\\\"\"; break;\n                case 'b': tagname += \" type=\\\"json:boolean\\\"\"; break;\n                case 'a': tagname += \" type=\\\"json:array\\\"\"; break;\n                case 's': tagname += \" type=\\\"json:string\\\"\"; break;\n                case 'o': tagname += \" type=\\\"json:object\\\"\"; break;\n                case 'n': tagname += \" type=\\\"json:number\\\"\"; break;\n            }\n\n            if( !name.empty() )\n                tagname += std::string(\" name=\\\"\") + escape_string(name) + \"\\\"\";\n\n            break;\n    }\n\n    return std::string(\"<\") + tagname + attr + \">\";\n}\n\nstd::string close_tag( unsigned format, char type, const std::string &name ) {\n    switch( format )\n    {\n        default:\n            return std::string();\n\n        case jsonxx::JXML:\n        case jsonxx::JXMLex:\n            return \"</j>\";\n\n        case jsonxx::JSONx:\n            switch( type ) {\n                default:\n                case '0': return \"</json:null>\";\n                case 'b': return \"</json:boolean>\";\n                case 'a': return \"</json:array>\";\n                case 'o': return \"</json:object>\";\n                case 's': return \"</json:string>\";\n                case 'n': return \"</json:number>\";\n            }\n            break;\n\n        case jsonxx::TaggedXML: // @TheMadButcher\n            if( !name.empty() )\n                return \"</\"+escape_attrib(name)+\">\";\n            else\n                return \"</JsonItem>\";\n    }\n}\n\nstd::string tag( unsigned format, unsigned depth, const std::string &name, const jsonxx::Value &t, const std::string &attr = std::string() ) {\n    std::stringstream ss;\n    const std::string tab(depth, '\\t');\n\n    switch( t.type_ )\n    {\n        default:\n        case jsonxx::Value::NULL_:\n            return tab + open_tag( format, '0', name, \" /\" ) + '\\n';\n\n        case jsonxx::Value::BOOL_:\n            ss << ( t.bool_value_ ? \"true\" : \"false\" );\n            return tab + open_tag( format, 'b', name, std::string(), format == jsonxx::JXMLex ? ss.str() : std::string() )\n                       + ss.str()\n                       + close_tag( format, 'b', name ) + '\\n';\n\n        case jsonxx::Value::ARRAY_:\n            for(Array::container::const_iterator it = t.array_value_->values().begin(),\n                end = t.array_value_->values().end(); it != end; ++it )\n              ss << tag( format, depth+1, std::string(), **it );\n            return tab + open_tag( format, 'a', name, attr ) + '\\n'\n                       + ss.str()\n                 + tab + close_tag( format, 'a', name ) + '\\n';\n\n        case jsonxx::Value::STRING_:\n            ss << escape_tag( *t.string_value_, format );\n            return tab + open_tag( format, 's', name, std::string(), format == jsonxx::JXMLex ? ss.str() : std::string() )\n                       + ss.str()\n                       + close_tag( format, 's', name ) + '\\n';\n\n        case jsonxx::Value::OBJECT_:\n            for(Object::container::const_iterator it=t.object_value_->kv_map().begin(),\n                end = t.object_value_->kv_map().end(); it != end ; ++it)\n              ss << tag( format, depth+1, it->first, *it->second );\n            return tab + open_tag( format, 'o', name, attr ) + '\\n'\n                       + ss.str()\n                 + tab + close_tag( format, 'o', name ) + '\\n';\n\n        case jsonxx::Value::NUMBER_:\n            // max precision\n            ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1);\n            ss << t.number_value_;\n            return tab + open_tag( format, 'n', name, std::string(), format == jsonxx::JXMLex ? ss.str() : std::string() )\n                       + ss.str()\n                       + close_tag( format, 'n', name ) + '\\n';\n    }\n}\n\n// order here matches jsonxx::Format enum\nconst char *defheader[] = {\n    \"\",\n\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n         JSONXX_XML_TAG \"\\n\",\n\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n         JSONXX_XML_TAG \"\\n\",\n\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n         JSONXX_XML_TAG \"\\n\",\n\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n         JSONXX_XML_TAG \"\\n\"\n};\n\n// order here matches jsonxx::Format enum\nconst char *defrootattrib[] = {\n    \"\",\n\n    \" xsi:schemaLocation=\\\"http://www.datapower.com/schemas/json jsonx.xsd\\\"\"\n        \" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\"\n        \" xmlns:json=\\\"http://www.ibm.com/xmlns/prod/2009/jsonx\\\"\",\n\n    \"\",\n\n    \"\",\n\n    \"\"\n};\n\n} // namespace jsonxx::anon::xml\n\n} // namespace jsonxx::anon\n\nstd::string Object::json() const {\n    using namespace json;\n\n    jsonxx::Value v;\n    v.object_value_ = const_cast<jsonxx::Object*>(this);\n    v.type_ = jsonxx::Value::OBJECT_;\n\n    std::string result = tag( jsonxx::JSON, 0, std::string(), v );\n\n    v.object_value_ = 0;\n    return remove_last_comma( result );\n}\n\nstd::string Object::xml( unsigned format, const std::string &header, const std::string &attrib ) const {\n    using namespace xml;\n    JSONXX_ASSERT( format == jsonxx::JSONx || format == jsonxx::JXML || format == jsonxx::JXMLex || format == jsonxx::TaggedXML );\n\n    jsonxx::Value v;\n    v.object_value_ = const_cast<jsonxx::Object*>(this);\n    v.type_ = jsonxx::Value::OBJECT_;\n\n    std::string result = tag( format, 0, std::string(), v, attrib.empty() ? std::string(defrootattrib[format]) : attrib );\n\n    v.object_value_ = 0;\n    return ( header.empty() ? std::string(defheader[format]) : header ) + result;\n}\n\nstd::string Array::json() const {\n    using namespace json;\n\n    jsonxx::Value v;\n    v.array_value_ = const_cast<jsonxx::Array*>(this);\n    v.type_ = jsonxx::Value::ARRAY_;\n\n    std::string result = tag( jsonxx::JSON, 0, std::string(), v );\n\n    v.array_value_ = 0;\n    return remove_last_comma( result );\n}\n\nstd::string Array::xml( unsigned format, const std::string &header, const std::string &attrib ) const {\n    using namespace xml;\n    JSONXX_ASSERT( format == jsonxx::JSONx || format == jsonxx::JXML || format == jsonxx::JXMLex || format == jsonxx::TaggedXML );\n\n    jsonxx::Value v;\n    v.array_value_ = const_cast<jsonxx::Array*>(this);\n    v.type_ = jsonxx::Value::ARRAY_;\n\n    std::string result = tag( format, 0, std::string(), v, attrib.empty() ? std::string(defrootattrib[format]) : attrib );\n\n    v.array_value_ = 0;\n    return ( header.empty() ? std::string(defheader[format]) : header ) + result;\n}\n\nbool validate( std::istream &input ) {\n\n    // trim non-printable chars\n    for( char ch(0); !input.eof() && input.peek() <= 32; )\n        input.get(ch);\n\n    // validate json\n    if( input.peek() == '{' )\n    {\n        jsonxx::Object o;\n        if( parse_object( input, o ) )\n            return true;\n    }\n    else\n    if( input.peek() == '[' )\n    {\n        jsonxx::Array a;\n        if( parse_array( input, a ) )\n            return true;\n    }\n\n    // bad json input\n    return false;\n}\n\nbool validate( const std::string &input ) {\n    std::istringstream is( input );\n    return jsonxx::validate( is );\n}\n\nstd::string xml( std::istream &input, unsigned format ) {\n    using namespace xml;\n    JSONXX_ASSERT( format == jsonxx::JSONx || format == jsonxx::JXML || format == jsonxx::JXMLex || format == jsonxx::TaggedXML );\n\n    // trim non-printable chars\n    for( char ch(0); !input.eof() && input.peek() <= 32; )\n        input.get(ch);\n\n    // validate json, then transform\n    if( input.peek() == '{' )\n    {\n        jsonxx::Object o;\n        if( parse_object( input, o ) )\n            return o.xml(format);\n    }\n    else\n    if( input.peek() == '[' )\n    {\n        jsonxx::Array a;\n        if( parse_array( input, a ) )\n            return a.xml(format);\n    }\n\n    // bad json, return empty xml\n    return defheader[format];\n}\n\nstd::string xml( const std::string &input, unsigned format ) {\n    std::istringstream is( input );\n    return jsonxx::xml( is, format );\n}\n\n\nObject::Object(const Object &other) {\n  import(other);\n}\nObject::Object(const std::string &key, const Value &value) {\n  import(key,value);\n}\nvoid Object::import( const Object &other ) {\n  odd.clear();\n  if (this != &other) {\n    // default\n    container::const_iterator\n        it = other.value_map_.begin(),\n        end = other.value_map_.end();\n    for (/**/ ; it != end ; ++it) {\n      container::iterator found = value_map_.find(it->first);\n      if( found != value_map_.end() ) {\n        delete found->second;\n      }\n      value_map_[ it->first ] = new Value( *it->second );\n    }\n  } else {\n    // recursion is supported here\n    import( Object(*this) );\n  }\n}\nvoid Object::import( const std::string &key, const Value &value ) {\n  odd.clear();\n  container::iterator found = value_map_.find(key);\n  if( found != value_map_.end() ) {\n    delete found->second;\n  }\n  value_map_[ key ] = new Value( value );\n}\nObject &Object::operator=(const Object &other) {\n  odd.clear();\n  if (this != &other) {\n    reset();\n    import(other);\n  }\n  return *this;\n}\nObject &Object::operator<<(const Value &value) {\n  if (odd.empty()) {\n    odd = value.get<String>();\n  } else {\n    import( Object(odd, value) );\n    odd.clear();\n  }\n  return *this;\n}\nObject &Object::operator<<(const Object &value) {\n  import( std::string(odd),value);\n  odd.clear();\n  return *this;\n}\nsize_t Object::size() const {\n  return value_map_.size();\n}\nbool Object::empty() const {\n  return value_map_.size() == 0;\n}\nconst std::map<std::string, Value*> &Object::kv_map() const {\n  return value_map_;\n}\nstd::string Object::write( unsigned format ) const {\n  return format == JSON ? json() : xml(format);\n}\nvoid Object::reset() {\n  container::iterator i;\n  for (i = value_map_.begin(); i != value_map_.end(); ++i) {\n    delete i->second;\n  }\n  value_map_.clear();\n}\nbool Object::parse(std::istream &input) {\n  return parse(input,*this);\n}\nbool Object::parse(const std::string &input) {\n  std::istringstream is( input );\n  return parse(is,*this);\n}\n\n\nArray::Array(const Array &other) {\n  import(other);\n}\nArray::Array(const Value &value) {\n  import(value);\n}\nvoid Array::import(const Array &other) {\n  if (this != &other) {\n    // default\n    container::const_iterator\n        it = other.values_.begin(),\n        end = other.values_.end();\n    for (/**/ ; it != end; ++it) {\n      values_.push_back( new Value(**it) );\n    }\n  } else {\n    // recursion is supported here\n    import( Array(*this) );\n  }\n}\nvoid Array::import(const Value &value) {\n  values_.push_back( new Value(value) );\n}\nsize_t Array::size() const {\n  return values_.size();\n}\nbool Array::empty() const {\n  return values_.size() == 0;\n}\nvoid Array::reset() {\n  for (container::iterator i = values_.begin(); i != values_.end(); ++i) {\n    delete *i;\n  }\n  values_.clear();\n}\nbool Array::parse(std::istream &input) {\n  return parse(input,*this);\n}\nbool Array::parse(const std::string &input) {\n  std::istringstream is(input);\n  return parse(is,*this);\n}\nArray &Array::operator<<(const Array &other) {\n  import(other);\n  return *this;\n}\nArray &Array::operator<<(const Value &value) {\n  import(value);\n  return *this;\n}\nArray &Array::operator=(const Array &other) {\n  if( this != &other ) {\n    reset();\n    import(other);\n  }\n  return *this;\n}\nArray &Array::operator=(const Value &value) {\n  reset();\n  import(value);\n  return *this;\n}\n\nValue::Value(const Value &other) : type_(INVALID_) {\n  import( other );\n}\nbool Value::empty() const {\n  if( type_ == INVALID_ ) return true;\n  if( type_ == STRING_ && string_value_ == 0 ) return true;\n  if( type_ == ARRAY_ && array_value_ == 0 ) return true;\n  if( type_ == OBJECT_ && object_value_ == 0 ) return true;\n  return false;\n}\nbool Value::parse(std::istream &input) {\n  return parse(input,*this);\n}\nbool Value::parse(const std::string &input) {\n  std::istringstream is( input );\n  return parse(is,*this);\n}\n\n}  // namespace jsonxx\n"]}